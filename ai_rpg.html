<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üíñ AI Galgame | üå∏ ÊàëÁöÑ‰∫åÊ¨°ÂÖÉÂ∞èÁ™ù üå∏</title>
    <link rel="stylesheet" href="css/style.css"> <!-- Link to main style -->
    <!-- Marked.js for Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- DOMPurify for security -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.10/purify.min.js"></script>

    <style>
        /* --- Galgame Specific Styles (Unchanged from previous version) --- */
        /* Main container */
        #galgame-container {
            position: relative;
            width: 100%;
            height: calc(100vh - 100px); /* Example: Full viewport height minus approximate header/footer */
            min-height: 500px; /* Minimum height */
            overflow: hidden;
            border-radius: 15px;
            box-shadow: 0 5px 20px var(--galgame-container-shadow, rgba(0,0,0,0.2));
            margin-top: 20px;
        }

        /* Background Image */
        #game-background {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--content-bg); /* Fallback color */
            background-size: cover; background-position: center; z-index: 1;
            transition: background-image 0.8s ease-in-out; /* Smoother transition */
            background-image: url('https://image.pollinations.ai/prompt/beautiful%20anime%20classroom%20background,%20large%20windows,%20sunlight%20streaming%20in,%20empty,%20detailed,%20peaceful%20atmosphere?width=1024&height=576&seed=101&nologo=true');
        }

        /* --- Character Sprite Areas --- */
        .character-area {
            position: absolute;
            bottom: 5%;
            height: 65%;
            width: auto; /* Allow width to adjust based on height */
            max-width: 40%; /* Limit width slightly more to fit two */
            z-index: 3;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
        }

        /* AI Character (Right Side) */
        #ai-character-area {
            right: 5%; /* Position on the right */
            transform: none; /* Remove horizontal centering */
        }

        /* Player Character (Left Side) */
        #player-character-area {
            left: 5%; /* Position on the left */
            transform: none; /* Remove horizontal centering */
        }

        .character-sprite {
            display: block;
            max-height: 100%;
            max-width: 100%;
            height: auto;
            width: auto;
            object-fit: contain;
            filter: drop-shadow(3px 5px 8px rgba(0,0,0,0.4));
            transition: transform 0.4s ease, opacity 0.5s ease;
            opacity: 1;
        }
        /* Class to hide sprites */
        .character-sprite.hidden {
            opacity: 0;
            transform: scale(0.95);
        }
        /* Specific ID for AI sprite if needed */
        #ai-character-sprite { }
        /* Specific ID for Player sprite */
        #player-character-sprite {
            /* Flip horizontally if desired */
             /* transform: scaleX(-1); */
        }


        /* Dialogue Box */
        #dialogue-box {
            position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 950px;
            min-height: 140px; max-height: 38%;
            background: var(--galgame-dialogue-bg);
            backdrop-filter: var(--galgame-dialogue-backdrop-filter);
            border-radius: 12px;
            border: 1px solid var(--galgame-dialogue-border);
            padding: 20px 30px;
            color: var(--galgame-dialogue-text-color);
            z-index: 4; overflow-y: auto;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            scrollbar-width: thin;
            scrollbar-color: var(--galgame-scrollbar-thumb-bg) var(--galgame-scrollbar-track-bg);
        }
         #dialogue-box::-webkit-scrollbar { width: 8px; }
         #dialogue-box::-webkit-scrollbar-track { background: var(--galgame-scrollbar-track-bg); border-radius: 4px;}
         #dialogue-box::-webkit-scrollbar-thumb { background-color: var(--galgame-scrollbar-thumb-bg); border-radius: 4px; border: 1px solid rgba(0, 0, 0, 0.3); }
         #dialogue-box::-webkit-scrollbar-thumb:hover { background-color: var(--galgame-scrollbar-thumb-hover-bg); }

        #speaker-name {
            font-weight: bold; margin-bottom: 10px;
            color: var(--galgame-speaker-name-color);
            font-size: 1.15em;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        #dialogue-text { line-height: 1.7; font-size: 1.05em; }
        /* Markdown Styles (Keep as before) */
         #dialogue-text p { margin-bottom: 0.8em;}
         #dialogue-text h1, #dialogue-text h2, #dialogue-text h3 { margin-top: 0.5em; margin-bottom: 0.3em; color: var(--galgame-config-link-color); }
         #dialogue-text strong { color: var(--galgame-speaker-name-color); }
         #dialogue-text em { color: #90ee90; }
         #dialogue-text ul, #dialogue-text ol { padding-left: 25px; margin-bottom: 0.8em;}
         #dialogue-text li { margin-bottom: 0.3em;}
         #dialogue-text code { background-color: rgba(255,255,255,0.1); padding: 2px 5px; border-radius: 4px; font-family: 'Courier New', Courier, monospace; color: #f0f0f0; }
         #dialogue-text pre { background-color: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; overflow-x: auto; margin-bottom: 0.8em; }
         #dialogue-text pre code { background: none; padding: 0; }
         #dialogue-text blockquote { border-left: 3px solid var(--galgame-control-btn-bg); padding-left: 10px; margin: 0.8em 0; color: #ccc; font-style: italic; }
         #dialogue-text a { color: var(--galgame-config-link-color); text-decoration: underline; }
         #dialogue-text a:hover { filter: brightness(1.2); }

        /* Game Controls */
        #game-controls {
            position: absolute; bottom: 25px; right: 30px; z-index: 5;
            display: flex; gap: 12px; align-items: center;
        }
        .control-button {
             padding: 10px 20px; border: none; border-radius: 20px;
             background: var(--galgame-control-btn-bg); color: var(--galgame-control-btn-color);
             cursor: pointer; transition: all 0.3s ease; font-size: 1em; font-weight: 500;
             box-shadow: 0 4px 10px var(--shadow-color-medium); border: 1px solid var(--galgame-control-btn-border);
             backdrop-filter: blur(3px);
         }
         .control-button:hover:not(:disabled) { background: var(--galgame-control-btn-hover-bg); box-shadow: 0 6px 15px var(--shadow-color-dark); transform: translateY(-2px); }
         .control-button:disabled { background: var(--text-color-lighter); cursor: not-allowed; box-shadow: none; opacity: 0.7; }
         #toggle-history-btn { background: var(--galgame-history-btn-bg); color: var(--galgame-history-btn-color); }
         #toggle-history-btn:hover:not(:disabled) { background: var(--galgame-history-btn-hover-bg); }

        /* Choices Container */
        #choices-container { display: flex; flex-direction: column; gap: 10px; margin-top: 15px; }
        .choice-button {
             display: block; width: 100%; text-align: left; padding: 10px 15px;
             border: 1px solid var(--galgame-choice-btn-border); border-radius: 8px;
             background: var(--galgame-choice-btn-bg); color: var(--galgame-choice-btn-color);
             cursor: pointer; transition: background-color 0.3s ease; font-size: 0.95em;
         }
         .choice-button:hover { background: var(--galgame-choice-btn-hover-bg); }

        /* Config Panel & Contents */
        #config-panel {
            position: absolute; top: 10px; right: 10px; width: 350px; /* Wider */
            background: var(--galgame-config-bg);
            backdrop-filter: var(--galgame-config-backdrop-filter);
            border-radius: 8px; padding: 20px; z-index: 10; color: var(--galgame-config-text-color);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); border: 1px solid var(--galgame-config-border);
            display: none; font-size: 0.9em; max-height: 80vh; overflow-y: auto; /* Allow scrolling */
        }
        #config-panel.visible { display: block; }
        #config-panel h3 { margin-top: 0; margin-bottom: 15px; text-align: center; color: var(--galgame-config-link-color); }
        #config-panel .form-group { margin-bottom: 15px; }
        #config-panel label { color: var(--galgame-config-label-color); margin-bottom: 5px; font-size: 0.95em; display: block;} /* Ensure label is block */
        #config-panel input[type="text"], #config-panel input[type="password"],
        #config-panel input[type="url"], #config-panel .select-wrapper select,
        #config-panel textarea {
            width: 100%; padding: 8px 10px; border: 1px solid var(--galgame-config-input-border);
            border-radius: 5px; background: var(--galgame-config-input-bg); color: var(--galgame-config-text-color);
            font-size: 1em; box-sizing: border-box; font-family: inherit;
             appearance: none; -webkit-appearance: none; -moz-appearance: none;
        }
         #config-panel textarea { min-height: 60px; } /* Give textareas a min height */
        #config-panel .select-wrapper::after { color: var(--galgame-config-label-color); }
        #config-panel .config-buttons { display: flex; justify-content: space-between; margin-top: 20px; }
        #config-panel button { padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.3s; font-size: 0.9em; }
        #save-config-btn { background-color: var(--galgame-save-btn-bg); color: white;} #save-config-btn:hover { background-color: var(--galgame-save-btn-hover-bg);}
        #close-config-btn { background-color: var(--galgame-close-btn-bg); color: white;} #close-config-btn:hover { background-color: var(--galgame-close-btn-hover-bg);}
        #key-status { font-size: 0.85em; margin-top: 5px; display: inline-block; height: 1.2em; }
        #key-status.testing { color: #ffc107; } #key-status.valid { color: #28a745; }
        #key-status.invalid { color: #dc3545; } #key-status.error { color: #ff8aae; }
        #toggle-config-btn {
            position: absolute; top: 20px; right: 20px; z-index: 15;
             background: var(--button-glass-bg); color: var(--button-primary-text); border: 1px solid var(--border-color-light);
             border-radius: 50%; width: 40px; height: 40px; font-size: 20px; cursor: pointer;
             backdrop-filter: blur(5px); transition: all 0.3s ease; display: flex; justify-content: center; align-items: center;
         }
         #toggle-config-btn:hover { background: var(--button-glass-hover-bg); transform: scale(1.1) rotate(45deg); }

        /* Loading & Error Overlays (Keep as before) */
        #game-loading-overlay { background: var(--galgame-loading-bg); color: var(--galgame-loading-text-color); position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 9; display: none; justify-content: center; align-items: center; font-size: 1.5em; text-align: center; border-radius: 15px;}
        #game-loading-overlay.visible { display: flex; }
        #game-loading-overlay span { animation: pulse 1.5s infinite ease-in-out; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        #game-error-message { background: var(--galgame-error-bg); color: var(--galgame-error-text-color); position: absolute; top: 10px; left: 50%; transform: translateX(-50%); padding: 10px 20px; border-radius: 8px; z-index: 11; display: none; font-size: 0.95em; box-shadow: 0 3px 10px rgba(0,0,0,0.2); }

        /* History Panel (Keep as before, display logic modified in JS) */
        #history-panel {
            background: var(--galgame-history-panel-bg); backdrop-filter: var(--galgame-history-panel-backdrop-filter);
            border: 1px solid var(--galgame-history-panel-border); color: var(--galgame-history-panel-text-color);
            position: absolute; top: 10%; left: 50%; transform: translateX(-50%); width: 70%; max-width: 700px; height: 70%; max-height: 600px; border-radius: 10px; padding: 25px; z-index: 12; box-shadow: 0 5px 25px rgba(0,0,0,0.4); display: none; flex-direction: column; font-size: 0.95em;
        }
        #history-panel.visible { display: flex; }
        #history-panel h3 { color: var(--galgame-history-panel-title-color); margin-top: 0; margin-bottom: 15px; text-align: center; flex-shrink: 0;}
        #history-content {
            flex-grow: 1; overflow-y: auto; padding-right: 10px; margin-bottom: 15px; line-height: 1.6;
            scrollbar-color: var(--galgame-history-scrollbar-thumb-bg) var(--galgame-history-scrollbar-track-bg);
        }
        #history-content::-webkit-scrollbar { width: 8px; }
        #history-content::-webkit-scrollbar-track { background: var(--galgame-history-scrollbar-track-bg); border-radius: 4px; }
        #history-content::-webkit-scrollbar-thumb { background-color: var(--galgame-history-scrollbar-thumb-bg); border-radius: 4px; border: 1px solid rgba(0, 0, 0, 0.5); }
        #history-content::-webkit-scrollbar-thumb:hover { background-color: var(--galgame-history-scrollbar-thumb-hover-bg); }
        #history-content .history-entry { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px dashed rgba(255, 255, 255, 0.15); }
        #history-content .history-entry:last-child { border-bottom: none; }
        #history-content .history-role-user { font-weight: bold; color: var(--galgame-history-role-user-color); margin-bottom: 5px; }
        #history-content .history-role-model { font-weight: bold; color: var(--galgame-history-role-model-color); margin-bottom: 5px; }
        /* Nested history text for segments */
        #history-content .history-dialogue-segment { margin-left: 10px; margin-bottom: 5px; font-size: 0.98em; }
        #history-content .history-dialogue-segment .segment-speaker { font-weight: bold; color: var(--galgame-speaker-name-color); margin-right: 5px; }
        #history-content .history-dialogue-segment .segment-text {}
        #history-content .history-dialogue-segment .segment-text p {margin-bottom: 0.3em;} /* Adjust spacing in history */


        #close-history-btn {
             background-color: var(--galgame-history-close-btn-bg); color: white;
             padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.3s; font-size: 0.9em; align-self: center; flex-shrink: 0;
        }
        #close-history-btn:hover { background-color: var(--galgame-history-close-btn-hover-bg); }

        /* Config Section Styles */
        .config-section { border: 1px dashed var(--galgame-config-input-border); padding: 15px; margin-bottom: 20px; border-radius: 8px; background: rgba(10, 10, 10, 0.1); }
        body.theme-dark .config-section { background: rgba(200, 200, 220, 0.05); }
        .config-section h4 { margin-top: 0; margin-bottom: 10px; color: var(--galgame-config-link-color); border-bottom: 1px solid var(--galgame-config-input-border); padding-bottom: 5px; }
        .form-grid { display: grid; grid-template-columns: 1fr; gap: 15px; }
        .api-key-wrapper { position: relative; display: flex; align-items: center; }
        .api-key-wrapper input { padding-right: 45px; flex-grow: 1; }
        #toggle-api-key-visibility { position: absolute; right: 1px; top: 50%; transform: translateY(-50%); background: none; border: none; cursor: pointer; padding: 10px; color: var(--galgame-config-label-color); font-size: 1.2em; line-height: 1; opacity: 0.7; transition: opacity 0.2s; }
        #toggle-api-key-visibility:hover { opacity: 1; color: var(--galgame-config-text-color); }
        .api-url-wrapper { display: flex; gap: 0; align-items: stretch; }
        .api-url-wrapper input[type="url"] { flex-grow: 1; border-top-right-radius: 0; border-bottom-right-radius: 0; border-right: none; }
        #fetch-models-btn { flex-shrink: 0; padding: 8px 15px; border: 1px solid var(--galgame-config-input-border); border-left: none; border-top-left-radius: 0; border-bottom-left-radius: 0; background: var(--galgame-control-btn-bg); color: var(--galgame-control-btn-color); cursor: pointer; font-weight: 500; font-size: 0.9em; transition: all 0.3s ease; height: auto; }
        #fetch-models-btn:hover { background: var(--galgame-control-btn-hover-bg); }
        #fetch-models-btn:disabled { background: rgba(255,255,255,0.1); color: var(--galgame-config-label-color); box-shadow: none; opacity: 0.5; }
        #model-loading-indicator { margin-left: 8px; color: var(--galgame-config-label-color); font-size: 1.2em; vertical-align: middle; display: none; }
        .input-hint { font-size: 0.85em; color: var(--galgame-config-label-color); display:block; margin-top: 5px; opacity: 0.8; }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
             #galgame-container { height: calc(100vh - 80px); }
             .character-area { height: 55%; max-width: 45%; } /* Adjust width for smaller screens */
             #dialogue-box { width: 95%; min-height: 120px; max-height: 45%; padding: 15px 20px; }
             #speaker-name { font-size: 1.05em; } #dialogue-text { font-size: 0.95em; }
             #game-controls { bottom: 15px; right: 15px; gap: 8px; } .control-button { padding: 8px 15px; font-size: 0.9em; }
             #history-panel { width: 90%; height: 75%; }
             #config-panel { width: 90%; max-width: 350px; right: 50%; transform: translateX(50%); top: 5%; }
             #toggle-config-btn { top: 10px; right: 10px; width: 35px; height: 35px; font-size: 18px;}
         }
         @media (max-width: 480px) {
             .character-area { height: 50%; max-width: 55%; } /* Further adjust width */
             #ai-character-area { right: 2%; }
             #player-character-area { left: 2%; }
             #dialogue-box { max-height: 50%; padding: 10px 15px; }
             #speaker-name { font-size: 1em; } #dialogue-text { font-size: 0.9em; }
             .control-button { padding: 6px 12px; font-size: 0.85em; }
             #history-panel { width: 95%; height: 80%; padding: 15px; }
             #config-panel { padding: 15px; width: 95%; }
         }
    </style>
</head>
<body>
    <!-- Background, Sidebar, Toggle Button (Keep as before) -->
    <div class="background"></div>
    <div id="sidebar">
        <nav id="sidebar-nav">
            <a href="index.html">üè† ‰∏ªÈ°µ</a>
            <a href="about.html">‚ú® ÂÖ≥‰∫éÊàë</a>
            <a href="blog_page1.html">üìù ÂçöÂÆ¢</a>
            <a href="contact.html">üíå ËÅîÁ≥ªÊàë</a>
            <a href="download.html">üìÅ Êñá‰ª∂‰∏ãËΩΩ</a>
            <a href="ai_draw.html">üé® AI ‰ΩúÁîª</a>
            <a href="tno_generator.html">üìú TNO‰∫ã‰ª∂ÁîüÊàê</a>
            <a href="if_game.html">üåå AI ‰∫íÂä®Â∞èËØ¥</a>
            <a href="ai_rpg.html">üíñ AI Galgame</a> <!-- Link Added -->
        </nav>
        <div class="theme-switcher">
            <h4>ÂàáÊç¢‰∏ªÈ¢ò:</h4>
            <div class="theme-buttons-container">
                <button data-theme="pastel" class="theme-button">üå∏ Á≤âÂΩ©Ê¢¶Â¢É</button>
                <button data-theme="dark" class="theme-button">üåô ÂçàÂ§úÊ®±ËêΩ</button>
            </div>
        </div>
    </div>
    <button id="toggle-btn">‚ò∞</button>

    <!-- Main Content Area -->
    <div class="content scroll-container">
        <header>
            <h1>AI Galgame ‰∫íÂä®ÊïÖ‰∫ã</h1>
             <button id="toggle-config-btn" title="ËÆæÁΩÆ">‚öô</button> <!-- Config Toggle -->
        </header>

        <main>
            <!-- Configuration Panel (HTML unchanged from previous version) -->
            <div id="config-panel">
                <!-- Player Settings Section -->
                <div class="config-section">
                    <h4>Áé©ÂÆ∂ËÆæÂÆö</h4>
                    <div class="form-group">
                        <label for="player-name-input">‰Ω†ÁöÑÂêçÂ≠ó:</label>
                        <input type="text" id="player-name-input" placeholder="ËæìÂÖ•‰Ω†ÊÉ≥‰ΩøÁî®ÁöÑÂêçÂ≠ó">
                    </div>
                    <div class="form-group">
                        <label for="player-persona-input">‰Ω†ÁöÑËßíËâ≤ÁÆÄ‰ªã:</label>
                        <textarea id="player-persona-input" rows="3" placeholder="ÁÆÄÂçïÊèèËø∞‰Ω†ÁöÑËßíËâ≤ (‰æãÂ¶ÇÔºö‰∏Ä‰∏™ÊúâÁÇπÂÜÖÂêë‰ΩÜÂñÑËâØÁöÑÈ´ò‰∏≠ÁîüÔºåÂñúÊ¨¢ËØª‰π¶ÂíåÈü≥‰πê)"></textarea>
                        <small class="input-hint">AI‰ºöÂü∫‰∫éÊ≠§ËøõË°åÊâ©ÂÖÖÂπ∂ÁîüÊàêÁ´ãÁªòÊèêÁ§∫ËØç„ÄÇ</small>
                    </div>
                     <div class="form-group">
                        <label for="player-start-input">ÊúüÊúõÁöÑÂºÄÂ±Ä:</label>
                        <textarea id="player-start-input" rows="3" placeholder="ÊèèËø∞‰Ω†ÊÉ≥Ë¶ÅÁöÑÂºÄÂ±ÄÂú∫ÊôØÊàñÂâßÊÉÖÂºïÂÖ•ÁÇπ (‰æãÂ¶ÇÔºöÂú®Êñ∞Â≠¶Ê†°ÁöÑÁ¨¨‰∏ÄÂ§©Ëø∑Ë∑Ø‰∫ÜÔºõÂú®Âõæ‰π¶È¶ÜÂÅ∂ÁÑ∂ÂèëÁé∞‰∏ÄÊú¨Á•ûÁßòÁöÑ‰π¶ÔºõÊî∂Âà∞‰∏ÄÂ∞ÅÂ•áÊÄ™ÁöÑÂåøÂêç‰ø°)"></textarea>
                        <small class="input-hint">AI‰ºöÂü∫‰∫éÊ≠§ËÆæÂÆöÂ±ïÂºÄÊïÖ‰∫ãÔºå‰∏çÈôê‰∫éÊ†°Âõ≠ÊÅãÁà±„ÄÇ</small>
                    </div>
                </div>

                <!-- AI & API Settings Section -->
                <div class="config-section">
                     <h4>AI & API ËÆæÁΩÆ</h4>
                     <div class="form-grid">
                        <div class="form-group">
                            <label for="llm-api-key">API ÂØÜÈí•:</label>
                            <div class="api-key-wrapper">
                                <input type="password" id="llm-api-key" placeholder="ËæìÂÖ• API Key (‰æãÂ¶Ç Gemini)">
                                <button id="toggle-api-key-visibility" title="ÂàáÊç¢ÂèØËßÅÊÄß">üëÅÔ∏è</button>
                            </div>
                             <span id="key-status"></span>
                             <button id="test-key-btn" class="control-button" style="padding: 6px 10px; font-size: 0.8em; margin-top: 5px;">ÊµãËØï Key</button>
                        </div>
                        <div class="form-group">
                            <label for="llm-api-url">API Âü∫Á°ÄÂú∞ÂùÄ:</label>
                            <div class="api-url-wrapper">
                                <input type="url" id="llm-api-url" placeholder="‰æãÂ¶Ç: https://generativelanguage.googleapis.com" value="https://generativelanguage.googleapis.com">
                                <button id="fetch-models-btn" title="Ëé∑ÂèñÂèØÁî®Ê®°ÂûãÂàóË°®">Ëé∑ÂèñÂàóË°®</button>
                            </div>
                             <small class="input-hint">(Google: ÁïôÁ©∫ÊàñÂ°´ ...googleapis.com; OpenAIÂÖºÂÆπ: Â°´Âà∞ /v1/ ÁªìÂ∞æ)</small>
                        </div>
                        <div class="form-group">
                            <label for="llm-model-select">ÈÄâÊã© LLM Ê®°Âûã:</label>
                             <div style="display: flex; align-items: center; gap: 10px;">
                                <div class="select-wrapper" style="flex-grow: 1;">
                                    <select id="llm-model-select" disabled>
                                        <option value="" disabled selected>-- ËØ∑ÂÖàËé∑ÂèñÊ®°ÂûãÂàóË°® --</option>
                                    </select>
                                </div>
                                <span id="model-loading-indicator" title="Ê≠£Âú®Âä†ËΩΩÊ®°Âûã...">üîÑ</span>
                             </div>
                        </div>
                        <div class="form-group">
                            <label for="galgame-persona">AI ÂØπÊâãËßíËâ≤ËÆæÂÆö (ÂèØÈÄâ):</label>
                            <textarea id="galgame-persona" rows="3" placeholder="‰Ω†Â∏åÊúõAIÊâÆÊºî‰ªÄ‰πàËßíËâ≤Ôºü(‰æãÂ¶ÇÔºö‰∏Ä‰∏™ÂÇ≤Â®áÁöÑÂêåÁè≠ÂêåÂ≠¶ÔºåÂêçÂè´[‰∫öÈáåÊ≤ô]...)"></textarea>
                             <small class="input-hint">Âú®[]‰∏≠ÂåÖÂê´ËßíËâ≤ÂêçÔºåÁî®‰∫éAIÁ´ãÁªòÂíåÂØπËØù„ÄÇ</small>
                        </div>
                     </div>
                 </div>

                <div class="config-buttons">
                    <button id="save-config-btn">‰øùÂ≠òËÆæÁΩÆ</button>
                    <button id="close-config-btn">ÂÖ≥Èó≠</button>
                </div>
            </div>

            <!-- Galgame UI Container (HTML unchanged) -->
            <div id="galgame-container">
                <div id="game-background"></div>
                <div id="player-character-area" class="character-area">
                    <img id="player-character-sprite" src="#" alt="Áé©ÂÆ∂ËßíËâ≤" class="character-sprite hidden">
                </div>
                <div id="ai-character-area" class="character-area">
                    <img id="ai-character-sprite" src="#" alt="AIËßíËâ≤" class="character-sprite hidden">
                </div>
                <div id="dialogue-box">
                    <div id="speaker-name">ÊóÅÁôΩ</div>
                    <div id="dialogue-text">Âú®ËøôÈáåËÆæÁΩÆÁé©ÂÆ∂ÂêçÁß∞„ÄÅËÆæÂÆöÂíåÊúüÊúõÂºÄÂ±ÄÂêéÔºåÁÇπÂáª‚ÄúÂºÄÂßã‚Äù„ÄÇ</div>
                     <div id="choices-container"></div>
                </div>
                <div id="game-controls">
                    <button id="toggle-history-btn" class="control-button" title="Êü•ÁúãÂØπËØùÂéÜÂè≤" disabled>ÂéÜÂè≤</button>
                    <button id="next-button" class="control-button" disabled>ÂºÄÂßã (ËØ∑ÂÖàËÆæÁΩÆAPI)</button>
                </div>
                 <div id="game-loading-overlay"><span>Â∞ëÂ•≥Á•àÁ•∑‰∏≠...</span></div>
                 <div id="game-error-message"></div>
            </div>

             <!-- History Panel (HTML unchanged) -->
             <div id="history-panel">
                 <h3>ÂØπËØùÂéÜÂè≤ËÆ∞ÂΩï</h3>
                 <div id="history-content"></div>
                 <button id="close-history-btn">ÂÖ≥Èó≠</button>
             </div>
        </main>

        <footer>
            <p>¬© 2024 MOLIFULAN's Blog | Galgame powered by AI</p>
        </footer>
    </div>

    <!-- JS Files -->
    <script src="js/script.js"></script> <!-- Main site script -->
    <script>
        // --- Galgame Specific JS (v3 - Style/Consistency Focus) ---

        // --- DOM Element References (Unchanged) ---
        const configPanel = document.getElementById('config-panel');
        const toggleConfigBtn = document.getElementById('toggle-config-btn');
        const saveConfigBtn = document.getElementById('save-config-btn');
        const closeConfigBtn = document.getElementById('close-config-btn');
        const apiKeyInput = document.getElementById('llm-api-key');
        const apiUrlInput = document.getElementById('llm-api-url');
        const fetchModelsBtn = document.getElementById('fetch-models-btn');
        const modelSelect = document.getElementById('llm-model-select');
        const modelLoadingIndicator = document.getElementById('model-loading-indicator');
        const toggleApiKeyVisibilityBtn = document.getElementById('toggle-api-key-visibility');
        const keyStatusSpan = document.getElementById('key-status');
        const aiPersonaInput = document.getElementById('galgame-persona');
        const playerNameInput = document.getElementById('player-name-input');
        const playerPersonaInput = document.getElementById('player-persona-input');
        const playerStartInput = document.getElementById('player-start-input');
        const dialogueBox = document.getElementById('dialogue-box');
        const speakerName = document.getElementById('speaker-name');
        const dialogueText = document.getElementById('dialogue-text');
        const choicesContainer = document.getElementById('choices-container');
        const nextButton = document.getElementById('next-button');
        const loadingOverlay = document.getElementById('game-loading-overlay');
        const gameErrorMessage = document.getElementById('game-error-message');
        const historyPanel = document.getElementById('history-panel');
        const historyContent = document.getElementById('history-content');
        const toggleHistoryBtn = document.getElementById('toggle-history-btn');
        const closeHistoryBtn = document.getElementById('close-history-btn');
        const gameBackground = document.getElementById('game-background');
        const aiCharacterSprite = document.getElementById('ai-character-sprite');
        const playerCharacterSprite = document.getElementById('player-character-sprite');

        // --- Constants ---
        // Style prompt placed first, more specific, no "same character", added anti-chibi hints
        const FIXED_STYLE_PROMPT = "masterpiece, best quality, highres, japanese anime art style, visual novel character sprite, full body sprite, detailed face, proportional body, clean lines, vibrant colors, flat colors, (not chibi), (not Q version)";
        // Stronger keywords for guaranteed white background
        const SPRITE_BACKGROUND_KEYWORDS = "plain white background, solid white background, simple white, isolated on white, no background elements, no shadows on background, pure white background";

        // --- State Variables ---
        // API & AI
        let currentApiKey = '';
        let currentApiUrl = '';
        let currentModel = '';
        let currentAiPersona = '';
        // Player
        let playerName = '';
        let playerPersona = '';
        let playerStart = '';
        // Character Appearance
        let playerBaseAppearancePrompt = ''; // Â≠òÂÇ®Áé©ÂÆ∂Âü∫Á°ÄÂ§ñËßÇ
        let aiBaseAppearancePrompt = '';     // Â≠òÂÇ®AIÂü∫Á°ÄÂ§ñËßÇ
        let spriteCache = {}; // Add cache object
        // Game State
        let conversationHistory = [];
        let isGameStarted = false;
        let isLoading = false;
        const GALGAME_STORAGE_PREFIX = 'galGame_';
        const DEFAULT_API_URL_GALGAME = 'https://generativelanguage.googleapis.com';
        let currentDialogueSegments = []; // ÂΩìÂâçÂõûÂêàÁöÑÂØπËØùÁâáÊÆµÊï∞ÁªÑ
        let currentSegmentIndex = 0;
        let currentTurnChoices = [];
        let currentTurnParsedData = null; // ÂΩìÂâçÂõûÂêàËß£ÊûêÂêéÁöÑÂÆåÊï¥JSON

        // --- Error & Loading UI (Unchanged) ---
        function showGameError(message) { console.error("Game Error:", message); gameErrorMessage.textContent = message; gameErrorMessage.style.display = 'block'; setTimeout(() => { clearGameError(); }, 7000); setLoading(false); }
        function clearGameError() { gameErrorMessage.style.display = 'none'; gameErrorMessage.textContent = ''; }
        function setLoading(loading) {
             console.log("Setting loading state to:", loading);
             isLoading = loading;
             loadingOverlay.classList.toggle('visible', loading);
             const canInteract = currentApiKey && currentModel;
             const choicesCurrentlyDisplayed = choicesContainer.querySelector('.choice-button') !== null;
             const moreSegmentsAvailable = currentDialogueSegments && currentSegmentIndex < currentDialogueSegments.length - 1;
             nextButton.disabled = loading || !canInteract || !isGameStarted || choicesCurrentlyDisplayed || !moreSegmentsAvailable;
             toggleHistoryBtn.disabled = loading || !canInteract || !isGameStarted;
             toggleConfigBtn.disabled = loading;
             document.querySelectorAll('.choice-button').forEach(btn => btn.disabled = loading);
         }

        // --- Configuration Logic (Unchanged) ---
        function saveConfig() {
            const apiKey = apiKeyInput.value.trim(); const apiUrl = apiUrlInput.value.trim() || DEFAULT_API_URL_GALGAME; const model = modelSelect.value; const aiPersona = aiPersonaInput.value.trim(); const pName = playerNameInput.value.trim(); const pPersona = playerPersonaInput.value.trim(); const pStart = playerStartInput.value.trim(); localStorage.setItem(GALGAME_STORAGE_PREFIX + 'apiKey', apiKey); localStorage.setItem(GALGAME_STORAGE_PREFIX + 'apiUrl', apiUrl); localStorage.setItem(GALGAME_STORAGE_PREFIX + 'model', model); localStorage.setItem(GALGAME_STORAGE_PREFIX + 'aiPersona', aiPersona); localStorage.setItem(GALGAME_STORAGE_PREFIX + 'playerName', pName); localStorage.setItem(GALGAME_STORAGE_PREFIX + 'playerPersona', pPersona); localStorage.setItem(GALGAME_STORAGE_PREFIX + 'playerStart', pStart); currentApiKey = apiKey; currentApiUrl = apiUrl; currentModel = model; currentAiPersona = aiPersona; playerName = pName; playerPersona = pPersona; playerStart = pStart; console.log("Galgame Config saved (state updated):", { currentApiKey, currentApiUrl, currentModel, currentAiPersona, playerName, playerPersona, playerStart }); const canStart = currentApiKey && currentModel; nextButton.textContent = isGameStarted ? 'ÁªßÁª≠' : (canStart ? 'ÂºÄÂßã' : 'ÂºÄÂßã (ËØ∑ÂÖàËÆæÁΩÆAPI)'); nextButton.disabled = isLoading || !canStart; toggleHistoryBtn.disabled = isLoading || !canStart || !isGameStarted; if (!isGameStarted) { if (canStart) { let info = "API ËÆæÁΩÆÂ∑≤Âä†ËΩΩ„ÄÇ\n"; if (playerName) info += `Áé©ÂÆ∂ÂêçÁß∞: ${playerName}\n`; if (playerPersona) info += `Áé©ÂÆ∂ËÆæÂÆö: ${playerPersona.substring(0, 50)}...\n`; if (playerStart) info += `ÂºÄÂ±ÄÊèêÁ§∫: ${playerStart.substring(0, 50)}...\n`; if (currentAiPersona) info += `AI ËßíËâ≤: ${currentAiPersona.substring(0, 50)}...\n`; info += "ÁÇπÂáª‚ÄúÂºÄÂßã‚ÄùËøõÂÖ•ÊïÖ‰∫ã„ÄÇ"; dialogueText.innerHTML = marked.parse(info); } else { dialogueText.innerHTML = marked.parse("Ê¨¢ËøéÊù•Âà∞ AI Galgame ‰∫íÂä®ÊïÖ‰∫ãÔºÅ\nËØ∑ÁÇπÂáªÂè≥‰∏äËßíÁöÑ **‚öô** ËÆæÁΩÆ‰Ω†ÁöÑ API KeyÔºåÂπ∂ÈÄâÊã©‰∏Ä‰∏™Ê®°Âûã„ÄÇ\nÔºàÂèØÈÄâÔºâËÆæÁΩÆÁé©ÂÆ∂ÂêçÁß∞„ÄÅËÆæÂÆöÂíåÊúüÊúõÂºÄÂ±Ä„ÄÇ\nÂáÜÂ§áÂ•ΩÂêéÔºåÁÇπÂáª‚ÄúÂºÄÂßã‚ÄùÊåâÈíÆ„ÄÇ"); } }
        }
        function loadConfig() { currentApiKey = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'apiKey') || ''; currentApiUrl = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'apiUrl') || DEFAULT_API_URL_GALGAME; currentModel = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'model') || ''; currentAiPersona = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'aiPersona') || ''; playerName = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'playerName') || ''; playerPersona = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'playerPersona') || ''; playerStart = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'playerStart') || ''; apiKeyInput.value = currentApiKey; apiUrlInput.value = currentApiUrl === DEFAULT_API_URL_GALGAME ? '' : currentApiUrl; aiPersonaInput.value = currentAiPersona; playerNameInput.value = playerName; playerPersonaInput.value = playerPersona; playerStartInput.value = playerStart; modelSelect.innerHTML = '<option value="" disabled selected>-- Ëé∑ÂèñÊàñÈÄâÊã©Ê®°Âûã --</option>'; if (currentModel) { const o = document.createElement('option'); o.value = currentModel; o.textContent = currentModel + " (Â∑≤‰øùÂ≠ò)"; o.selected = true; modelSelect.appendChild(o); modelSelect.disabled = false; } else { modelSelect.disabled = true; } keyStatusSpan.textContent = ''; keyStatusSpan.className = ''; console.log("Galgame Config loaded:", { currentApiKey, currentApiUrl, currentModel, currentAiPersona, playerName, playerPersona, playerStart }); const canConfigure = currentApiKey && currentModel; isGameStarted = false; if (!canConfigure) { dialogueText.innerHTML = marked.parse("Ê¨¢ËøéÊù•Âà∞ AI Galgame ‰∫íÂä®ÊïÖ‰∫ãÔºÅ\nËØ∑ÁÇπÂáªÂè≥‰∏äËßíÁöÑ **‚öô** ËÆæÁΩÆ‰Ω†ÁöÑ API KeyÔºåÂπ∂ÈÄâÊã©‰∏Ä‰∏™Ê®°Âûã„ÄÇ\nÔºàÂèØÈÄâÔºâËÆæÁΩÆÁé©ÂÆ∂ÂêçÁß∞„ÄÅËÆæÂÆöÂíåÊúüÊúõÂºÄÂ±Ä„ÄÇ\nÂáÜÂ§áÂ•ΩÂêéÔºåÁÇπÂáª‚ÄúÂºÄÂßã‚ÄùÊåâÈíÆ„ÄÇ"); nextButton.textContent = "ÂºÄÂßã (ËØ∑ÂÖàËÆæÁΩÆAPI)"; nextButton.disabled = true; toggleHistoryBtn.disabled = true; } else { let info = "API ËÆæÁΩÆÂ∑≤Âä†ËΩΩ„ÄÇ\n"; if (playerName) info += `Áé©ÂÆ∂ÂêçÁß∞: ${playerName}\n`; if (playerPersona) info += `Áé©ÂÆ∂ËÆæÂÆö: ${playerPersona.substring(0, 50)}...\n`; if (playerStart) info += `ÂºÄÂ±ÄÊèêÁ§∫: ${playerStart.substring(0, 50)}...\n`; if (currentAiPersona) info += `AI ËßíËâ≤: ${currentAiPersona.substring(0, 50)}...\n`; info += "ÁÇπÂáª‚ÄúÂºÄÂßã‚ÄùËøõÂÖ•ÊïÖ‰∫ã„ÄÇ"; dialogueText.innerHTML = marked.parse(info); nextButton.textContent = "ÂºÄÂßã"; nextButton.disabled = isLoading || !canConfigure; toggleHistoryBtn.disabled = true; } aiCharacterSprite.classList.add('hidden'); playerCharacterSprite.classList.add('hidden'); }
        function toggleConfigPanel() { configPanel.classList.toggle('visible'); }
        async function fetchLLMModels() { const apiKey = apiKeyInput.value.trim(); const baseApiUrl = apiUrlInput.value.trim() || DEFAULT_API_URL_GALGAME; if (!apiKey) { showGameError('ËØ∑ÂÖàÂ°´ÂÜô API ÂØÜÈí•„ÄÇ'); return; } keyStatusSpan.textContent = ''; keyStatusSpan.className = ''; modelLoadingIndicator.style.display = 'inline-block'; fetchModelsBtn.disabled = true; modelSelect.disabled = true; modelSelect.innerHTML = '<option value="" disabled selected>-- Ê≠£Âú®Ëé∑Âèñ... --</option>'; let modelListUrl = ''; let headers = { 'Content-Type': 'application/json' }; let method = 'GET'; try { if (baseApiUrl.includes('generativelanguage.googleapis.com')) { modelListUrl = baseApiUrl.replace(/\/$/, '') + `/v1beta/models?key=${apiKey}&pageSize=1000`; } else if (baseApiUrl.includes('/v1')) { headers['Authorization'] = `Bearer ${apiKey}`; modelListUrl = baseApiUrl.replace(/\/v1\/?$/, '') + '/v1/models'; } else { console.warn("Êú™Áü•Âú∞ÂùÄÊ†ºÂºèÔºåÂ∞ùËØï /v1/models"); headers['Authorization'] = `Bearer ${apiKey}`; modelListUrl = baseApiUrl.replace(/\/$/, '') + '/v1/models'; } console.log("Fetching models from:", modelListUrl); const response = await fetch(modelListUrl, { method, headers }); if (!response.ok) { const e = await response.text(); throw new Error(`Ëé∑ÂèñÂ§±Ë¥•: ${response.status} ${response.statusText}. ${e.substring(0,100)}`); } const data = await response.json(); console.log("Model List Raw:", data); let modelNames = []; if (data.models?.length) { modelNames = data.models.map(m => m.name?.replace(/^models\//, '')).filter(Boolean).filter(name => !/embed|vision|instruct|text-|aqa|diffusion|image/i.test(name)).sort(); } else if (data.data?.length) { modelNames = data.data.map(m => m.id).filter(Boolean).filter(id => !/embed|vision|instruct|text-|whisper|tts|davinci|babbage|curie|ada|image|diffusion/i.test(id)).sort(); } else { throw new Error("Êó†Ê≥ïËØÜÂà´ÁöÑÊ®°ÂûãÂàóË°®Ê†ºÂºè„ÄÇ"); } if (modelNames.length === 0) { throw new Error("Âú®Ê≠§ API Âú∞ÂùÄÊú™ÊâæÂà∞ÂèØÁî®ÁöÑËÅäÂ§©Ê®°Âûã„ÄÇ"); } const previouslySelected = currentModel || modelSelect.value; modelSelect.innerHTML = '<option value="" disabled>-- ËØ∑ÈÄâÊã©‰∏Ä‰∏™Ê®°Âûã --</option>'; let foundPrevious = false; modelNames.forEach(name => { const o=document.createElement('option'); o.value=name; o.textContent=name; if(name === previouslySelected) { o.selected = true; foundPrevious = true; } modelSelect.appendChild(o); }); if (!foundPrevious && modelSelect.options.length > 1) { modelSelect.selectedIndex = 1; } else if (!foundPrevious && modelSelect.options.length <= 1) { modelSelect.selectedIndex = 0; } currentModel = modelSelect.value; modelSelect.disabled = !currentModel; clearGameError(); } catch (error) { console.error("Ëé∑ÂèñÊ®°ÂûãÂá∫Èîô:", error); showGameError(error.message || "Ëé∑ÂèñÊ®°ÂûãÂàóË°®Êó∂Âá∫Èîô„ÄÇ"); modelSelect.innerHTML = '<option value="" disabled selected>-- Ëé∑ÂèñÂ§±Ë¥• --</option>'; modelSelect.disabled = true; } finally { modelLoadingIndicator.style.display = 'none'; fetchModelsBtn.disabled = false; modelSelect.disabled = modelSelect.options.length <= 1 || !modelSelect.value; saveConfig(); } }
        async function testApiKey() { const testKeyButtonElement = document.getElementById('test-key-btn'); const apiKey = apiKeyInput.value.trim(); const baseApiUrl = apiUrlInput.value.trim() || DEFAULT_API_URL_GALGAME; if (!apiKey) { keyStatusSpan.textContent = 'ËØ∑ËæìÂÖ• API Key'; keyStatusSpan.className = 'invalid'; return; } if (!testKeyButtonElement) { console.error("Êó†Ê≥ïÊâæÂà∞ÊµãËØïÊåâÈíÆÂÖÉÁ¥†!"); keyStatusSpan.textContent = 'È°µÈù¢ÈîôËØØ'; keyStatusSpan.className = 'error'; return; } keyStatusSpan.textContent = 'Ê≠£Âú®ÊµãËØï...'; keyStatusSpan.className = 'testing'; testKeyButtonElement.disabled = true; let testUrl = ''; let headers = {}; let method = 'GET'; try { if (baseApiUrl.includes('generativelanguage.googleapis.com')) { testUrl = baseApiUrl.replace(/\/$/, '') + `/v1beta/models?key=${apiKey}`; } else if (baseApiUrl.includes('/v1')) { headers['Authorization'] = `Bearer ${apiKey}`; testUrl = baseApiUrl.replace(/\/v1\/?$/, '') + '/v1/models'; } else { throw new Error("Êó†Ê≥ïÁ°ÆÂÆöÊµãËØï URL Ê†ºÂºè"); } console.log("Testing API Key with URL:", testUrl); const response = await fetch(testUrl, { method, headers }); if (response.ok) { keyStatusSpan.textContent = '‚úÖ Key ÊúâÊïà'; keyStatusSpan.className = 'valid'; } else { let errorMsg = `‚ùå Key Êó†ÊïàÊàñURLÈîôËØØ (${response.status})`; try{ const errData = await response.json(); if(errData?.error?.message) errorMsg += `: ${errData.error.message}`; } catch(e){} keyStatusSpan.textContent = errorMsg; keyStatusSpan.className = 'invalid'; } } catch (error) { keyStatusSpan.textContent = '‚ö†Ô∏è ÊµãËØïÂá∫Èîô (ÁΩëÁªú/URL?)'; keyStatusSpan.className = 'error'; console.error("Key test error:", error); } finally { testKeyButtonElement.disabled = false; } }

        // --- History Panel Logic (Unchanged) ---
        function toggleHistoryPanel() { console.log("toggleHistoryPanel called. isLoading:", isLoading, "isGameStarted:", isGameStarted); if (isLoading) return; if (!isGameStarted || !currentApiKey || !currentModel) { showGameError("ËØ∑ÂÖàÂºÄÂßãÊ∏∏Êàè‰ª•Êü•ÁúãÂéÜÂè≤ËÆ∞ÂΩï„ÄÇ"); return; } if (historyPanel.classList.contains('visible')) { historyPanel.classList.remove('visible'); } else { displayHistory(); historyPanel.classList.add('visible'); } }
        function displayHistory() { console.log("Displaying history. Count:", conversationHistory.length); historyContent.innerHTML = ''; if (conversationHistory.length === 0) { historyContent.innerHTML = '<p><i>ËøòÊ≤°ÊúâÂØπËØùËÆ∞ÂΩïÂë¢...</i></p>'; return; } conversationHistory.forEach(entry => { if (entry.role === 'user' && entry.isSetup) { return; } const entryDiv = document.createElement('div'); entryDiv.classList.add('history-entry'); if (entry.role === 'user') { const roleSpan = document.createElement('div'); roleSpan.classList.add('history-role-user'); roleSpan.textContent = `${playerName || '‰Ω†'}:`; const textDiv = document.createElement('div'); textDiv.classList.add('history-text'); textDiv.textContent = entry.parts[0]?.text || '(Á©∫Ê∂àÊÅØ)'; entryDiv.appendChild(roleSpan); entryDiv.appendChild(textDiv); } else if (entry.role === 'model') { try { const parsedData = JSON.parse(entry.parts[0]?.text || '{}'); const segments = parsedData.dialogue_segments || []; const choices = parsedData.choices || []; if (segments.length > 0) { segments.forEach(segment => { const segmentDiv = document.createElement('div'); segmentDiv.classList.add('history-dialogue-segment'); const speakerSpan = document.createElement('span'); speakerSpan.classList.add('segment-speaker'); speakerSpan.textContent = `${segment.speaker || '???'}:`; const textSpan = document.createElement('span'); textSpan.classList.add('segment-text'); try { textSpan.innerHTML = typeof DOMPurify !== 'undefined' ? DOMPurify.sanitize(marked.parse(segment.text || '(Á©∫ÁâáÊÆµ)')) : marked.parse(segment.text || '(Á©∫ÁâáÊÆµ)'); } catch(e){ textSpan.textContent = segment.text || '(Á©∫ÁâáÊÆµ)'; } segmentDiv.appendChild(speakerSpan); segmentDiv.appendChild(textSpan); entryDiv.appendChild(segmentDiv); }); } else { const roleSpan = document.createElement('div'); roleSpan.classList.add('history-role-model'); roleSpan.textContent = `AI (Ëß£ÊûêÈîôËØØ):`; const textDiv = document.createElement('div'); textDiv.classList.add('history-text'); textDiv.textContent = '(Êó†Ê≥ïËß£ÊûêÂØπËØùÁâáÊÆµ)'; entryDiv.appendChild(roleSpan); entryDiv.appendChild(textDiv); } if (choices.length > 0) { const choiceList = document.createElement('ul'); choiceList.style.fontSize = '0.9em'; choiceList.style.opacity = '0.7'; choiceList.style.marginTop = '8px'; choiceList.style.paddingLeft = '25px'; choices.forEach(c => { const li = document.createElement('li'); li.textContent = c.replace(/^\[|\]$/g, ''); choiceList.appendChild(li); }); entryDiv.appendChild(choiceList); } } catch (e) { console.error("Failed to parse model entry in history:", e, entry.parts[0]?.text); const roleSpan = document.createElement('div'); roleSpan.classList.add('history-role-model'); roleSpan.textContent = `AI (ÂéüÂßã):`; const textDiv = document.createElement('div'); textDiv.classList.add('history-text'); textDiv.textContent = entry.parts[0]?.text || '(Êó†Ê≥ïËß£Êûê)'; entryDiv.appendChild(roleSpan); entryDiv.appendChild(textDiv); } } historyContent.appendChild(entryDiv); }); historyContent.scrollTop = historyContent.scrollHeight; }

        // --- Character Sprite Background Removal (Unchanged) ---
        async function removeEdgeWhiteBackground(img) {
             return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                const width = img.naturalWidth;
                const height = img.naturalHeight;
                 if (width === 0 || height === 0) {
                     console.warn("Image has zero dimensions, cannot process.");
                     resolve(img.src); // Return original source if dimensions are invalid
                     return;
                 }
                canvas.width = width;
                canvas.height = height;

                try {
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, width, height);
                    const data = imageData.data;
                    const visited = new Uint8Array(width * height);
                    const whiteThreshold = 248;
                    const tolerance = 7;
                    const effectiveThreshold = whiteThreshold - tolerance;

                    function isNearWhite(index) {
                        if (index < 0 || index >= data.length || data[index+3] < 128) return false;
                        const r = data[index]; const g = data[index + 1]; const b = data[index + 2];
                        return r >= effectiveThreshold && g >= effectiveThreshold && b >= effectiveThreshold;
                    }

                    function getIndex(x, y) { return (y * width + x) * 4; }
                    function getVisitedIndex(x, y) { return y * width + x; }
                    const queue = [];

                    for (let y = 0; y < height; y++) { for (let x = 0; x < width; x++) { if (y === 0 || y === height - 1 || x === 0 || x === width - 1) { const index = getIndex(x, y); const visitedIndex = getVisitedIndex(x,y); if (isNearWhite(index) && !visited[visitedIndex]) { queue.push({ x, y }); visited[visitedIndex] = 1; } } } }
                    console.log("Starting flood fill. Queue:", queue.length, "Threshold:", whiteThreshold, "Tolerance:", tolerance);

                    let processedPixelCount = 0;
                    while (queue.length > 0) {
                        const { x, y } = queue.shift(); const index = getIndex(x, y); if (data[index + 3] > 0) { data[index + 3] = 0; processedPixelCount++; }
                        const neighbors = [ { nx: x + 1, ny: y }, { nx: x - 1, ny: y }, { nx: x, ny: y + 1 }, { nx: x, ny: y - 1 } ];
                        for (const {nx, ny} of neighbors) { if (nx >= 0 && nx < width && ny >= 0 && ny < height) { const neighborIndex = getIndex(nx, ny); const visitedIndex = getVisitedIndex(nx, ny); if (isNearWhite(neighborIndex) && !visited[visitedIndex]) { visited[visitedIndex] = 1; queue.push({ x: nx, y: ny }); } } }
                    }
                    console.log(`Flood fill finished. ${processedPixelCount} pixels made transparent.`);
                    ctx.putImageData(imageData, 0, 0); resolve(canvas.toDataURL('image/png'));
                } catch (error) {
                    if (error.name === 'SecurityError') { console.error("Canvas processing error (likely CORS): Cannot process image from different origin without CORS headers.", error); resolve(img.src); } else { console.error("Canvas processing error in removeEdgeWhiteBackground:", error); resolve(img.src); }
                }
            });
        }

        // --- Image Loading (Prompt Order Adjusted) ---
        async function loadDynamicImage(element, prompt, imageType = "background", nologo = true, seed = null) { // Seed param kept but unused now
             if (!prompt || !element) {
                 console.warn(`Skipping ${imageType} image: No prompt or element.`);
                 if (imageType === 'character') { element.classList.add('hidden'); }
                 return Promise.resolve();
             }
             const baseCharacterPrompt = prompt; // Rename for clarity
             console.log(`Attempting to load ${imageType} image with base prompt: ${baseCharacterPrompt}`);
             let width = 1024, height = 576, extraParams = "", finalPromptString = '';

             if (imageType === 'character') {
                 width = 512; height = 768; extraParams = "&nofeed=true";
                 // Assemble the final prompt: Style -> Character Details -> Background
                 finalPromptString = `${FIXED_STYLE_PROMPT}, ${baseCharacterPrompt}, ${SPRITE_BACKGROUND_KEYWORDS}`;

                 console.log("Final Character Prompt:", finalPromptString);

                 // --- Caching Logic Start (Unchanged) ---
                 if (spriteCache[finalPromptString]) {
                     console.log(`Cache hit for character prompt: ${finalPromptString.substring(0, 100)}...`);
                     element.src = spriteCache[finalPromptString];
                     element.classList.remove('hidden');
                     element.style.opacity = 1;
                     return Promise.resolve();
                 }
                 element.classList.add('hidden');
                 // --- Caching Logic End ---

             } else if (imageType === 'background') {
                 // Keep background prompt separate
                 finalPromptString = `${baseCharacterPrompt}, anime style, visual novel background, detailed illustration, high quality`;
                 width = 1024; height = 576;
             }

             const nologoValue = nologo ? 'true' : 'false';
             let finalUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPromptString)}?width=${width}&height=${height}&model=flux&nologo=${nologoValue}${extraParams}`;
             finalUrl += `&seed=${Math.floor(Math.random()*1e7)}`; // Use random seed
             const url = finalUrl;
             console.log(`Loading ${imageType} image URL:`, url);

             return new Promise((resolve) => { // Rest of the promise logic unchanged
                 const img = new Image();
                 img.crossOrigin = "Anonymous";

                 img.onload = async () => {
                     console.log(`${imageType} image preloaded/loaded successfully.`);
                     if (imageType === 'background') {
                         element.style.backgroundImage = `url('${url}')`;
                         console.log(`Background image set for element:`, element);
                         resolve();
                     } else { // Character sprite processing
                         try {
                             console.log(`Attempting white background removal for ${element.id}...`);
                             const processedUrl = await removeEdgeWhiteBackground(img);
                             element.src = processedUrl;
                             spriteCache[finalPromptString] = processedUrl; // Cache processed URL
                             element.classList.remove('hidden');
                             element.style.opacity = 1; console.log(`White background removal finished for ${element.id}.`);
                         } catch (error) {
                             console.error(`Using original URL due to background removal error for ${element.id}:`, error);
                             element.src = url; // Fallback
                             spriteCache[finalPromptString] = url; // Cache original URL on error
                             element.classList.remove('hidden');
                             element.style.opacity = 1; showGameError(`Â§ÑÁêÜ ${element.alt} ËÉåÊôØÊó∂Âá∫Èîô„ÄÇ`);
                         } finally { resolve(); }
                     }
                 };

                 img.onerror = (e) => {
                    console.error(`Error loading ${imageType} image:`, e, url);
                    showGameError(`${imageType === 'character' ? element.alt : 'ËÉåÊôØ'} Âä†ËΩΩÂ§±Ë¥•„ÄÇ`);
                    if (imageType === 'character') {
                        element.classList.add('hidden');
                    }
                    resolve();
                 };

                 img.src = url;
             });
         }


        // --- LLM API Call (Instructions against "same") ---
        async function callLLMApi_Galgame(promptHistory) {
            console.log("callLLMApi_Galgame initiated."); if (!currentApiKey || !currentModel || !currentApiUrl) { showGameError("API ÈÖçÁΩÆ‰∏çÂÆåÊï¥ÔºÅËØ∑Ê£ÄÊü•ËÆæÁΩÆ„ÄÇ"); return null; } clearGameError(); let finalApiUrl = currentApiUrl.trim(); let requestBody; let headers = { 'Content-Type': 'application/json' };

            // Updated System Instruction with stricter rules against "same..." and for concise emotion
            const systemInstruction = `‰Ω†Áé∞Âú®ÊòØ‰∏Ä‰∏™ Galgame (ËßÜËßâÂ∞èËØ¥) ÂºïÊìé„ÄÇ‰Ω†ÁöÑ‰ªªÂä°ÊòØ‰∏éÁé©ÂÆ∂ (${playerName || 'Áé©ÂÆ∂'}) ‰∫íÂä®ÔºåÂπ∂ÁîüÊàêÊ∏∏ÊàèÂÜÖÂÆπ„ÄÇ\nÁé©ÂÆ∂Âü∫Á°ÄÂ§ñË≤åÊèêÁ§∫ËØç(Áî±‰Ω†ÁîüÊàêÊàñÂÆåÂñÑ): ${playerBaseAppearancePrompt || '(Â∞öÊú™ÁîüÊàê)'}\nAIËßíËâ≤Âü∫Á°ÄÂ§ñË≤åÊèêÁ§∫ËØç(Áî±‰Ω†ÁîüÊàêÊàñÂÆåÂñÑ): ${aiBaseAppearancePrompt || '(Â∞öÊú™ÁîüÊàê)'}\n${currentAiPersona ? `AI ËßíËâ≤ËÆæÂÆö: ${currentAiPersona}\n` : ''}ËØ∑**‰∏•Ê†º**ÊåâÁÖß‰ª•‰∏ã JSON Ê†ºÂºèÁîüÊàêÂìçÂ∫îÔºå‰∏çË¶ÅÂåÖÂê´‰ªª‰ΩïÈ¢ùÂ§ñÁöÑËß£ÈáäÊàñ Markdown Ê†áËÆ∞ÂåÖË£π JSON Êú¨Ë∫´Ôºö\n\`\`\`json\n{\n  "scene_state": {\n    "background_prompt": "String (Âú∫ÊôØÁöÑËã±ÊñáÊèèËø∞, ËøôÊòØÊ∏∏ÊàèËÉåÊôØÂõæ, ‰∏çÊòØËßíËâ≤Á´ãÁªòËÉåÊôØ!)",\n    "visible_characters": [\n      {\n        "character_id": "'player' or 'ai'",\n        "emotion": "String or Null (ËßíËâ≤„ÄêÂΩìÂâç„ÄëÁöÑË°®ÊÉÖ/Âä®‰Ωú/ÁªÜÂæÆÂèòÂåñ, e.g., 'smiling slightly', 'surprised face', 'holding a pen', 'adjusting glasses')"\n      }\n      // ... ÂèØËÉΩÂåÖÂê´ 'player' Âíå/Êàñ 'ai'\n    ]\n  },\n  "dialogue_segments": [\n    {\n      "speaker": "String (AIËßíËâ≤Âêç, ${playerName ? "'" + playerName + "'" : "'Áé©ÂÆ∂'"}, 'ÊóÅÁôΩ', 'ÂÜÖÂøÉÊÉ≥Ê≥ï')",\n      "emotion": "String or Null (ËØ¥ËØùËÄÖË°®ÊÉÖ/Âä®‰Ωú, ÂØπÂ∫îÊ≠§„ÄêÂØπËØù„ÄëÂÜÖÂÆπ)",\n      "text": "String (ËØ•ÁâáÊÆµÁöÑÂØπËØù/ÊóÅÁôΩÊñáÊú¨, ÊîØÊåÅMarkdown)"\n    }\n    // ... more segments\n  ],\n  "choices": [\n    "String (ÈÄâÈ°π1)", \n    "String (ÈÄâÈ°π2)"\n  ],\n  "initial_setup_details": { \n     // !!! Ëøô‰∏™Â≠óÊÆµ„ÄêÂè™Âú®„ÄëÂìçÂ∫îÁ¨¨‰∏Ä‰∏™ËÆæÁΩÆËØ∑Ê±ÇÊó∂Âá∫Áé∞ !!!\n     // **Ë¶ÅÊ±ÇÔºöÁîüÊàê„ÄêÊûÅÂÖ∂ËØ¶ÁªÜ‰∏îËøûË¥Ø„Äë„ÄÅÂåÖÂê´ÂÖ∑‰ΩìÁâπÂæÅ(ÂèëÂûã/ÂèëËâ≤/Áû≥Ëâ≤/Ë∫´Êùê/ËÑ∏Âûã)Âíå„ÄêÂÖ∑‰ΩìÊúçË£Ö„ÄëÊèèËø∞ÁöÑÂü∫Á°ÄÊèêÁ§∫ËØç„ÄÇ**„ÄêÁ¶ÅÊ≠¢„Äë**ÂåÖÂê´ 'same character', 'same face', 'same style' Á≠âÊó†ÊïàËØçËØ≠„ÄÇ**\n     "player_base_appearance_prompt": "String (ÁîüÊàê„ÄêÊûÅÂÖ∂ËØ¶ÁªÜ„ÄÅËøûË¥Ø„ÄëÁöÑÁé©ÂÆ∂Âü∫Á°ÄÂ§ñË≤åËã±ÊñáÊèêÁ§∫ËØç, e.g., '1girl, teenage girl, medium height, slim build, long wavy bright pink hair tied in high twin tails with red ribbons, large sparkling emerald green eyes, fair skin, wearing a standard white short-sleeve sailor school uniform with navy blue collar and cuffs, red necktie, navy blue pleated skirt, white knee-high socks, brown loafers')",\n     "ai_base_appearance_prompt": "String (ÁîüÊàê„ÄêÊûÅÂÖ∂ËØ¶ÁªÜ„ÄÅËøûË¥Ø„ÄëÁöÑAIËßíËâ≤Âü∫Á°ÄÂ§ñË≤åËã±ÊñáÊèêÁ§∫ËØç, Âêå‰∏äË¶ÅÊ±Ç)"\n  }\n}\n\`\`\`\n*   **scene_state**: ÊèèËø∞ÂΩìÂâçÂú∫ÊôØËßÜËßâÁä∂ÊÄÅ„ÄÇ\n    *   **background_prompt**: ÂΩìÂâçÂú∫ÊôØÁöÑ„ÄêÊ∏∏ÊàèËÉåÊôØÂõæ„ÄëÊèêÁ§∫ËØç„ÄÇ\n    *   **visible_characters**: Êï∞ÁªÑÂåÖÂê´ÂΩìÂâçÂ±èÂπï‰∏äÂèØËßÅÁöÑËßíËâ≤„ÄÇÊØè‰∏™ÂØπË±°ÊåáÂÆö \`character_id\` ('player' Êàñ 'ai') Âíå \`emotion\`„ÄÇ \`emotion\` ÂøÖÈ°ªÊòØ„ÄêÊûÅÂÖ∂ÁÆÄÊ¥ÅÂú∞ÊèèËø∞ÂΩìÂâçË°®ÊÉÖ„ÄÅÂä®‰ΩúÊàñÈùûÂ∏∏Â∞èÁöÑ‰∏¥Êó∂Áâ©ÂìÅ„ÄëÔºå‰æãÂ¶Ç 'smiling', 'sad', 'surprised', 'holding a book', 'waving hand', 'blushing', 'looking down shyly'„ÄÇ**„ÄêÁªùÂØπÁ¶ÅÊ≠¢„Äë** Âú® \`emotion\` Â≠óÊÆµ‰∏≠ÈáçÊñ∞ÊèèËø∞ËßíËâ≤ÁöÑÊ†∏ÂøÉÁâπÂæÅÔºàÂ¶ÇÂèëÂûã„ÄÅÂèëËâ≤„ÄÅÁû≥Ëâ≤Ôºâ„ÄÅ‰∏ªË¶ÅÊúçË£ÖÊàñÊï¥‰ΩìËâ∫ÊúØÈ£éÊ†ºÔºå‰πü**„ÄêÁªùÂØπÁ¶ÅÊ≠¢„Äë**ÂåÖÂê´ 'same character/face/style/clothing' Á≠âËØçËØ≠„ÄÇÂÆ¢Êà∑Á´Ø‰ºöÂº∫Âà∂Â∫îÁî®‰∏ÄËá¥ÁöÑÊó•Âºè‰∫åÊ¨°ÂÖÉÁîªÈ£éÂíåÁ∫ØÁôΩËÉåÊôØ„ÄÇ\n*   **dialogue_segments**: ÂØπËØùÂÜÖÂÆπÊï∞ÁªÑ„ÄÇ\n*   **choices**: Áé©ÂÆ∂ÈÄâÈ°πÊï∞ÁªÑ„ÄÇ\n*   **initial_setup_details**: „ÄêÂè™Âú®È¶ñÊ¨°ÂìçÂ∫îÊó∂Êèê‰æõ„ÄëÔºåÂåÖÂê´‰Ω†ÁîüÊàêÁöÑ„ÄêÊûÅÂÖ∂ËØ¶ÁªÜ„ÄÅËøûË¥Ø‰∏î‰∏çÂê´Êó†ÊïàÈáçÂ§çËØç„ÄëÁöÑÂü∫Á°ÄÂ§ñË≤åÊèêÁ§∫ËØç„ÄÇ\n*   **È£éÊ†ºÂíåÁ´ãÁªòËÉåÊôØ**: ÂÆ¢Êà∑Á´Ø‰ºöÂº∫Âà∂‰ΩøÁî®Âõ∫ÂÆöÁöÑ„ÄêÊó•Âºè‰∫åÊ¨°ÂÖÉËßÜËßâÂ∞èËØ¥Á´ãÁªòÈ£éÊ†º„ÄëÂíå„ÄêÁ∫ØÁôΩËÉåÊôØ„ÄëÊù•ÁîüÊàêËßíËâ≤Á´ãÁªò„ÄÇ‰Ω†ÁöÑ‰ªªÂä°ÊòØÊèê‰æõËØ¶ÁªÜÁöÑÂü∫Á°ÄÊèèËø∞ÂíåÁÆÄÊ¥ÅÁöÑÁä∂ÊÄÅÂèòÂåñÔºåÂπ∂ÈÅøÂÖçÊó†ÊïàÂÖ≥ÈîÆËØç„ÄÇ

ËøôÊòØ‰πãÂâçÁöÑÂØπËØùÂéÜÂè≤ÔºàÊúÄËøëÂá†Êù°ÔºâÔºö\n${JSON.stringify(promptHistory.slice(-6, -1).map(h => `${h.role === 'user' ? (playerName || 'Áé©ÂÆ∂') : 'AI Response (Segments)'}: ${h.role === 'user' ? h.parts[0].text : '(...)'}`)).substring(0, 1000)}...\n\nÁî®Êà∑ÁöÑÊúÄÊñ∞ËæìÂÖ•/ÈÄâÊã©ÊòØ: "${promptHistory[promptHistory.length - 1].parts[0].text}"\n\nËØ∑ÁîüÊàê JSON Ê†ºÂºèÁöÑÂìçÂ∫î„ÄÇ`;

             // --- Rest of the API call logic (unchanged) ---
             try {
                 let messagesForApi = [];
                 if (promptHistory.length === 1 && promptHistory[0].isSetup) { messagesForApi = [ { "role": "system", "content": systemInstruction }, { "role": "user", "content": promptHistory[0].parts[0].text } ]; }
                 else { messagesForApi = [ { "role": "system", "content": systemInstruction }, ...promptHistory.slice(-7).map(h => ({ role: h.role === 'model' ? 'assistant' : 'user', content: h.parts[0].text })) ]; }

                 if (finalApiUrl.includes('generativelanguage.googleapis.com')) { if (!finalApiUrl.includes('/v1beta/models')) { finalApiUrl = finalApiUrl.replace(/\/$/, '') + `/v1beta/models/${currentModel}:generateContent?key=${currentApiKey}`; } else { finalApiUrl = finalApiUrl.replace(/\/$/, '') + `?key=${currentApiKey}`; } let geminiContents = []; messagesForApi.forEach(msg => { if (msg.role === 'system') return; const role = (msg.role === 'assistant' ? 'model' : 'user'); if (geminiContents.length > 0 && geminiContents[geminiContents.length - 1].role === role) { console.warn(`Skipping message due to non-alternating roles for Gemini: ${JSON.stringify(msg)}`); return; } geminiContents.push({ role: role, parts: [{ text: msg.content }] }); }); requestBody = JSON.stringify({ contents: geminiContents, generationConfig: { responseMimeType: "application/json" } }); }
                 else if (finalApiUrl.includes('/v1')) { headers['Authorization'] = `Bearer ${currentApiKey}`; if (!finalApiUrl.includes('/chat/completions')) { finalApiUrl = finalApiUrl.replace(/\/v1\/?$/, '') + '/v1/chat/completions'; } requestBody = JSON.stringify({ model: currentModel, messages: messagesForApi, response_format: { type: "json_object" } }); }
                 else { throw new Error("Êó†Ê≥ïËØÜÂà´ÁöÑ API Âü∫Á°ÄÂú∞ÂùÄÊ†ºÂºè„ÄÇ"); }

                 console.log("Calling Galgame LLM API:", finalApiUrl);
                 const response = await fetch(finalApiUrl, { method: 'POST', headers, body: requestBody });
                 console.log("LLM API Response Status:", response.status);
                 if (!response.ok) { let errorText = `API ËØ∑Ê±ÇÂ§±Ë¥•: ${response.status} ${response.statusText}`; try { const errorBody = await response.json(); errorText += `\nDetails: ${errorBody?.error?.message || JSON.stringify(errorBody)}`; } catch (_) { try { errorText += `\nDetails: ${await response.text()}`; } catch (e) {} } throw new Error(errorText); }
                 const data = await response.json();
                 let responseContent; if (data.candidates?.[0]?.content?.parts?.[0]?.text) { responseContent = data.candidates[0].content.parts[0].text; } else if (data.choices?.[0]?.message?.content) { responseContent = data.choices[0].message.content; } else { throw new Error("Êó†Ê≥ï‰ªé API ÂìçÂ∫î‰∏≠ÊèêÂèñÊúâÊïàÂÜÖÂÆπ„ÄÇ"); }
                 console.log("Extracted Response Content (before parsing):", responseContent);

                 let parsedData;
                 try {
                     const cleanedText = responseContent.replace(/^```json\s*|```$/gs, '').trim(); parsedData = JSON.parse(cleanedText);
                     // Validation (Unchanged from previous version)
                     if (!parsedData || typeof parsedData !== 'object') throw new Error("Parsed data is not an object.");
                     if (!parsedData.scene_state || typeof parsedData.scene_state !== 'object') throw new Error("Missing or invalid scene_state.");
                     if (typeof parsedData.scene_state.background_prompt !== 'string') throw new Error("Invalid background_prompt type.");
                     if (!Array.isArray(parsedData.scene_state.visible_characters)) throw new Error("Invalid visible_characters type.");
                     for(const charInfo of parsedData.scene_state.visible_characters) { if (typeof charInfo !== 'object' || charInfo === null) throw new Error("Invalid item in visible_characters array."); if (typeof charInfo.character_id !== 'string' || (charInfo.character_id !== 'player' && charInfo.character_id !== 'ai')) throw new Error("Invalid character_id in visible_characters."); if (typeof charInfo.emotion !== 'string' && charInfo.emotion !== null) throw new Error("Invalid emotion type in visible_characters."); }
                     if (!Array.isArray(parsedData.dialogue_segments)) throw new Error("Invalid dialogue_segments type.");
                     if (parsedData.dialogue_segments.length === 0) { console.warn("AI provided zero dialogue segments. Adding placeholder."); parsedData.dialogue_segments.push({speaker: "ÊóÅÁôΩ", text:"(AIÊú™ËøîÂõûÂØπËØùÂÜÖÂÆπ)", emotion: null}); } else { for(const segment of parsedData.dialogue_segments) { if (typeof segment !== 'object' || segment === null) throw new Error("Invalid item in dialogue_segments array."); if (typeof segment.speaker !== 'string') throw new Error("Invalid speaker type in dialogue_segments."); if (typeof segment.text !== 'string') throw new Error("Invalid text type in dialogue_segments."); segment.emotion = segment.emotion || null; } }
                     if (!Array.isArray(parsedData.choices)) throw new Error("Invalid choices type.");
                      if (parsedData.choices.length === 0) { console.warn("AI provided zero choices. Adding default."); parsedData.choices = ["[ÁªßÁª≠...]"]; } else { for(let i = 0; i < parsedData.choices.length; i++) { if (typeof parsedData.choices[i] !== 'string') throw new Error(`Invalid choice type at index ${i}.`); } }
                     if (promptHistory.length === 1 && promptHistory[0].isSetup) { if (!parsedData.initial_setup_details || typeof parsedData.initial_setup_details !== 'object') throw new Error("Initial setup response missing valid initial_setup_details object."); if (typeof parsedData.initial_setup_details.player_base_appearance_prompt !== 'string' || !parsedData.initial_setup_details.player_base_appearance_prompt.trim()) throw new Error("Initial setup missing valid player_base_appearance_prompt."); if (typeof parsedData.initial_setup_details.ai_base_appearance_prompt !== 'string' || !parsedData.initial_setup_details.ai_base_appearance_prompt.trim()) throw new Error("Initial setup missing valid ai_base_appearance_prompt."); console.log("Initial setup details received and validated."); }
                     else if (parsedData.initial_setup_details) { console.warn("AI incorrectly included initial_setup_details on a non-first turn. Ignoring it."); delete parsedData.initial_setup_details; }
                 } catch (parseError) {
                     console.error("Failed to parse or validate LLM JSON response:", parseError); console.error("Received content:", responseContent);
                     const fallbackData = { scene_state: { background_prompt: "error background", visible_characters: [] }, dialogue_segments: [{ speaker: "Á≥ªÁªü", text: `Êä±Ê≠âÔºåËß£ÊûêAIÂìçÂ∫îÊó∂Âá∫ÈîôÔºö${parseError.message}`, emotion: null }], choices: ["[Â∞ùËØïÁªßÁª≠]"] };
                     conversationHistory.push({ role: "model", parts: [{ text: JSON.stringify(fallbackData) }], isErrorFallback: true }); return fallbackData;
                 }

                 conversationHistory.push({ role: "model", parts: [{ text: JSON.stringify(parsedData) }] });
                 return parsedData;

             } catch (error) {
                 console.error("Ë∞ÉÁî® Galgame LLM API Êó∂Âá∫Èîô:", error); showGameError(error.message || "‰∏é AI ÁöÑËøûÊé•‰∏≠Êñ≠„ÄÇ");
                 const fallbackData = { scene_state: { background_prompt: "error background", visible_characters: [] }, dialogue_segments: [{ speaker: "Á≥ªÁªü", text: `Êä±Ê≠âÔºåËøûÊé•AIÊó∂Âá∫ÈîôÔºö${error.message}`, emotion: null }], choices: ["[Â∞ùËØïÁªßÁª≠]"] };
                 conversationHistory.push({ role: "model", parts: [{ text: JSON.stringify(fallbackData) }], isErrorFallback: true }); return fallbackData;
             }
        }

        // --- UI Update (Unchanged) ---
        function updateDialogueUI(parsedData) { console.log("Updating dialogue UI with parsed data:", parsedData); clearGameError(); currentDialogueSegments = parsedData.dialogue_segments || []; currentTurnChoices = parsedData.choices || []; currentSegmentIndex = 0; if (currentDialogueSegments.length > 0) { displayCurrentSegment(); if (currentDialogueSegments.length === 1) { processChoicesAndButtonState(); console.log("Single dialogue segment, processing choices."); } else { nextButton.style.display = 'block'; nextButton.disabled = false; choicesContainer.innerHTML = ''; console.log("Multi-segment dialogue. Next button enabled."); } } else { console.warn("Parsed data has no dialogue segments. Proceeding to choices."); dialogueText.innerHTML = ""; speakerName.textContent = "ÊóÅÁôΩ"; processChoicesAndButtonState(); } setLoading(false); }
        function displayCurrentSegment() { if (!currentDialogueSegments || currentSegmentIndex >= currentDialogueSegments.length) { console.error("displayCurrentSegment called with invalid index or no segments."); processChoicesAndButtonState(); setLoading(false); return; } const segment = currentDialogueSegments[currentSegmentIndex]; console.log(`Displaying segment ${currentSegmentIndex + 1}/${currentDialogueSegments.length}:`, segment); speakerName.textContent = segment.speaker || "Êú™Áü•"; try { const cleanHtml = typeof DOMPurify !== 'undefined' ? DOMPurify.sanitize(marked.parse(segment.text || "")) : marked.parse(segment.text || ""); dialogueText.innerHTML = cleanHtml; } catch (e) { console.error("Markdown parsing error for segment:", e); dialogueText.textContent = segment.text || ""; showGameError("ÂØπËØùÁâáÊÆµÊ†ºÂºèËß£ÊûêÂá∫Èîô„ÄÇ"); } dialogueBox.scrollTop = 0; choicesContainer.innerHTML = ''; nextButton.style.display = 'block'; const isLastSegment = currentSegmentIndex === currentDialogueSegments.length - 1; nextButton.disabled = isLastSegment; console.log(`Segment displayed. isLastSegment: ${isLastSegment}, nextButton disabled: ${nextButton.disabled}`); setLoading(false); }
        function processChoicesAndButtonState() { choicesContainer.innerHTML = ''; if (currentTurnChoices && currentTurnChoices.length > 0) { console.log("Processing final choices:", currentTurnChoices); nextButton.style.display = 'none'; currentTurnChoices.forEach((choiceText) => { const button = document.createElement('button'); button.classList.add('choice-button'); button.textContent = choiceText.replace(/^\[|\]$/g, ''); button.onclick = () => handleChoice_Galgame(choiceText); button.disabled = isLoading; choicesContainer.appendChild(button); }); nextButton.disabled = true; } else { console.error("No choices available to display. Game cannot proceed."); nextButton.style.display = 'block'; nextButton.disabled = true; showGameError("AI Êú™Êèê‰æõ‰ªª‰ΩïÈÄâÈ°πÔºåÊïÖ‰∫ãÊó†Ê≥ïÁªßÁª≠„ÄÇ"); } console.log("Choices processed and displayed."); setLoading(false); }


        // --- Game Flow Functions (startGame_Galgame clears cache, proceedStory calls correct loadDynamicImage) ---
        function startGame_Galgame() { // Clears cache
            console.log("startGame_Galgame called");
            if (!currentApiKey || !currentModel) { showGameError("ËØ∑ÂÖàÂÆåÊàêÂπ∂‰øùÂ≠ò API ÈÖçÁΩÆÔºÅ"); toggleConfigPanel(); return; }
            isGameStarted = true; nextButton.textContent = 'ÁªßÁª≠'; toggleHistoryBtn.disabled = false; conversationHistory = []; playerBaseAppearancePrompt = ''; aiBaseAppearancePrompt = ''; currentDialogueSegments = []; currentSegmentIndex = 0; currentTurnChoices = []; currentTurnParsedData = null; speakerName.textContent = 'ÊóÅÁôΩ'; dialogueText.innerHTML = '';
            spriteCache = {}; // <<< Clear sprite cache for new game

             let initialSetupPrompt = "=== Ê∏∏ÊàèÂºÄÂßãËÆæÂÆö ===\n"; // Instructions updated in callLLMApi_Galgame
             initialSetupPrompt += `Áé©ÂÆ∂ÂêçÁß∞: ${playerName || 'Áé©ÂÆ∂'}\n`;
             if (playerPersona) { initialSetupPrompt += `Áé©ÂÆ∂ËßíËâ≤ÁÆÄ‰ªã (ÂåÖÂê´ÂèØÈÄâÂ§ñË≤åÁ∫øÁ¥¢): ${playerPersona}\n`; initialSetupPrompt += `‰ªªÂä°1: Âü∫‰∫éÁé©ÂÆ∂ÁÆÄ‰ªãÔºåÁîüÊàê‰∏Ä‰∏™„ÄêÊûÅÂÖ∂ËØ¶ÁªÜ‰∏îËøûË¥Ø„ÄëÁöÑÁé©ÂÆ∂„ÄêÂü∫Á°ÄÂ§ñË≤åËã±ÊñáÊèêÁ§∫ËØç„Äë (ÂåÖÊã¨ÊÄßÂà´„ÄÅÂ§ßËá¥Ë∫´È´ò/‰ΩìÂûã„ÄÅÂèëÂûã„ÄÅÂèëËâ≤„ÄÅÁû≥Ëâ≤„ÄÅËÑ∏Âûã„ÄÅÂÖ∑‰ΩìÊúçË£ÖÁ≠â)„ÄÇÂ¶ÇÊûúÁÆÄ‰ªã‰∏≠Áº∫Â∞ëÁªÜËäÇÔºåËØ∑ÂêàÁêÜË°•ÂÖÖ„ÄÇ„ÄêÁ¶ÅÊ≠¢„ÄëÂåÖÂê´ 'same character/face/style' Á≠âÊó†ÊïàËØçËØ≠„ÄÇ\n`; } else { initialSetupPrompt += `Áé©ÂÆ∂ËßíËâ≤ÁÆÄ‰ªã: (Êó†ÔºåÁî±‰Ω†ÂàõÈÄ†)\n`; initialSetupPrompt += `‰ªªÂä°1: ÂàõÈÄ†‰∏Ä‰∏™ÂêàÈÄÇÁöÑÁé©ÂÆ∂ËßíËâ≤ÔºåÂπ∂ÁîüÊàê‰∏Ä‰∏™„ÄêÊûÅÂÖ∂ËØ¶ÁªÜ‰∏îËøûË¥Ø„ÄëÁöÑÁé©ÂÆ∂„ÄêÂü∫Á°ÄÂ§ñË≤åËã±ÊñáÊèêÁ§∫ËØç„Äë (ÂåÖÊã¨ÊÄßÂà´„ÄÅÂ§ßËá¥Ë∫´È´ò/‰ΩìÂûã„ÄÅÂèëÂûã„ÄÅÂèëËâ≤„ÄÅÁû≥Ëâ≤„ÄÅËÑ∏Âûã„ÄÅÂÖ∑‰ΩìÊúçË£ÖÁ≠â)„ÄÇ„ÄêÁ¶ÅÊ≠¢„ÄëÂåÖÂê´ 'same character/face/style' Á≠âÊó†ÊïàËØçËØ≠„ÄÇ\n`; }
             if (currentAiPersona) { initialSetupPrompt += `AIÂØπÊâãËßíËâ≤ËÆæÂÆö (ÂåÖÂê´ÂèØÈÄâÂ§ñË≤åÁ∫øÁ¥¢): ${currentAiPersona}\n`; initialSetupPrompt += `‰ªªÂä°2: Âü∫‰∫éAIËßíËâ≤ËÆæÂÆöÔºåÁîüÊàê‰∏Ä‰∏™„ÄêÊûÅÂÖ∂ËØ¶ÁªÜ‰∏îËøûË¥Ø„ÄëÁöÑAIËßíËâ≤„ÄêÂü∫Á°ÄÂ§ñË≤åËã±ÊñáÊèêÁ§∫ËØç„Äë„ÄÇ„ÄêÁ¶ÅÊ≠¢„ÄëÂåÖÂê´ 'same character/face/style' Á≠âÊó†ÊïàËØçËØ≠„ÄÇ\n`; } else { initialSetupPrompt += `AIÂØπÊâãËßíËâ≤ËÆæÂÆö: (Êó†ÔºåÁî±‰Ω†ÂàõÈÄ†)\n`; initialSetupPrompt += `‰ªªÂä°2: ÂàõÈÄ†‰∏Ä‰∏™ÂêàÈÄÇÁöÑAIÂØπÊâãËßíËâ≤ÔºåÂπ∂ÁîüÊàê‰∏Ä‰∏™„ÄêÊûÅÂÖ∂ËØ¶ÁªÜ‰∏îËøûË¥Ø„ÄëÁöÑAIËßíËâ≤„ÄêÂü∫Á°ÄÂ§ñË≤åËã±ÊñáÊèêÁ§∫ËØç„Äë„ÄÇ„ÄêÁ¶ÅÊ≠¢„ÄëÂåÖÂê´ 'same character/face/style' Á≠âÊó†ÊïàËØçËØ≠„ÄÇ\n`; }
             initialSetupPrompt += `ÊúüÊúõÂºÄÂ±Ä: ${playerStart || '‰∏Ä‰∏™ÊúâË∂£ÊàñÂ∏∏ËßÅÁöÑÊó•Â∏∏Âú∫ÊôØ„ÄÇ'}\n`; initialSetupPrompt += `Ê∏∏ÊàèÁ±ªÂûã: ‰∫íÂä®ÊïÖ‰∫ã (‰∏çÈôê‰∫éÁâπÂÆöÁ±ªÂûã)\n`; initialSetupPrompt += "=== ‰ªªÂä°3 (ÁîüÊàêÈ¶ñÊ¨°ÂìçÂ∫î) ===\n"; initialSetupPrompt += `ËØ∑ÁîüÊàêÊ∏∏ÊàèÁöÑÂºÄÂú∫ÁôΩ„ÄÅÂú∫ÊôØÊèèËø∞ÂíåÁ¨¨‰∏Ä‰∏™ÂØπËØùÁâáÊÆµ„ÄÇËØ∑Á°Æ‰øù„ÄêÈ¶ñÊ¨°ÂìçÂ∫î„ÄëÁöÑJSONÂåÖÂê´‰ª•‰∏ãÂÜÖÂÆπÔºö\n`; initialSetupPrompt += `1.  \`initial_setup_details\` ÂØπË±°ÔºåÂÜÖÂê´ÁîüÊàêÁöÑ \`player_base_appearance_prompt\` Âíå \`ai_base_appearance_prompt\`„ÄÇ\n`; initialSetupPrompt += `2.  \`scene_state\` ÂØπË±°ÔºåÂåÖÂê´ \`background_prompt\` Âíå \`visible_characters\` Êï∞ÁªÑ„ÄÇ\n`; initialSetupPrompt += `3.  \`dialogue_segments\` Êï∞ÁªÑ„ÄÇ\n`; initialSetupPrompt += `4.  \`choices\` Êï∞ÁªÑ„ÄÇ\n`; initialSetupPrompt += "ËØ∑‰∏•Ê†º‰ΩøÁî®ÂâçÈù¢ÊèèËø∞ÁöÑÊñ∞JSONÊ†ºÂºèËæìÂá∫„ÄÇ\n"; initialSetupPrompt += "=====================\n";

            console.log("Initial Setup Prompt:", initialSetupPrompt);
            conversationHistory.push({ role: 'user', parts: [{ text: initialSetupPrompt }], isSetup: true });
            proceedStory_Galgame();
        }

        async function proceedStory_Galgame(userChoice = null) { // Calls loadDynamicImage correctly
            if (userChoice) { console.log("proceedStory_Galgame called with choice:", userChoice); }
            else { console.log("proceedStory_Galgame called for initial setup or next segment"); }

            setLoading(true); clearGameError(); currentTurnParsedData = null;
            aiCharacterSprite.classList.add('hidden'); playerCharacterSprite.classList.add('hidden');

            try {
                const parsedData = await callLLMApi_Galgame(conversationHistory);
                currentTurnParsedData = parsedData;

                if (parsedData.initial_setup_details) {
                    playerBaseAppearancePrompt = parsedData.initial_setup_details.player_base_appearance_prompt || '';
                    aiBaseAppearancePrompt = parsedData.initial_setup_details.ai_base_appearance_prompt || '';
                    console.log("Stored Player Base Appearance:", playerBaseAppearancePrompt);
                    console.log("Stored AI Base Appearance:", aiBaseAppearancePrompt);
                }

                updateDialogueUI(parsedData);

                const imagePromises = [];
                const sceneState = parsedData.scene_state || {};
                let playerShouldBeVisible = false; let aiShouldBeVisible = false;

                imagePromises.push(loadDynamicImage(gameBackground, sceneState.background_prompt || "default anime background", 'background'));

                const visibleCharacters = sceneState.visible_characters || [];
                visibleCharacters.forEach(charInfo => {
                    let basePrompt = ''; let imgElement = null; let altText = '';
                    if (charInfo.character_id === 'player' && playerBaseAppearancePrompt) { basePrompt = playerBaseAppearancePrompt; imgElement = playerCharacterSprite; altText = playerName || "Áé©ÂÆ∂ËßíËâ≤"; playerShouldBeVisible = true; }
                    else if (charInfo.character_id === 'ai' && aiBaseAppearancePrompt) { basePrompt = aiBaseAppearancePrompt; imgElement = aiCharacterSprite; const aiNameMatch = currentAiPersona.match(/\[([^\]]+)\]/); altText = aiNameMatch ? aiNameMatch[1] : "AIËßíËâ≤"; aiShouldBeVisible = true; }

                    if (imgElement && basePrompt) {
                        let characterDetails = basePrompt; // Start with base
                        if (charInfo.emotion && typeof charInfo.emotion === 'string' && charInfo.emotion.trim() !== "") {
                            characterDetails += `, ${charInfo.emotion.trim()}`; // Add emotion modifier
                        }
                        imgElement.alt = altText;
                        // Pass only the character details (base + emotion) to loadDynamicImage
                        // The fixed style and background keywords are added *inside* loadDynamicImage
                        imagePromises.push(loadDynamicImage(imgElement, characterDetails, 'character'));
                    }
                });

                console.log("Waiting for image loading promises...");
                await Promise.allSettled(imagePromises);
                console.log("Image promises settled.");

                // Visibility management (Unchanged)
                 if (!playerShouldBeVisible) { playerCharacterSprite.classList.add('hidden'); console.log("Ensuring player sprite is hidden based on visibility flag."); }
                 else if (playerCharacterSprite.classList.contains('hidden') && playerShouldBeVisible) { playerCharacterSprite.classList.remove('hidden'); playerCharacterSprite.style.opacity = 1; console.log("Ensuring player sprite is SHOWN based on visibility flag.");}
                 if (!aiShouldBeVisible) { aiCharacterSprite.classList.add('hidden'); console.log("Ensuring AI sprite is hidden based on visibility flag."); }
                 else if (aiCharacterSprite.classList.contains('hidden') && aiShouldBeVisible) { aiCharacterSprite.classList.remove('hidden'); aiCharacterSprite.style.opacity = 1; console.log("Ensuring AI sprite is SHOWN based on visibility flag.");}

            } catch (error) {
                console.error("Error proceeding Galgame story:", error); showGameError(`Â§ÑÁêÜÊïÖ‰∫ãÊó∂ÂèëÁîüÈîôËØØ: ${error.message}`); setLoading(false);
            }
        }

        // --- handleNext_Galgame, handleChoice_Galgame (Unchanged) ---
        function handleNext_Galgame() {
             console.log("handleNext_Galgame called."); if (isLoading || !isGameStarted) return;
             if (currentDialogueSegments && currentSegmentIndex < currentDialogueSegments.length - 1) {
                 currentSegmentIndex++; setLoading(true); displayCurrentSegment();
                 if (currentSegmentIndex === currentDialogueSegments.length - 1) { console.log("Last segment reached via Next, processing choices."); processChoicesAndButtonState(); }
             } else { console.warn("handleNext_Galgame called unexpectedly."); nextButton.disabled = true; setLoading(false); }
        }
        function handleChoice_Galgame(choiceText) {
            console.log("handleChoice_Galgame called with:", choiceText, "isLoading:", isLoading); if (isLoading) return; console.log("Galgame User chose:", choiceText);
            choicesContainer.querySelectorAll('button').forEach(btn => btn.disabled = true);
            conversationHistory.push({ role: 'user', parts: [{ text: choiceText }], isSetup: false });
            currentDialogueSegments = []; currentSegmentIndex = 0; currentTurnChoices = []; currentTurnParsedData = null;
            console.log(">>> About to call proceedStory_Galgame from handleChoice");
            proceedStory_Galgame();
            console.log("<<< Call to proceedStory_Galgame finished (in handleChoice_Galgame)");
        }

        // --- Event Listeners (Unchanged) ---
        document.addEventListener('DOMContentLoaded', () => {
             console.log("DOM Content Loaded. Attaching listeners."); loadConfig(); if (toggleConfigBtn) toggleConfigBtn.addEventListener('click', toggleConfigPanel); if (closeConfigBtn) closeConfigBtn.addEventListener('click', toggleConfigPanel); if (saveConfigBtn) { saveConfigBtn.addEventListener('click', () => { saveConfig(); configPanel.classList.remove('visible'); console.log("Config panel closed via Save button."); }); } if (fetchModelsBtn) fetchModelsBtn.addEventListener('click', fetchLLMModels); const testKeyButtonElement = document.getElementById('test-key-btn'); if (testKeyButtonElement) { testKeyButtonElement.addEventListener('click', testApiKey); } if (toggleApiKeyVisibilityBtn && apiKeyInput) { toggleApiKeyVisibilityBtn.addEventListener('click', () => { const isP = apiKeyInput.type === 'password'; apiKeyInput.type = isP ? 'text':'password'; toggleApiKeyVisibilityBtn.textContent = isP ? 'üëÅÔ∏è‚Äçüó®Ô∏è':'üëÅÔ∏è'; }); } if(modelSelect) modelSelect.addEventListener('change', saveConfig); if(aiPersonaInput) aiPersonaInput.addEventListener('input', saveConfig); if(apiKeyInput) apiKeyInput.addEventListener('input', saveConfig); if(apiUrlInput) apiUrlInput.addEventListener('input', saveConfig); if(playerNameInput) playerNameInput.addEventListener('input', saveConfig); if(playerPersonaInput) playerPersonaInput.addEventListener('input', saveConfig); if(playerStartInput) playerStartInput.addEventListener('input', saveConfig); if (nextButton) { nextButton.addEventListener('click', () => { if (!isGameStarted) { startGame_Galgame(); } else { handleNext_Galgame(); } }); } if (toggleHistoryBtn) toggleHistoryBtn.addEventListener('click', toggleHistoryPanel); if (closeHistoryBtn) closeHistoryBtn.addEventListener('click', toggleHistoryPanel); console.log("All listeners attached.");
        });

    </script>
    </body>
    </html>