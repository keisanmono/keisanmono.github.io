<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ’– AI Galgame | ğŸŒ¸ æˆ‘çš„äºŒæ¬¡å…ƒå°çª ğŸŒ¸</title>
    <link rel="stylesheet" href="css/style.css"> <!-- Link to main style -->
    <!-- Marked.js for Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- DOMPurify for security -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.10/purify.min.js"></script>

    <style>
        /* --- Galgame Specific Styles (Additions/Modifications Highlighted) --- */
        /* ... (Keep all previous styles for galgame-container, dialogue-box, controls, etc.) ... */

        /* Config Panel Enhancements for Image Upload */
        #config-panel {
            /* ... (keep existing styles) ... */
            max-height: 90vh; /* Allow more height for images */
        }
         .image-upload-section {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
            border: 1px solid var(--galgame-config-input-border);
            padding: 10px;
            border-radius: 5px;
            background: rgba(0,0,0,0.1);
         }
         body.theme-dark .image-upload-section { background: rgba(255,255,255,0.05); }

         .image-upload-section input[type="file"] {
            /* Basic file input styling override */
            padding: 5px; /* Smaller padding */
            font-size: 0.9em;
            background: rgba(255,255,255,0.1);
            border: 1px dashed var(--galgame-config-input-border);
            flex-grow: 1; /* Allow input to take space */
            cursor: pointer;
            color: var(--galgame-config-label-color);
         }
        /* Hide default file input text */
         .image-upload-section input[type="file"]::file-selector-button {
            padding: 6px 10px;
            border: none;
            background-color: var(--galgame-control-btn-bg);
            color: var(--galgame-control-btn-color);
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            font-size: 0.9em;
            transition: background-color 0.2s ease;
         }
         .image-upload-section input[type="file"]::file-selector-button:hover {
            background-color: var(--galgame-control-btn-hover-bg);
         }


         .image-preview-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
         }

         .image-preview {
            max-width: 80px;
            max-height: 80px;
            height: auto;
            width: auto;
            border-radius: 4px;
            border: 1px solid var(--galgame-config-input-border);
            object-fit: cover;
            display: none; /* Hidden by default */
         }
         .clear-image-btn {
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 3px 8px;
            font-size: 0.8em;
            cursor: pointer;
            display: none; /* Hidden by default */
         }
         .clear-image-btn:hover { background: #5a6268; }

        /* --- End Image Upload Styles --- */


        /* Main container */
        #galgame-container {
            position: relative;
            width: 100%;
            height: calc(100vh - 100px); /* Example: Full viewport height minus approximate header/footer */
            min-height: 500px; /* Minimum height */
            overflow: hidden;
            border-radius: 15px;
            box-shadow: 0 5px 20px var(--galgame-container-shadow, rgba(0,0,0,0.2));
            margin-top: 20px;
        }

        /* Background Image */
        #game-background {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--content-bg); /* Fallback color */
            background-size: cover; background-position: center; z-index: 1;
            transition: background-image 0.8s ease-in-out; /* Smoother transition */
            background-image: url('https://image.pollinations.ai/prompt/beautiful%20anime%20classroom%20background,%20large%20windows,%20sunlight%20streaming%20in,%20empty,%20detailed,%20peaceful%20atmosphere?width=1024&height=576&seed=101&nologo=true');
        }

        /* --- Character Sprite Areas --- */
        .character-area {
            position: absolute;
            bottom: 5%;
            height: 65%;
            width: auto; /* Allow width to adjust based on height */
            max-width: 40%; /* Limit width slightly more to fit two */
            z-index: 3;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
        }

        /* AI Character (Right Side) */
        #ai-character-area {
            right: 5%; /* Position on the right */
            transform: none; /* Remove horizontal centering */
        }

        /* Player Character (Left Side) */
        #player-character-area {
            left: 5%; /* Position on the left */
            transform: none; /* Remove horizontal centering */
        }

        .character-sprite {
            display: block;
            max-height: 100%;
            max-width: 100%;
            height: auto;
            width: auto;
            object-fit: contain;
            filter: drop-shadow(3px 5px 8px rgba(0,0,0,0.4));
            transition: transform 0.4s ease, opacity 0.5s ease;
            opacity: 1;
        }
        /* Class to hide sprites */
        .character-sprite.hidden {
            opacity: 0;
            transform: scale(0.95);
        }
        /* Specific ID for AI sprite if needed */
        #ai-character-sprite { }
        /* Specific ID for Player sprite */
        #player-character-sprite {
            /* Flip horizontally if desired */
             /* transform: scaleX(-1); */
        }


        /* Dialogue Box */
        #dialogue-box {
            position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 950px;
            min-height: 140px; max-height: 38%;
            background: var(--galgame-dialogue-bg);
            backdrop-filter: var(--galgame-dialogue-backdrop-filter);
            border-radius: 12px;
            border: 1px solid var(--galgame-dialogue-border);
            padding: 20px 30px;
            color: var(--galgame-dialogue-text-color);
            z-index: 4; overflow-y: auto;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            scrollbar-width: thin;
            scrollbar-color: var(--galgame-scrollbar-thumb-bg) var(--galgame-scrollbar-track-bg);
        }
         #dialogue-box::-webkit-scrollbar { width: 8px; }
         #dialogue-box::-webkit-scrollbar-track { background: var(--galgame-scrollbar-track-bg); border-radius: 4px;}
         #dialogue-box::-webkit-scrollbar-thumb { background-color: var(--galgame-scrollbar-thumb-bg); border-radius: 4px; border: 1px solid rgba(0, 0, 0, 0.3); }
         #dialogue-box::-webkit-scrollbar-thumb:hover { background-color: var(--galgame-scrollbar-thumb-hover-bg); }

        #speaker-name {
            font-weight: bold; margin-bottom: 10px;
            color: var(--galgame-speaker-name-color);
            font-size: 1.15em;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        #dialogue-text { line-height: 1.7; font-size: 1.05em; }
        /* Markdown Styles (Keep as before) */
         #dialogue-text p { margin-bottom: 0.8em;}
         #dialogue-text h1, #dialogue-text h2, #dialogue-text h3 { margin-top: 0.5em; margin-bottom: 0.3em; color: var(--galgame-config-link-color); }
         #dialogue-text strong { color: var(--galgame-speaker-name-color); }
         #dialogue-text em { color: #90ee90; }
         #dialogue-text ul, #dialogue-text ol { padding-left: 25px; margin-bottom: 0.8em;}
         #dialogue-text li { margin-bottom: 0.3em;}
         #dialogue-text code { background-color: rgba(255,255,255,0.1); padding: 2px 5px; border-radius: 4px; font-family: 'Courier New', Courier, monospace; color: #f0f0f0; }
         #dialogue-text pre { background-color: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; overflow-x: auto; margin-bottom: 0.8em; }
         #dialogue-text pre code { background: none; padding: 0; }
         #dialogue-text blockquote { border-left: 3px solid var(--galgame-control-btn-bg); padding-left: 10px; margin: 0.8em 0; color: #ccc; font-style: italic; }
         #dialogue-text a { color: var(--galgame-config-link-color); text-decoration: underline; }
         #dialogue-text a:hover { filter: brightness(1.2); }

        /* Game Controls */
        #game-controls {
            position: absolute; bottom: 25px; right: 30px; z-index: 5;
            display: flex; gap: 12px; align-items: center;
        }
        .control-button {
             padding: 10px 20px; border: none; border-radius: 20px;
             background: var(--galgame-control-btn-bg); color: var(--galgame-control-btn-color);
             cursor: pointer; transition: all 0.3s ease; font-size: 1em; font-weight: 500;
             box-shadow: 0 4px 10px var(--shadow-color-medium); border: 1px solid var(--galgame-control-btn-border);
             backdrop-filter: blur(3px);
         }
         .control-button:hover:not(:disabled) { background: var(--galgame-control-btn-hover-bg); box-shadow: 0 6px 15px var(--shadow-color-dark); transform: translateY(-2px); }
         .control-button:disabled { background: var(--text-color-lighter); cursor: not-allowed; box-shadow: none; opacity: 0.7; }
         #toggle-history-btn { background: var(--galgame-history-btn-bg); color: var(--galgame-history-btn-color); }
         #toggle-history-btn:hover:not(:disabled) { background: var(--galgame-history-btn-hover-bg); }

        /* Choices Container */
        #choices-container { display: flex; flex-direction: column; gap: 10px; margin-top: 15px; }
        .choice-button {
             display: block; width: 100%; text-align: left; padding: 10px 15px;
             border: 1px solid var(--galgame-choice-btn-border); border-radius: 8px;
             background: var(--galgame-choice-btn-bg); color: var(--galgame-choice-btn-color);
             cursor: pointer; transition: background-color 0.3s ease; font-size: 0.95em;
         }
         .choice-button:hover { background: var(--galgame-choice-btn-hover-bg); }

        /* Config Panel & Contents */
        #config-panel {
            position: absolute; top: 10px; right: 10px; width: 350px; /* Wider */
            background: var(--galgame-config-bg);
            backdrop-filter: var(--galgame-config-backdrop-filter);
            border-radius: 8px; padding: 20px; z-index: 10; color: var(--galgame-config-text-color);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); border: 1px solid var(--galgame-config-border);
            display: none; font-size: 0.9em; max-height: 80vh; overflow-y: auto; /* Allow scrolling */
        }
        #config-panel.visible { display: block; }
        #config-panel h3 { margin-top: 0; margin-bottom: 15px; text-align: center; color: var(--galgame-config-link-color); }
        #config-panel .form-group { margin-bottom: 15px; }
        #config-panel label { color: var(--galgame-config-label-color); margin-bottom: 5px; font-size: 0.95em; display: block;} /* Ensure label is block */
        #config-panel input[type="text"], #config-panel input[type="password"],
        #config-panel input[type="url"], #config-panel .select-wrapper select,
        #config-panel textarea {
            width: 100%; padding: 8px 10px; border: 1px solid var(--galgame-config-input-border);
            border-radius: 5px; background: var(--galgame-config-input-bg); color: var(--galgame-config-text-color);
            font-size: 1em; box-sizing: border-box; font-family: inherit;
             appearance: none; -webkit-appearance: none; -moz-appearance: none;
        }
         #config-panel textarea { min-height: 60px; } /* Give textareas a min height */
        #config-panel .select-wrapper::after { color: var(--galgame-config-label-color); }
        #config-panel .config-buttons { display: flex; justify-content: space-between; margin-top: 20px; }
        #config-panel button { padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.3s; font-size: 0.9em; }
        #save-config-btn { background-color: var(--galgame-save-btn-bg); color: white;} #save-config-btn:hover { background-color: var(--galgame-save-btn-hover-bg);}
        #close-config-btn { background-color: var(--galgame-close-btn-bg); color: white;} #close-config-btn:hover { background-color: var(--galgame-close-btn-hover-bg);}
        #key-status { font-size: 0.85em; margin-top: 5px; display: inline-block; height: 1.2em; }
        #key-status.testing { color: #ffc107; } #key-status.valid { color: #28a745; }
        #key-status.invalid { color: #dc3545; } #key-status.error { color: #ff8aae; }
        #toggle-config-btn {
            position: absolute; top: 20px; right: 20px; z-index: 15;
             background: var(--button-glass-bg); color: var(--button-primary-text); border: 1px solid var(--border-color-light);
             border-radius: 50%; width: 40px; height: 40px; font-size: 20px; cursor: pointer;
             backdrop-filter: blur(5px); transition: all 0.3s ease; display: flex; justify-content: center; align-items: center;
         }
         #toggle-config-btn:hover { background: var(--button-glass-hover-bg); transform: scale(1.1) rotate(45deg); }

        /* Loading & Error Overlays (Keep as before) */
        #game-loading-overlay { background: var(--galgame-loading-bg); color: var(--galgame-loading-text-color); position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 9; display: none; justify-content: center; align-items: center; font-size: 1.5em; text-align: center; border-radius: 15px;}
        #game-loading-overlay.visible { display: flex; }
        #game-loading-overlay span { animation: pulse 1.5s infinite ease-in-out; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        #game-error-message { background: var(--galgame-error-bg); color: var(--galgame-error-text-color); position: absolute; top: 10px; left: 50%; transform: translateX(-50%); padding: 10px 20px; border-radius: 8px; z-index: 11; display: none; font-size: 0.95em; box-shadow: 0 3px 10px rgba(0,0,0,0.2); }

        /* History Panel (Keep as before, display logic modified in JS) */
        #history-panel {
            background: var(--galgame-history-panel-bg); backdrop-filter: var(--galgame-history-panel-backdrop-filter);
            border: 1px solid var(--galgame-history-panel-border); color: var(--galgame-history-panel-text-color);
            position: absolute; top: 10%; left: 50%; transform: translateX(-50%); width: 70%; max-width: 700px; height: 70%; max-height: 600px; border-radius: 10px; padding: 25px; z-index: 12; box-shadow: 0 5px 25px rgba(0,0,0,0.4); display: none; flex-direction: column; font-size: 0.95em;
        }
        #history-panel.visible { display: flex; }
        #history-panel h3 { color: var(--galgame-history-panel-title-color); margin-top: 0; margin-bottom: 15px; text-align: center; flex-shrink: 0;}
        #history-content {
            flex-grow: 1; overflow-y: auto; padding-right: 10px; margin-bottom: 15px; line-height: 1.6;
            scrollbar-color: var(--galgame-history-scrollbar-thumb-bg) var(--galgame-history-scrollbar-track-bg);
        }
        #history-content::-webkit-scrollbar { width: 8px; }
        #history-content::-webkit-scrollbar-track { background: var(--galgame-history-scrollbar-track-bg); border-radius: 4px; }
        #history-content::-webkit-scrollbar-thumb { background-color: var(--galgame-history-scrollbar-thumb-bg); border-radius: 4px; border: 1px solid rgba(0, 0, 0, 0.5); }
        #history-content::-webkit-scrollbar-thumb:hover { background-color: var(--galgame-history-scrollbar-thumb-hover-bg); }
        #history-content .history-entry { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px dashed rgba(255, 255, 255, 0.15); }
        #history-content .history-entry:last-child { border-bottom: none; }
        #history-content .history-role-user { font-weight: bold; color: var(--galgame-history-role-user-color); margin-bottom: 5px; }
        #history-content .history-role-model { font-weight: bold; color: var(--galgame-history-role-model-color); margin-bottom: 5px; }
        /* Nested history text for segments */
        #history-content .history-dialogue-segment { margin-left: 10px; margin-bottom: 5px; font-size: 0.98em; }
        #history-content .history-dialogue-segment .segment-speaker { font-weight: bold; color: var(--galgame-speaker-name-color); margin-right: 5px; }
        #history-content .history-dialogue-segment .segment-text {}
        #history-content .history-dialogue-segment .segment-text p {margin-bottom: 0.3em;} /* Adjust spacing in history */


        #close-history-btn {
             background-color: var(--galgame-history-close-btn-bg); color: white;
             padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.3s; font-size: 0.9em; align-self: center; flex-shrink: 0;
        }
        #close-history-btn:hover { background-color: var(--galgame-history-close-btn-hover-bg); }

        /* Config Section Styles */
        .config-section { border: 1px dashed var(--galgame-config-input-border); padding: 15px; margin-bottom: 20px; border-radius: 8px; background: rgba(10, 10, 10, 0.1); }
        body.theme-dark .config-section { background: rgba(200, 200, 220, 0.05); }
        .config-section h4 { margin-top: 0; margin-bottom: 10px; color: var(--galgame-config-link-color); border-bottom: 1px solid var(--galgame-config-input-border); padding-bottom: 5px; }
        .form-grid { display: grid; grid-template-columns: 1fr; gap: 15px; }
        .api-key-wrapper { position: relative; display: flex; align-items: center; }
        .api-key-wrapper input { padding-right: 45px; flex-grow: 1; }
        #toggle-api-key-visibility { position: absolute; right: 1px; top: 50%; transform: translateY(-50%); background: none; border: none; cursor: pointer; padding: 10px; color: var(--galgame-config-label-color); font-size: 1.2em; line-height: 1; opacity: 0.7; transition: opacity 0.2s; }
        #toggle-api-key-visibility:hover { opacity: 1; color: var(--galgame-config-text-color); }
        .api-url-wrapper { display: flex; gap: 0; align-items: stretch; }
        .api-url-wrapper input[type="url"] { flex-grow: 1; border-top-right-radius: 0; border-bottom-right-radius: 0; border-right: none; }
        #fetch-models-btn { flex-shrink: 0; padding: 8px 15px; border: 1px solid var(--galgame-config-input-border); border-left: none; border-top-left-radius: 0; border-bottom-left-radius: 0; background: var(--galgame-control-btn-bg); color: var(--galgame-control-btn-color); cursor: pointer; font-weight: 500; font-size: 0.9em; transition: all 0.3s ease; height: auto; }
        #fetch-models-btn:hover { background: var(--galgame-control-btn-hover-bg); }
        #fetch-models-btn:disabled { background: rgba(255,255,255,0.1); color: var(--galgame-config-label-color); box-shadow: none; opacity: 0.5; }
        #model-loading-indicator { margin-left: 8px; color: var(--galgame-config-label-color); font-size: 1.2em; vertical-align: middle; display: none; }
        .input-hint { font-size: 0.85em; color: var(--galgame-config-label-color); display:block; margin-top: 5px; opacity: 0.8; }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
             #galgame-container { height: calc(100vh - 80px); }
             .character-area { height: 55%; max-width: 45%; } /* Adjust width for smaller screens */
             #dialogue-box { width: 95%; min-height: 120px; max-height: 45%; padding: 15px 20px; }
             #speaker-name { font-size: 1.05em; } #dialogue-text { font-size: 0.95em; }
             #game-controls { bottom: 15px; right: 15px; gap: 8px; } .control-button { padding: 8px 15px; font-size: 0.9em; }
             #history-panel { width: 90%; height: 75%; }
             #config-panel { width: 90%; max-width: 350px; right: 50%; transform: translateX(50%); top: 5%; }
             #toggle-config-btn { top: 10px; right: 10px; width: 35px; height: 35px; font-size: 18px;}
             .image-upload-section { flex-direction: column; align-items: stretch; } /* Stack upload elements */
             .image-preview { max-width: 60px; max-height: 60px; }
         }
         @media (max-width: 480px) {
             .character-area { height: 50%; max-width: 55%; } /* Further adjust width */
             #ai-character-area { right: 2%; }
             #player-character-area { left: 2%; }
             #dialogue-box { max-height: 50%; padding: 10px 15px; }
             #speaker-name { font-size: 1em; } #dialogue-text { font-size: 0.9em; }
             .control-button { padding: 6px 12px; font-size: 0.85em; }
             #history-panel { width: 95%; height: 80%; padding: 15px; }
             #config-panel { padding: 15px; width: 95%; }
             .image-preview { max-width: 50px; max-height: 50px; }
         }
    </style>
</head>
<body>
    <!-- Background, Sidebar, Toggle Button -->
    <div class="background"></div>
    <div id="sidebar">
        <nav id="sidebar-nav">
            <a href="index.html">ğŸ  ä¸»é¡µ</a>
            <a href="about.html">âœ¨ å…³äºæˆ‘</a>
            <a href="blog_page1.html">ğŸ“ åšå®¢</a>
            <a href="contact.html">ğŸ’Œ è”ç³»æˆ‘</a>
            <a href="download.html">ğŸ“ æ–‡ä»¶ä¸‹è½½</a>
            <a href="ai_draw.html">ğŸ¨ AI ä½œç”»</a>
            <a href="tno_generator.html">ğŸ“œ TNOäº‹ä»¶ç”Ÿæˆ</a>
            <a href="if_game.html">ğŸŒŒ AI äº’åŠ¨å°è¯´</a>
            <a href="ai_rpg.html">ğŸ’– AI Galgame</a>
        </nav>
        <div class="theme-switcher">
            <h4>åˆ‡æ¢ä¸»é¢˜:</h4>
            <div class="theme-buttons-container">
                <button data-theme="pastel" class="theme-button">ğŸŒ¸ ç²‰å½©æ¢¦å¢ƒ</button>
                <button data-theme="dark" class="theme-button">ğŸŒ™ åˆå¤œæ¨±è½</button>
            </div>
        </div>
    </div>
    <button id="toggle-btn">â˜°</button>

    <!-- Main Content Area -->
    <div class="content scroll-container">
        <header>
            <h1>AI Galgame äº’åŠ¨æ•…äº‹</h1>
             <button id="toggle-config-btn" title="è®¾ç½®">âš™</button> <!-- Config Toggle -->
        </header>

        <main>
            <!-- Configuration Panel (MODIFIED for Image Upload) -->
            <div id="config-panel">
                <!-- Player Settings Section -->
                <div class="config-section">
                    <h4>ç©å®¶è®¾å®š</h4>
                    <div class="form-group">
                        <label for="player-name-input">ä½ çš„åå­—:</label>
                        <input type="text" id="player-name-input" placeholder="è¾“å…¥ä½ æƒ³ä½¿ç”¨çš„åå­—">
                    </div>
                    <div class="form-group">
                        <label for="player-persona-input">ä½ çš„è§’è‰²ç®€ä»‹ (å¯é€‰ï¼Œè‹¥ä¸Šä¼ å›¾ç‰‡åˆ™ä¼˜å…ˆä½¿ç”¨å›¾ç‰‡):</label>
                        <textarea id="player-persona-input" rows="2" placeholder="ç®€å•æè¿°ä½ çš„è§’è‰² (ä¾‹å¦‚ï¼šä¸€ä¸ªæœ‰ç‚¹å†…å‘ä½†å–„è‰¯çš„é«˜ä¸­ç”Ÿ)"></textarea>
                    </div>
                    <!-- Player Image Upload -->
                    <div class="form-group">
                         <label for="player-image-upload">ä¸Šä¼ ä½ çš„è§’è‰²å›¾ç‰‡ (å¯é€‰):</label>
                         <div class="image-upload-section">
                             <input type="file" id="player-image-upload" accept="image/png, image/jpeg, image/webp">
                             <div class="image-preview-container">
                                 <img id="player-image-preview" class="image-preview" src="#" alt="ç©å®¶å›¾ç‰‡é¢„è§ˆ">
                                 <button id="clear-player-image-btn" class="clear-image-btn">æ¸…é™¤</button>
                             </div>
                         </div>
                         <small class="input-hint">ä¸Šä¼ å›¾ç‰‡åï¼ŒAIä¼šå°è¯•æ ¹æ®å›¾ç‰‡ç”Ÿæˆå¤–è²Œæè¿°ã€‚</small>
                     </div>
                     <div class="form-group">
                        <label for="player-start-input">æœŸæœ›çš„å¼€å±€:</label>
                        <textarea id="player-start-input" rows="2" placeholder="æè¿°ä½ æƒ³è¦çš„å¼€å±€åœºæ™¯ (ä¾‹å¦‚ï¼šåœ¨æ–°å­¦æ ¡çš„ç¬¬ä¸€å¤©è¿·è·¯äº†)"></textarea>
                    </div>
                </div>

                <!-- AI & API Settings Section -->
                <div class="config-section">
                     <h4>AI & API è®¾ç½®</h4>
                     <div class="form-grid">
                         <div class="form-group">
                            <label for="galgame-persona">AI å¯¹æ‰‹è§’è‰²è®¾å®š (å¯é€‰ï¼Œè‹¥ä¸Šä¼ å›¾ç‰‡åˆ™ä¼˜å…ˆä½¿ç”¨å›¾ç‰‡):</label>
                            <textarea id="galgame-persona" rows="2" placeholder="ä½ å¸Œæœ›AIæ‰®æ¼”ä»€ä¹ˆè§’è‰²ï¼Ÿ(ä¾‹å¦‚ï¼šä¸€ä¸ªå‚²å¨‡çš„åŒç­åŒå­¦ï¼Œåå«[äºšé‡Œæ²™]...)"></textarea>
                         </div>
                         <!-- AI Image Upload -->
                         <div class="form-group">
                              <label for="ai-image-upload">ä¸Šä¼ AIè§’è‰²å›¾ç‰‡ (å¯é€‰):</label>
                              <div class="image-upload-section">
                                  <input type="file" id="ai-image-upload" accept="image/png, image/jpeg, image/webp">
                                  <div class="image-preview-container">
                                      <img id="ai-image-preview" class="image-preview" src="#" alt="AIå›¾ç‰‡é¢„è§ˆ">
                                      <button id="clear-ai-image-btn" class="clear-image-btn">æ¸…é™¤</button>
                                  </div>
                              </div>
                              <small class="input-hint">ä¸Šä¼ å›¾ç‰‡åï¼ŒAIä¼šå°è¯•æ ¹æ®å›¾ç‰‡ç”Ÿæˆè¯¥è§’è‰²çš„å¤–è²Œæè¿°ã€‚</small>
                          </div>
                          <!-- API Key, URL, Model (Keep as before) -->
                          <div class="form-group">
                            <label for="llm-api-key">API å¯†é’¥:</label>
                            <div class="api-key-wrapper">
                                <input type="password" id="llm-api-key" placeholder="è¾“å…¥ API Key (ä¾‹å¦‚ Gemini)">
                                <button id="toggle-api-key-visibility" title="åˆ‡æ¢å¯è§æ€§">ğŸ‘ï¸</button>
                            </div>
                             <span id="key-status"></span>
                             <button id="test-key-btn" class="control-button" style="padding: 6px 10px; font-size: 0.8em; margin-top: 5px;">æµ‹è¯• Key</button>
                        </div>
                        <div class="form-group">
                            <label for="llm-api-url">API åŸºç¡€åœ°å€:</label>
                            <div class="api-url-wrapper">
                                <input type="url" id="llm-api-url" placeholder="ä¾‹å¦‚: https://generativelanguage.googleapis.com" value="https://generativelanguage.googleapis.com">
                                <button id="fetch-models-btn" title="è·å–å¯ç”¨æ¨¡å‹åˆ—è¡¨">è·å–åˆ—è¡¨</button>
                            </div>
                             <small class="input-hint">(Google: ç•™ç©ºæˆ–å¡« ...googleapis.com; OpenAIå…¼å®¹: å¡«åˆ° /v1/ ç»“å°¾)</small>
                        </div>
                        <div class="form-group">
                            <label for="llm-model-select">é€‰æ‹© LLM æ¨¡å‹:</label>
                             <div style="display: flex; align-items: center; gap: 10px;">
                                <div class="select-wrapper" style="flex-grow: 1;">
                                    <select id="llm-model-select" disabled>
                                        <option value="" disabled selected>-- è¯·å…ˆè·å–æ¨¡å‹åˆ—è¡¨ --</option>
                                    </select>
                                </div>
                                <span id="model-loading-indicator" title="æ­£åœ¨åŠ è½½æ¨¡å‹...">ğŸ”„</span>
                             </div>
                        </div>
                     </div>
                 </div>

                <div class="config-buttons">
                    <button id="save-config-btn">ä¿å­˜è®¾ç½®</button>
                    <button id="close-config-btn">å…³é—­</button>
                </div>
            </div>

            <!-- Galgame UI Container (Unchanged) -->
            <div id="galgame-container">
                <div id="game-background"></div>
                <div id="player-character-area" class="character-area">
                    <img id="player-character-sprite" src="#" alt="ç©å®¶è§’è‰²" class="character-sprite hidden">
                </div>
                <div id="ai-character-area" class="character-area">
                    <img id="ai-character-sprite" src="#" alt="AIè§’è‰²" class="character-sprite hidden">
                </div>
                <div id="dialogue-box">
                    <div id="speaker-name">æ—ç™½</div>
                    <div id="dialogue-text">åœ¨è¿™é‡Œè®¾ç½®ç©å®¶åç§°ã€è®¾å®šå’ŒæœŸæœ›å¼€å±€åï¼Œç‚¹å‡»â€œå¼€å§‹â€ã€‚</div>
                     <div id="choices-container"></div>
                </div>
                <div id="game-controls">
                    <button id="toggle-history-btn" class="control-button" title="æŸ¥çœ‹å¯¹è¯å†å²" disabled>å†å²</button>
                    <button id="next-button" class="control-button" disabled>å¼€å§‹ (è¯·å…ˆè®¾ç½®API)</button>
                </div>
                 <div id="game-loading-overlay"><span>å°‘å¥³ç¥ˆç¥·ä¸­...</span></div>
                 <div id="game-error-message"></div>
            </div>

             <!-- History Panel (Unchanged) -->
             <div id="history-panel">
                 <h3>å¯¹è¯å†å²è®°å½•</h3>
                 <div id="history-content"></div>
                 <button id="close-history-btn">å…³é—­</button>
             </div>
        </main>

        <footer>
            <p>Â© 2024 MOLIFULAN's Blog | Galgame powered by AI</p>
        </footer>
    </div>

    <!-- JS Files -->
    <script src="js/script.js"></script> <!-- Main site script -->
    <script>
        // --- Galgame Specific JS (v4 - Image Upload Support) ---

        // --- DOM Element References (Additions Highlighted) ---
        const configPanel = document.getElementById('config-panel');
        const toggleConfigBtn = document.getElementById('toggle-config-btn');
        const saveConfigBtn = document.getElementById('save-config-btn');
        const closeConfigBtn = document.getElementById('close-config-btn');
        const apiKeyInput = document.getElementById('llm-api-key');
        const apiUrlInput = document.getElementById('llm-api-url');
        const fetchModelsBtn = document.getElementById('fetch-models-btn');
        const modelSelect = document.getElementById('llm-model-select');
        const modelLoadingIndicator = document.getElementById('model-loading-indicator');
        const toggleApiKeyVisibilityBtn = document.getElementById('toggle-api-key-visibility');
        const keyStatusSpan = document.getElementById('key-status');
        const aiPersonaInput = document.getElementById('galgame-persona');
        const playerNameInput = document.getElementById('player-name-input');
        const playerPersonaInput = document.getElementById('player-persona-input');
        const playerStartInput = document.getElementById('player-start-input');
        const dialogueBox = document.getElementById('dialogue-box');
        const speakerName = document.getElementById('speaker-name');
        const dialogueText = document.getElementById('dialogue-text');
        const choicesContainer = document.getElementById('choices-container');
        const nextButton = document.getElementById('next-button');
        const loadingOverlay = document.getElementById('game-loading-overlay');
        const gameErrorMessage = document.getElementById('game-error-message');
        const historyPanel = document.getElementById('history-panel');
        const historyContent = document.getElementById('history-content');
        const toggleHistoryBtn = document.getElementById('toggle-history-btn');
        const closeHistoryBtn = document.getElementById('close-history-btn');
        const gameBackground = document.getElementById('game-background');
        const aiCharacterSprite = document.getElementById('ai-character-sprite');
        const playerCharacterSprite = document.getElementById('player-character-sprite');
        // Image Upload Elements
        const playerImageUpload = document.getElementById('player-image-upload');
        const playerImagePreview = document.getElementById('player-image-preview');
        const clearPlayerImageBtn = document.getElementById('clear-player-image-btn');
        const aiImageUpload = document.getElementById('ai-image-upload');
        const aiImagePreview = document.getElementById('ai-image-preview');
        const clearAiImageBtn = document.getElementById('clear-ai-image-btn');


        // --- Constants ---
        const FIXED_STYLE_PROMPT = "masterpiece, best quality, ultra-detailed, extremely detailed illustration, high resolution, sharp focus, dramatic lighting, strong highlights, deep contrasting shadows, emphasized light interaction, professional game art style, Japanese anime art style, normal anime proportions, standard body ratio, NOT chibi, NO SD";
        const SPRITE_BACKGROUND_KEYWORDS = "plain white background, isolated on white";
        const ALLOWED_IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/webp'];

        // --- State Variables ---
        // API & AI
        let currentApiKey = '';
        let currentApiUrl = '';
        let currentModel = '';
        let currentAiPersona = '';
        // Player
        let playerName = '';
        let playerPersona = '';
        let playerStart = '';
        // Image Data (Base64 Strings) - Not saved in localStorage
        let playerImageBase64 = null;
        let aiImageBase64 = null;
        // Character Appearance
        let playerBaseAppearancePrompt = '';
        let aiBaseAppearancePrompt = '';
        let spriteCache = {};
        // Game State
        let conversationHistory = [];
        let isGameStarted = false;
        let isLoading = false;
        const GALGAME_STORAGE_PREFIX = 'galGame_';
        const DEFAULT_API_URL_GALGAME = 'https://generativelanguage.googleapis.com';
        let currentDialogueSegments = [];
        let currentSegmentIndex = 0;
        let currentTurnChoices = [];
        let currentTurnParsedData = null;

        // --- Helper Functions ---
        // Extracts mime type and base64 data from a data URL
        function getImageDataFromBase64(base64String) {
            if (!base64String || !base64String.startsWith('data:image')) {
                return null;
            }
            const parts = base64String.split(',');
            if (parts.length !== 2) return null;
            const mimeMatch = parts[0].match(/:(.*?);/);
            if (!mimeMatch || mimeMatch.length < 2) return null;
            return {
                mimeType: mimeMatch[1],
                data: parts[1]
            };
        }

        // Reads a file input and converts to Base64
        function handleImageUpload(fileInput, previewElement, clearButton, stateVariableSetter) {
            const file = fileInput.files[0];
            if (!file) {
                stateVariableSetter(null); // Clear state if no file selected
                previewElement.style.display = 'none';
                clearButton.style.display = 'none';
                return;
            }

            if (!ALLOWED_IMAGE_TYPES.includes(file.type)) {
                showGameError(`ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: ${file.type}. è¯·ä¸Šä¼  JPG, PNG, æˆ– WebP æ ¼å¼å›¾ç‰‡.`);
                fileInput.value = null; // Clear the input
                stateVariableSetter(null);
                previewElement.style.display = 'none';
                clearButton.style.display = 'none';
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                stateVariableSetter(e.target.result); // Store Base64 string
                previewElement.src = e.target.result;
                previewElement.style.display = 'block';
                clearButton.style.display = 'inline-block';
                console.log(`Image loaded and stored for ${fileInput.id}`);
            };
            reader.onerror = (e) => {
                showGameError("è¯»å–å›¾ç‰‡æ–‡ä»¶æ—¶å‡ºé”™.");
                console.error("FileReader error:", e);
                fileInput.value = null;
                stateVariableSetter(null);
                previewElement.style.display = 'none';
                clearButton.style.display = 'none';
            };
            reader.readAsDataURL(file);
        }

        // Clears an image upload field
        function clearImageUpload(fileInput, previewElement, clearButton, stateVariableSetter) {
            fileInput.value = null;
            stateVariableSetter(null);
            previewElement.src = '#'; // Reset src
            previewElement.style.display = 'none';
            clearButton.style.display = 'none';
            console.log(`Image cleared for ${fileInput.id}`);
        }


        // --- Error & Loading UI (Unchanged) ---
        function showGameError(message) { console.error("Game Error:", message); gameErrorMessage.textContent = message; gameErrorMessage.style.display = 'block'; setTimeout(() => { clearGameError(); }, 7000); setLoading(false); }
        function clearGameError() { gameErrorMessage.style.display = 'none'; gameErrorMessage.textContent = ''; }
        function setLoading(loading) {
             console.log("Setting loading state to:", loading);
             isLoading = loading;
             loadingOverlay.classList.toggle('visible', loading);
             const canInteract = currentApiKey && currentModel;
             const choicesCurrentlyDisplayed = choicesContainer.querySelector('.choice-button') !== null;
             const moreSegmentsAvailable = currentDialogueSegments && currentSegmentIndex < currentDialogueSegments.length - 1;
             nextButton.disabled = loading || !canInteract || !isGameStarted || choicesCurrentlyDisplayed || !moreSegmentsAvailable;
             toggleHistoryBtn.disabled = loading || !canInteract || !isGameStarted;
             toggleConfigBtn.disabled = loading;
             document.querySelectorAll('.choice-button').forEach(btn => btn.disabled = loading);
         }

        // --- Configuration Logic (Save/Load don't handle images directly) ---
        function saveConfig() {
            // Image Base64 is not saved to localStorage
            const apiKey = apiKeyInput.value.trim(); const apiUrl = apiUrlInput.value.trim() || DEFAULT_API_URL_GALGAME; const model = modelSelect.value; const aiPersona = aiPersonaInput.value.trim(); const pName = playerNameInput.value.trim(); const pPersona = playerPersonaInput.value.trim(); const pStart = playerStartInput.value.trim(); localStorage.setItem(GALGAME_STORAGE_PREFIX + 'apiKey', apiKey); localStorage.setItem(GALGAME_STORAGE_PREFIX + 'apiUrl', apiUrl); localStorage.setItem(GALGAME_STORAGE_PREFIX + 'model', model); localStorage.setItem(GALGAME_STORAGE_PREFIX + 'aiPersona', aiPersona); localStorage.setItem(GALGAME_STORAGE_PREFIX + 'playerName', pName); localStorage.setItem(GALGAME_STORAGE_PREFIX + 'playerPersona', pPersona); localStorage.setItem(GALGAME_STORAGE_PREFIX + 'playerStart', pStart); currentApiKey = apiKey; currentApiUrl = apiUrl; currentModel = model; currentAiPersona = aiPersona; playerName = pName; playerPersona = pPersona; playerStart = pStart; console.log("Galgame Config saved (state updated, images not persisted):", { currentApiKey, currentApiUrl, currentModel, currentAiPersona, playerName, playerPersona, playerStart }); const canStart = currentApiKey && currentModel; nextButton.textContent = isGameStarted ? 'ç»§ç»­' : (canStart ? 'å¼€å§‹' : 'å¼€å§‹ (è¯·å…ˆè®¾ç½®API)'); nextButton.disabled = isLoading || !canStart; toggleHistoryBtn.disabled = isLoading || !canStart || !isGameStarted; if (!isGameStarted) { if (canStart) { let info = "API è®¾ç½®å·²åŠ è½½ã€‚\n"; if (playerName) info += `ç©å®¶åç§°: ${playerName}\n`; if (playerPersona || playerImageBase64) info += `ç©å®¶è®¾å®š: ${playerImageBase64 ? 'ä½¿ç”¨ä¸Šä¼ å›¾ç‰‡' : playerPersona.substring(0, 50)+'...'}\n`; if (currentAiPersona || aiImageBase64) info += `AI è§’è‰²: ${aiImageBase64 ? 'ä½¿ç”¨ä¸Šä¼ å›¾ç‰‡' : currentAiPersona.substring(0, 50)+'...'}\n`; if (playerStart) info += `å¼€å±€æç¤º: ${playerStart.substring(0, 50)}...\n`; info += "ç‚¹å‡»â€œå¼€å§‹â€è¿›å…¥æ•…äº‹ã€‚"; dialogueText.innerHTML = marked.parse(info); } else { dialogueText.innerHTML = marked.parse("æ¬¢è¿æ¥åˆ° AI Galgame äº’åŠ¨æ•…äº‹ï¼\nè¯·ç‚¹å‡»å³ä¸Šè§’çš„ **âš™** è®¾ç½®ä½ çš„ API Keyï¼Œå¹¶é€‰æ‹©ä¸€ä¸ªæ¨¡å‹ã€‚\nï¼ˆå¯é€‰ï¼‰è®¾ç½®ç©å®¶åç§°ã€è®¾å®šå’ŒæœŸæœ›å¼€å±€ã€‚\nå‡†å¤‡å¥½åï¼Œç‚¹å‡»â€œå¼€å§‹â€æŒ‰é’®ã€‚"); } }
        }
        function loadConfig() {
            // Load text configs from localStorage
            currentApiKey = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'apiKey') || ''; currentApiUrl = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'apiUrl') || DEFAULT_API_URL_GALGAME; currentModel = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'model') || ''; currentAiPersona = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'aiPersona') || ''; playerName = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'playerName') || ''; playerPersona = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'playerPersona') || ''; playerStart = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'playerStart') || ''; apiKeyInput.value = currentApiKey; apiUrlInput.value = currentApiUrl === DEFAULT_API_URL_GALGAME ? '' : currentApiUrl; aiPersonaInput.value = currentAiPersona; playerNameInput.value = playerName; playerPersonaInput.value = playerPersona; playerStartInput.value = playerStart; modelSelect.innerHTML = '<option value="" disabled selected>-- è·å–æˆ–é€‰æ‹©æ¨¡å‹ --</option>'; if (currentModel) { const o = document.createElement('option'); o.value = currentModel; o.textContent = currentModel + " (å·²ä¿å­˜)"; o.selected = true; modelSelect.appendChild(o); modelSelect.disabled = false; } else { modelSelect.disabled = true; } keyStatusSpan.textContent = ''; keyStatusSpan.className = '';
            // Reset image uploads on load
            clearImageUpload(playerImageUpload, playerImagePreview, clearPlayerImageBtn, (val) => playerImageBase64 = val);
            clearImageUpload(aiImageUpload, aiImagePreview, clearAiImageBtn, (val) => aiImageBase64 = val);

            console.log("Galgame Config loaded (Images reset):", { currentApiKey, currentApiUrl, currentModel, currentAiPersona, playerName, playerPersona, playerStart }); const canConfigure = currentApiKey && currentModel; isGameStarted = false; if (!canConfigure) { dialogueText.innerHTML = marked.parse("æ¬¢è¿æ¥åˆ° AI Galgame äº’åŠ¨æ•…äº‹ï¼\nè¯·ç‚¹å‡»å³ä¸Šè§’çš„ **âš™** è®¾ç½®ä½ çš„ API Keyï¼Œå¹¶é€‰æ‹©ä¸€ä¸ªæ¨¡å‹ã€‚\nï¼ˆå¯é€‰ï¼‰è®¾ç½®ç©å®¶åç§°ã€è®¾å®šã€ä¸Šä¼ å›¾ç‰‡å’ŒæœŸæœ›å¼€å±€ã€‚\nå‡†å¤‡å¥½åï¼Œç‚¹å‡»â€œå¼€å§‹â€æŒ‰é’®ã€‚"); nextButton.textContent = "å¼€å§‹ (è¯·å…ˆè®¾ç½®API)"; nextButton.disabled = true; toggleHistoryBtn.disabled = true; } else { let info = "API è®¾ç½®å·²åŠ è½½ã€‚\n"; if (playerName) info += `ç©å®¶åç§°: ${playerName}\n`; if (playerPersona || playerImageBase64) info += `ç©å®¶è®¾å®š: ${playerImageBase64 ? 'å¾…ä¸Šä¼ å›¾ç‰‡' : playerPersona.substring(0, 50)+'...'}\n`; if (currentAiPersona || aiImageBase64) info += `AI è§’è‰²: ${aiImageBase64 ? 'å¾…ä¸Šä¼ å›¾ç‰‡' : currentAiPersona.substring(0, 50)+'...'}\n`; if (playerStart) info += `å¼€å±€æç¤º: ${playerStart.substring(0, 50)}...\n`; info += "ç‚¹å‡»â€œå¼€å§‹â€è¿›å…¥æ•…äº‹ã€‚"; dialogueText.innerHTML = marked.parse(info); nextButton.textContent = "å¼€å§‹"; nextButton.disabled = isLoading || !canConfigure; toggleHistoryBtn.disabled = true; } aiCharacterSprite.classList.add('hidden'); playerCharacterSprite.classList.add('hidden'); }
        function toggleConfigPanel() { configPanel.classList.toggle('visible'); }
        async function fetchLLMModels() { /* Unchanged */ const apiKey = apiKeyInput.value.trim(); const baseApiUrl = apiUrlInput.value.trim() || DEFAULT_API_URL_GALGAME; if (!apiKey) { showGameError('è¯·å…ˆå¡«å†™ API å¯†é’¥ã€‚'); return; } keyStatusSpan.textContent = ''; keyStatusSpan.className = ''; modelLoadingIndicator.style.display = 'inline-block'; fetchModelsBtn.disabled = true; modelSelect.disabled = true; modelSelect.innerHTML = '<option value="" disabled selected>-- æ­£åœ¨è·å–... --</option>'; let modelListUrl = ''; let headers = { 'Content-Type': 'application/json' }; let method = 'GET'; try { if (baseApiUrl.includes('generativelanguage.googleapis.com')) { modelListUrl = baseApiUrl.replace(/\/$/, '') + `/v1beta/models?key=${apiKey}&pageSize=1000`; } else if (baseApiUrl.includes('/v1')) { headers['Authorization'] = `Bearer ${apiKey}`; modelListUrl = baseApiUrl.replace(/\/v1\/?$/, '') + '/v1/models'; } else { console.warn("æœªçŸ¥åœ°å€æ ¼å¼ï¼Œå°è¯• /v1/models"); headers['Authorization'] = `Bearer ${apiKey}`; modelListUrl = baseApiUrl.replace(/\/$/, '') + '/v1/models'; } console.log("Fetching models from:", modelListUrl); const response = await fetch(modelListUrl, { method, headers }); if (!response.ok) { const e = await response.text(); throw new Error(`è·å–å¤±è´¥: ${response.status} ${response.statusText}. ${e.substring(0,100)}`); } const data = await response.json(); console.log("Model List Raw:", data); let modelNames = []; if (data.models?.length) { modelNames = data.models.map(m => m.name?.replace(/^models\//, '')).filter(Boolean).filter(name => !/embed|vision|instruct|text-|aqa|diffusion|image/i.test(name)).sort(); } else if (data.data?.length) { modelNames = data.data.map(m => m.id).filter(Boolean).filter(id => !/embed|vision|instruct|text-|whisper|tts|davinci|babbage|curie|ada|image|diffusion/i.test(id)).sort(); } else { throw new Error("æ— æ³•è¯†åˆ«çš„æ¨¡å‹åˆ—è¡¨æ ¼å¼ã€‚"); } if (modelNames.length === 0) { throw new Error("åœ¨æ­¤ API åœ°å€æœªæ‰¾åˆ°å¯ç”¨çš„èŠå¤©æ¨¡å‹ã€‚"); } const previouslySelected = currentModel || modelSelect.value; modelSelect.innerHTML = '<option value="" disabled>-- è¯·é€‰æ‹©ä¸€ä¸ªæ¨¡å‹ --</option>'; let foundPrevious = false; modelNames.forEach(name => { const o=document.createElement('option'); o.value=name; o.textContent=name; if(name === previouslySelected) { o.selected = true; foundPrevious = true; } modelSelect.appendChild(o); }); if (!foundPrevious && modelSelect.options.length > 1) { modelSelect.selectedIndex = 1; } else if (!foundPrevious && modelSelect.options.length <= 1) { modelSelect.selectedIndex = 0; } currentModel = modelSelect.value; modelSelect.disabled = !currentModel; clearGameError(); } catch (error) { console.error("è·å–æ¨¡å‹å‡ºé”™:", error); showGameError(error.message || "è·å–æ¨¡å‹åˆ—è¡¨æ—¶å‡ºé”™ã€‚"); modelSelect.innerHTML = '<option value="" disabled selected>-- è·å–å¤±è´¥ --</option>'; modelSelect.disabled = true; } finally { modelLoadingIndicator.style.display = 'none'; fetchModelsBtn.disabled = false; modelSelect.disabled = modelSelect.options.length <= 1 || !modelSelect.value; saveConfig(); } }
        async function testApiKey() { /* Unchanged */ const testKeyButtonElement = document.getElementById('test-key-btn'); const apiKey = apiKeyInput.value.trim(); const baseApiUrl = apiUrlInput.value.trim() || DEFAULT_API_URL_GALGAME; if (!apiKey) { keyStatusSpan.textContent = 'è¯·è¾“å…¥ API Key'; keyStatusSpan.className = 'invalid'; return; } if (!testKeyButtonElement) { console.error("æ— æ³•æ‰¾åˆ°æµ‹è¯•æŒ‰é’®å…ƒç´ !"); keyStatusSpan.textContent = 'é¡µé¢é”™è¯¯'; keyStatusSpan.className = 'error'; return; } keyStatusSpan.textContent = 'æ­£åœ¨æµ‹è¯•...'; keyStatusSpan.className = 'testing'; testKeyButtonElement.disabled = true; let testUrl = ''; let headers = {}; let method = 'GET'; try { if (baseApiUrl.includes('generativelanguage.googleapis.com')) { testUrl = baseApiUrl.replace(/\/$/, '') + `/v1beta/models?key=${apiKey}`; } else if (baseApiUrl.includes('/v1')) { headers['Authorization'] = `Bearer ${apiKey}`; testUrl = baseApiUrl.replace(/\/v1\/?$/, '') + '/v1/models'; } else { throw new Error("æ— æ³•ç¡®å®šæµ‹è¯• URL æ ¼å¼"); } console.log("Testing API Key with URL:", testUrl); const response = await fetch(testUrl, { method, headers }); if (response.ok) { keyStatusSpan.textContent = 'âœ… Key æœ‰æ•ˆ'; keyStatusSpan.className = 'valid'; } else { let errorMsg = `âŒ Key æ— æ•ˆæˆ–URLé”™è¯¯ (${response.status})`; try{ const errData = await response.json(); if(errData?.error?.message) errorMsg += `: ${errData.error.message}`; } catch(e){} keyStatusSpan.textContent = errorMsg; keyStatusSpan.className = 'invalid'; } } catch (error) { keyStatusSpan.textContent = 'âš ï¸ æµ‹è¯•å‡ºé”™ (ç½‘ç»œ/URL?)'; keyStatusSpan.className = 'error'; console.error("Key test error:", error); } finally { testKeyButtonElement.disabled = false; } }

        // --- History Panel Logic (Unchanged) ---
        function toggleHistoryPanel() { console.log("toggleHistoryPanel called. isLoading:", isLoading, "isGameStarted:", isGameStarted); if (isLoading) return; if (!isGameStarted || !currentApiKey || !currentModel) { showGameError("è¯·å…ˆå¼€å§‹æ¸¸æˆä»¥æŸ¥çœ‹å†å²è®°å½•ã€‚"); return; } if (historyPanel.classList.contains('visible')) { historyPanel.classList.remove('visible'); } else { displayHistory(); historyPanel.classList.add('visible'); } }
        function displayHistory() { console.log("Displaying history. Count:", conversationHistory.length); historyContent.innerHTML = ''; if (conversationHistory.length === 0) { historyContent.innerHTML = '<p><i>è¿˜æ²¡æœ‰å¯¹è¯è®°å½•å‘¢...</i></p>'; return; } conversationHistory.forEach(entry => { if (entry.role === 'user' && entry.isSetup) { return; } const entryDiv = document.createElement('div'); entryDiv.classList.add('history-entry'); if (entry.role === 'user') { const roleSpan = document.createElement('div'); roleSpan.classList.add('history-role-user'); roleSpan.textContent = `${playerName || 'ä½ '}:`; const textDiv = document.createElement('div'); textDiv.classList.add('history-text'); textDiv.textContent = entry.parts[0]?.text || '(ç©ºæ¶ˆæ¯)'; entryDiv.appendChild(roleSpan); entryDiv.appendChild(textDiv); } else if (entry.role === 'model') { try { const parsedData = JSON.parse(entry.parts[0]?.text || '{}'); const segments = parsedData.dialogue_segments || []; const choices = parsedData.choices || []; if (segments.length > 0) { segments.forEach(segment => { const segmentDiv = document.createElement('div'); segmentDiv.classList.add('history-dialogue-segment'); const speakerSpan = document.createElement('span'); speakerSpan.classList.add('segment-speaker'); speakerSpan.textContent = `${segment.speaker || '???'}:`; const textSpan = document.createElement('span'); textSpan.classList.add('segment-text'); try { textSpan.innerHTML = typeof DOMPurify !== 'undefined' ? DOMPurify.sanitize(marked.parse(segment.text || '(ç©ºç‰‡æ®µ)')) : marked.parse(segment.text || '(ç©ºç‰‡æ®µ)'); } catch(e){ textSpan.textContent = segment.text || '(ç©ºç‰‡æ®µ)'; } segmentDiv.appendChild(speakerSpan); segmentDiv.appendChild(textSpan); entryDiv.appendChild(segmentDiv); }); } else { const roleSpan = document.createElement('div'); roleSpan.classList.add('history-role-model'); roleSpan.textContent = `AI (è§£æé”™è¯¯):`; const textDiv = document.createElement('div'); textDiv.classList.add('history-text'); textDiv.textContent = '(æ— æ³•è§£æå¯¹è¯ç‰‡æ®µ)'; entryDiv.appendChild(roleSpan); entryDiv.appendChild(textDiv); } if (choices.length > 0) { const choiceList = document.createElement('ul'); choiceList.style.fontSize = '0.9em'; choiceList.style.opacity = '0.7'; choiceList.style.marginTop = '8px'; choiceList.style.paddingLeft = '25px'; choices.forEach(c => { const li = document.createElement('li'); li.textContent = c.replace(/^\[|\]$/g, ''); choiceList.appendChild(li); }); entryDiv.appendChild(choiceList); } } catch (e) { console.error("Failed to parse model entry in history:", e, entry.parts[0]?.text); const roleSpan = document.createElement('div'); roleSpan.classList.add('history-role-model'); roleSpan.textContent = `AI (åŸå§‹):`; const textDiv = document.createElement('div'); textDiv.classList.add('history-text'); textDiv.textContent = entry.parts[0]?.text || '(æ— æ³•è§£æ)'; entryDiv.appendChild(roleSpan); entryDiv.appendChild(textDiv); } } historyContent.appendChild(entryDiv); }); historyContent.scrollTop = historyContent.scrollHeight; }

        // --- Character Sprite Background Removal (Unchanged) ---
        async function removeEdgeWhiteBackground(img) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                const width = img.naturalWidth; const height = img.naturalHeight;
                if (width === 0 || height === 0) { console.warn("Image has zero dimensions, cannot process."); resolve(img.src); return; }
                canvas.width = width; canvas.height = height;
                try {
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, width, height);
                    const data = imageData.data;
                    const visited = new Uint8Array(width * height);

                    // --- Pass 1: Edge Flood Fill (Use a moderate tolerance, e.g., 4 or 5) ---
                    const whiteThreshold = 255;
                    const floodFillTolerance = 7; // <<<<<<<<<< TRY ADJUSTING THIS (e.g., 4, 5, or 6)
                    const effectiveFloodThreshold = whiteThreshold - floodFillTolerance;

                    function isNearWhiteForFlood(index) {
                         if (index < 0 || index >= data.length || data[index+3] < 128) return false;
                         const r = data[index]; const g = data[index + 1]; const b = data[index + 2];
                         return r >= effectiveFloodThreshold && g >= effectiveFloodThreshold && b >= effectiveFloodThreshold;
                    }
                    function getIndex(x, y) { return (y * width + x) * 4; }
                    function getVisitedIndex(x, y) { return y * width + x; }
                    const queue = [];
                    for (let y = 0; y < height; y++) { for (let x = 0; x < width; x++) { if (y === 0 || y === height - 1 || x === 0 || x === width - 1) { const index = getIndex(x, y); const visitedIndex = getVisitedIndex(x,y); if (isNearWhiteForFlood(index) && !visited[visitedIndex]) { queue.push({ x, y }); visited[visitedIndex] = 1; } } } }
                    console.log(`Starting Flood Fill Pass. Tolerance: ${floodFillTolerance}. Initial Queue:`, queue.length);
                    let processedFloodFillCount = 0;
                    while (queue.length > 0) {
                        const { x, y } = queue.shift(); const index = getIndex(x, y);
                        if (data[index + 3] > 0) { data[index + 3] = 0; processedFloodFillCount++; } // Make transparent
                        const neighbors = [ { nx: x + 1, ny: y }, { nx: x - 1, ny: y }, { nx: x, ny: y + 1 }, { nx: x, ny: y - 1 } ];
                        for (const {nx, ny} of neighbors) { if (nx >= 0 && nx < width && ny >= 0 && ny < height) { const neighborIndex = getIndex(nx, ny); const visitedIndex = getVisitedIndex(nx, ny); if (isNearWhiteForFlood(neighborIndex) && !visited[visitedIndex]) { visited[visitedIndex] = 1; queue.push({ x: nx, y: ny }); } } }
                    }
                    console.log(`Flood fill finished. ${processedFloodFillCount} pixels made transparent.`);

                    // --- Pass 2: Cleanup Isolated Near-White Pixels ---
                    const cleanupTolerance = 4; // <<<<<<<<<< Use a VERY STRICT tolerance here (e.g., 0, 1, or 2)
                    const effectiveCleanupThreshold = whiteThreshold - cleanupTolerance;
                    let cleanedPixelCount = 0;

                    console.log(`Starting Cleanup Pass. Strict Tolerance: ${cleanupTolerance}`);
                    for (let y = 1; y < height - 1; y++) { // Iterate excluding borders
                         for (let x = 1; x < width - 1; x++) {
                             const index = getIndex(x, y);
                             // Check if pixel is NOT already transparent from Pass 1
                             if (data[index + 3] > 0) {
                                 const r = data[index]; const g = data[index + 1]; const b = data[index + 2];
                                 // Check if it's VERY close to white
                                 if (r >= effectiveCleanupThreshold && g >= effectiveCleanupThreshold && b >= effectiveCleanupThreshold) {
                                     // Check its 4 direct neighbors
                                     let transparentNeighbors = 0;
                                     const neighborsIndices = [ getIndex(x+1, y), getIndex(x-1, y), getIndex(x, y+1), getIndex(x, y-1) ];
                                     for (const nIndex of neighborsIndices) {
                                         // Check if neighbor is within bounds and is transparent (alpha == 0)
                                         if (nIndex >= 0 && nIndex < data.length && data[nIndex + 3] === 0) {
                                             transparentNeighbors++;
                                         }
                                     }
                                     // If at least 3 out of 4 neighbors are transparent, consider it an isolated speck
                                     if (transparentNeighbors >= 3) {
                                         data[index + 3] = 0; // Make the speck transparent
                                         cleanedPixelCount++;
                                     }
                                 }
                             }
                         }
                    }
                    console.log(`Cleanup pass finished. ${cleanedPixelCount} isolated pixels made transparent.`);
                    // --- End Pass 2 ---

                    ctx.putImageData(imageData, 0, 0);
                    resolve(canvas.toDataURL('image/png'));
                } catch (error) {
                     // Error handling remains the same
                     if (error.name === 'SecurityError') { console.error("Canvas processing error (likely CORS)...", error); resolve(img.src);
                     } else { console.error("Canvas processing error in removeEdgeWhiteBackground:", error); resolve(img.src);
                     }
                }
            });
        }
        // --- Image Loading (Unchanged from previous version) ---
        async function loadDynamicImage(element, prompt, imageType = "background", nologo = true, seed = null) {
             if (!prompt || !element) { console.warn(`Skipping ${imageType} image: No prompt or element.`); if (imageType === 'character') { element.classList.add('hidden'); } return Promise.resolve(); }
             const baseCharacterPrompt = prompt; console.log(`Attempting to load ${imageType} image with base prompt: ${baseCharacterPrompt}`); let width = 768, height = 1024, extraParams = "", finalPromptString = '';
             if (imageType === 'character') {
                 width = 768; height = 1024; extraParams = "&nofeed=true";
                 finalPromptString = `${FIXED_STYLE_PROMPT}, ${SPRITE_BACKGROUND_KEYWORDS}, ${baseCharacterPrompt}`; console.log("Final Character Prompt:", finalPromptString);
                 if (spriteCache[finalPromptString]) { console.log(`Cache hit for character prompt: ${finalPromptString.substring(0, 100)}...`); element.src = spriteCache[finalPromptString]; element.classList.remove('hidden'); element.style.opacity = 1; return Promise.resolve(); }
                 element.classList.add('hidden');
             } else if (imageType === 'background') { finalPromptString = `${baseCharacterPrompt}, anime style, visual novel background, detailed illustration, high quality`; width = 1024; height = 1024; }
             const nologoValue = nologo ? 'true' : 'false'; let finalUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPromptString)}?width=${width}&height=${height}&model=flux&nologo=${nologoValue}${extraParams}`; finalUrl += `&seed=${Math.floor(Math.random()*1e7)}`; const url = finalUrl; console.log(`Loading ${imageType} image URL:`, url);
             return new Promise((resolve) => { const img = new Image(); img.crossOrigin = "Anonymous";
                 img.onload = async () => { console.log(`${imageType} image preloaded/loaded successfully.`); if (imageType === 'background') { element.style.backgroundImage = `url('${url}')`; console.log(`Background image set for element:`, element); resolve(); } else { try { console.log(`Attempting white background removal for ${element.id}...`); const processedUrl = await removeEdgeWhiteBackground(img); element.src = processedUrl; spriteCache[finalPromptString] = processedUrl; element.classList.remove('hidden'); element.style.opacity = 1; console.log(`White background removal finished for ${element.id}.`); } catch (error) { console.error(`Using original URL due to background removal error for ${element.id}:`, error); element.src = url; spriteCache[finalPromptString] = url; element.classList.remove('hidden'); element.style.opacity = 1; showGameError(`å¤„ç† ${element.alt} èƒŒæ™¯æ—¶å‡ºé”™ã€‚`); } finally { resolve(); } } };
                 img.onerror = (e) => { console.error(`Error loading ${imageType} image:`, e, url); showGameError(`${imageType === 'character' ? element.alt : 'èƒŒæ™¯'} åŠ è½½å¤±è´¥ã€‚`); if (imageType === 'character') { element.classList.add('hidden'); } resolve(); }; img.src = url;
             });
         }


        // --- LLM API Call (MODIFIED for Image Input) ---
        async function callLLMApi_Galgame(promptHistory) {
            console.log("callLLMApi_Galgame initiated.");
            if (!currentApiKey || !currentModel || !currentApiUrl) {
                showGameError("API é…ç½®ä¸å®Œæ•´ï¼è¯·æ£€æŸ¥è®¾ç½®ã€‚");
                const fallbackData = { scene_state: { background_prompt: "error config", visible_characters: [] }, dialogue_segments: [{ speaker: "ç³»ç»Ÿ", text: "API é…ç½®ä¸å®Œæ•´ï¼è¯·æ£€æŸ¥è®¾ç½®ã€‚", emotion: null }], choices: ["[å…³é—­]"] };
                // Ensure error is added to history if game started
                 if (isGameStarted && (!conversationHistory.length || !conversationHistory[conversationHistory.length - 1].isErrorFallback)) {
                    conversationHistory.push({ role: "model", parts: [{ text: JSON.stringify(fallbackData) }], isErrorFallback: true });
                 }
                return fallbackData;
            }
            clearGameError();
            let finalApiUrl = currentApiUrl.trim();
            let requestBody;
            let headers = { 'Content-Type': 'application/json' };
            const isFirstCall = promptHistory.length === 1 && promptHistory[0].isSetup;
            let userPromptText = isFirstCall ? promptHistory[0].parts[0].text : promptHistory[promptHistory.length - 1].parts[0].text;

            // --- System Instruction (Instructions against "same..." kept) ---
             const systemInstruction = `ä½ ç°åœ¨æ˜¯ä¸€ä¸ª Galgame (è§†è§‰å°è¯´) å¼•æ“ã€‚ä½ çš„ä»»åŠ¡æ˜¯ä¸ç©å®¶ (${playerName || 'ç©å®¶'}) äº’åŠ¨ï¼Œå¹¶ç”Ÿæˆæ¸¸æˆå†…å®¹ã€‚\nç©å®¶åŸºç¡€å¤–è²Œæç¤ºè¯(ç”±ä½ ç”Ÿæˆæˆ–å®Œå–„): ${playerBaseAppearancePrompt || '(å°šæœªç”Ÿæˆ)'}\nAIè§’è‰²åŸºç¡€å¤–è²Œæç¤ºè¯(ç”±ä½ ç”Ÿæˆæˆ–å®Œå–„): ${aiBaseAppearancePrompt || '(å°šæœªç”Ÿæˆ)'}\n${currentAiPersona ? `AI è§’è‰²è®¾å®š: ${currentAiPersona}\n` : ''}è¯·**ä¸¥æ ¼**æŒ‰ç…§ä»¥ä¸‹ JSON æ ¼å¼ç”Ÿæˆå“åº”ï¼Œä¸è¦åŒ…å«ä»»ä½•é¢å¤–çš„è§£é‡Šæˆ– Markdown æ ‡è®°åŒ…è£¹ JSON æœ¬èº«ï¼š\n\`\`\`json\n{\n  "scene_state": {\n    "background_prompt": "String (åœºæ™¯çš„è‹±æ–‡æè¿°, è¿™æ˜¯æ¸¸æˆèƒŒæ™¯å›¾, ä¸æ˜¯è§’è‰²ç«‹ç»˜èƒŒæ™¯!)",\n    "visible_characters": [\n      {\n        "character_id": "'player' or 'ai'",\n        "emotion": "String or Null (è§’è‰²ã€å½“å‰ã€‘çš„è¡¨æƒ…/åŠ¨ä½œ/ç»†å¾®å˜åŒ–, e.g., 'smiling slightly', 'surprised face', 'holding a pen', 'adjusting glasses')"\n      }\n      // ... å¯èƒ½åŒ…å« 'player' å’Œ/æˆ– 'ai'\n    ]\n  },\n  "dialogue_segments": [\n    {\n      "speaker": "String (AIè§’è‰²å, ${playerName ? "'" + playerName + "'" : "'ç©å®¶'"}, 'æ—ç™½', 'å†…å¿ƒæƒ³æ³•')",\n      "emotion": "String or Null (è¯´è¯è€…è¡¨æƒ…/åŠ¨ä½œ, å¯¹åº”æ­¤ã€å¯¹è¯ã€‘å†…å®¹)",\n      "text": "String (è¯¥ç‰‡æ®µçš„å¯¹è¯/æ—ç™½æ–‡æœ¬, æ”¯æŒMarkdown)"\n    }\n    // ... more segments\n  ],\n  "choices": [\n    "String (é€‰é¡¹1)", \n    "String (é€‰é¡¹2)"\n  ],\n  "initial_setup_details": { \n     // !!! è¿™ä¸ªå­—æ®µã€åªåœ¨ã€‘å“åº”ç¬¬ä¸€ä¸ªè®¾ç½®è¯·æ±‚æ—¶å‡ºç° !!!\n     // **è¦æ±‚ï¼šç”Ÿæˆã€ç®€è¦ä¸”è¿è´¯ã€‘ã€åŒ…å«å…·ä½“ç‰¹å¾(å‘å‹/å‘è‰²/ç³è‰²/èº«æ/è„¸å‹)å’Œã€å…·ä½“æœè£…ã€‘æè¿°çš„åŸºç¡€æç¤ºè¯ã€‚**ã€ç¦æ­¢ã€‘**åŒ…å« 'same character', 'same face', 'same style' ç­‰æ— æ•ˆè¯è¯­ã€‚**\n     "player_base_appearance_prompt": "String (ç”Ÿæˆã€ç®€è¦ã€è¿è´¯ã€‘çš„ç©å®¶åŸºç¡€å¤–è²Œè‹±æ–‡æç¤ºè¯, e.g., '1girl, teenage girl, medium height, slim build, long wavy bright pink hair tied in high twin tails with red ribbons, large sparkling emerald green eyes, fair skin, wearing a standard white short-sleeve sailor school uniform with navy blue collar and cuffs, red necktie, navy blue pleated skirt, white knee-high socks, brown loafers')",\n     "ai_base_appearance_prompt": "String (ç”Ÿæˆã€ç®€è¦ã€è¿è´¯ã€‘çš„AIè§’è‰²åŸºç¡€å¤–è²Œè‹±æ–‡æç¤ºè¯, åŒä¸Šè¦æ±‚)"\n  }\n}\n\`\`\`\n*   **scene_state**: æè¿°å½“å‰åœºæ™¯è§†è§‰çŠ¶æ€ã€‚\n    *   **background_prompt**: å½“å‰åœºæ™¯çš„ã€æ¸¸æˆèƒŒæ™¯å›¾ã€‘æç¤ºè¯ã€‚\n    *   **visible_characters**: æ•°ç»„åŒ…å«å½“å‰å±å¹•ä¸Šå¯è§çš„è§’è‰²ã€‚æ¯ä¸ªå¯¹è±¡æŒ‡å®š \`character_id\` ('player' æˆ– 'ai') å’Œ \`emotion\`ã€‚ \`emotion\` å¿…é¡»æ˜¯ã€æå…¶ç®€æ´åœ°æè¿°å½“å‰è¡¨æƒ…ã€åŠ¨ä½œæˆ–éå¸¸å°çš„ä¸´æ—¶ç‰©å“ã€‘ï¼Œä¾‹å¦‚ 'smiling', 'sad', 'surprised', 'holding a book', 'waving hand', 'blushing', 'looking down shyly'ã€‚**ã€ç»å¯¹ç¦æ­¢ã€‘** åœ¨ \`emotion\` å­—æ®µä¸­é‡æ–°æè¿°è§’è‰²çš„æ ¸å¿ƒç‰¹å¾ï¼ˆå¦‚å‘å‹ã€å‘è‰²ã€ç³è‰²ï¼‰ã€ä¸»è¦æœè£…æˆ–æ•´ä½“è‰ºæœ¯é£æ ¼ï¼Œä¹Ÿ**ã€ç»å¯¹ç¦æ­¢ã€‘**åŒ…å« 'same character/face/style/clothing' ç­‰è¯è¯­ã€‚å®¢æˆ·ç«¯ä¼šå¼ºåˆ¶åº”ç”¨ä¸€è‡´çš„æ—¥å¼äºŒæ¬¡å…ƒç”»é£å’Œçº¯ç™½èƒŒæ™¯ã€‚\n*   **dialogue_segments**: å¯¹è¯å†…å®¹æ•°ç»„ã€‚\n*   **choices**: ç©å®¶é€‰é¡¹æ•°ç»„ã€‚\n*   **initial_setup_details**: ã€åªåœ¨é¦–æ¬¡å“åº”æ—¶æä¾›ã€‘ï¼ŒåŒ…å«ä½ ç”Ÿæˆçš„ã€æå…¶è¯¦ç»†ã€è¿è´¯ä¸”ä¸å«æ— æ•ˆé‡å¤è¯ã€‘çš„åŸºç¡€å¤–è²Œæç¤ºè¯ã€‚\n*   **é£æ ¼å’Œç«‹ç»˜èƒŒæ™¯**: å®¢æˆ·ç«¯ä¼šå¼ºåˆ¶ä½¿ç”¨å›ºå®šçš„ã€æ—¥å¼äºŒæ¬¡å…ƒè§†è§‰å°è¯´ç«‹ç»˜é£æ ¼ã€‘å’Œã€çº¯ç™½èƒŒæ™¯ã€‘æ¥ç”Ÿæˆè§’è‰²ç«‹ç»˜ã€‚ä½ çš„ä»»åŠ¡æ˜¯æä¾›è¯¦ç»†çš„åŸºç¡€æè¿°å’Œç®€æ´çš„çŠ¶æ€å˜åŒ–ï¼Œå¹¶é¿å…æ— æ•ˆå…³é”®è¯ã€‚

è¿™æ˜¯ä¹‹å‰çš„å¯¹è¯å†å²ï¼ˆæœ€è¿‘å‡ æ¡ï¼‰ï¼š\n${JSON.stringify(promptHistory.slice(-6, -1).map(h => `${h.role === 'user' ? (playerName || 'ç©å®¶') : 'AI Response (Segments)'}: ${h.role === 'user' ? h.parts[0].text : '(...)'}`)).substring(0, 1000)}...\n\nç”¨æˆ·çš„æœ€æ–°è¾“å…¥/é€‰æ‹©æ˜¯: "${userPromptText}"\n\nè¯·ç”Ÿæˆ JSON æ ¼å¼çš„å“åº”ã€‚`;

            try {
                 // --- API Request Body Construction (Conditional based on Image & API type) ---
                 if (finalApiUrl.includes('generativelanguage.googleapis.com')) {
                     // Gemini API Structure
                     if (!finalApiUrl.includes('/v1beta/models')) { finalApiUrl = finalApiUrl.replace(/\/$/, '') + `/v1beta/models/${currentModel}:generateContent?key=${currentApiKey}`; }
                     else { finalApiUrl += `?key=${currentApiKey}`; } // Assumes URL already points to model

                     let geminiContents = [];
                      promptHistory.slice(0, isFirstCall ? -1 : undefined)
                          .slice(-7).forEach(h => {
                          const role = (h.role === 'model' ? 'model' : 'user');
                           if (geminiContents.length > 0 && geminiContents[geminiContents.length - 1].role === role) {
                               if (role === 'model') geminiContents.push({ role: 'user', parts: [{ text: "(Continue...)" }] });
                               else geminiContents.push({ role: 'model', parts: [{ text: "{}" }] });
                           }
                           geminiContents.push({ role: role, parts: [{ text: h.parts[0].text }] });
                       });

                     let currentUserParts = [];
                     if (isFirstCall) {
                         const playerData = getImageDataFromBase64(playerImageBase64);
                         if (playerData) { currentUserParts.push({ inline_data: { mime_type: playerData.mimeType, data: playerData.data } }); console.log("Adding player image to Gemini request"); }
                         const aiData = getImageDataFromBase64(aiImageBase64);
                         if (aiData) { currentUserParts.push({ inline_data: { mime_type: aiData.mimeType, data: aiData.data } }); console.log("Adding AI image to Gemini request"); }
                     }
                     currentUserParts.push({ text: userPromptText }); // Text prompt last for Gemini

                     if(geminiContents.length === 0 || geminiContents[geminiContents.length - 1].role === 'model') {
                        geminiContents.push({ role: 'user', parts: currentUserParts });
                     } else {
                        console.warn("Potentially non-alternating turn structure for Gemini.");
                        geminiContents.push({ role: 'user', parts: currentUserParts });
                     }

                     requestBody = JSON.stringify({ contents: geminiContents, generationConfig: { responseMimeType: "application/json" } });

                 } else if (finalApiUrl.includes('/v1')) {
                     // OpenAI Compatible API Structure
                     headers['Authorization'] = `Bearer ${currentApiKey}`;
                     if (!finalApiUrl.includes('/chat/completions')) { finalApiUrl = finalApiUrl.replace(/\/v1\/?$/, '') + '/v1/chat/completions'; }

                     let openAiMessages = [];
                     openAiMessages.push({ "role": "system", "content": systemInstruction });
                     promptHistory.slice(0, isFirstCall ? -1 : undefined)
                        .slice(-7).forEach(h => {
                            openAiMessages.push({ role: h.role === 'model' ? 'assistant' : 'user', content: h.parts[0].text });
                     });

                     let currentUserContent = [];
                     currentUserContent.push({ type: "text", text: userPromptText }); // Text first for OpenAI
                     if (isFirstCall) {
                         if (playerImageBase64) { currentUserContent.push({ type: "image_url", image_url: { url: playerImageBase64 } }); console.log("Adding player image to OpenAI request"); }
                         if (aiImageBase64) { currentUserContent.push({ type: "image_url", image_url: { url: aiImageBase64 } }); console.log("Adding AI image to OpenAI request"); }
                     }
                     openAiMessages.push({ role: "user", content: currentUserContent });

                     requestBody = JSON.stringify({ model: currentModel, messages: openAiMessages, max_tokens: 65536, response_format: { type: "json_object" } });

                 } else {
                     throw new Error("æ— æ³•è¯†åˆ«çš„ API åŸºç¡€åœ°å€æ ¼å¼ã€‚");
                 }


                 console.log("Calling Galgame LLM API:", finalApiUrl);
                 // Be cautious logging the request body if it contains large base64 images
                 // console.log("Request Body (structure):", JSON.stringify(JSON.parse(requestBody), (key, value) => key === 'data' || (key === 'image_url' && typeof value === 'object' && value.url?.startsWith('data:')) ? '<base64 data>' : value, 2));

                 const response = await fetch(finalApiUrl, { method: 'POST', headers, body: requestBody });
                 console.log("LLM API Response Status:", response.status);

                 // --- Enhanced Response Handling & Debugging ---
                 let data;
                 try {
                     data = await response.json();
                     // <<< Log the raw response immediately after parsing >>>
                     console.log("LLM API Raw Response Data:", JSON.stringify(data, null, 2));
                 } catch (jsonError) {
                      console.error("Failed to parse API response as JSON:", jsonError);
                      try {
                          const textResponse = await response.text();
                          console.error("API Raw Response Text:", textResponse);
                          throw new Error(`APIå“åº”ä¸æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼: ${textResponse.substring(0, 100)}...`);
                      } catch (textError) {
                           console.error("Failed to get text response either.");
                           throw new Error("APIå“åº”ä¸æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼ï¼Œä¸”æ— æ³•è¯»å–æ–‡æœ¬å†…å®¹ã€‚");
                      }
                 }
                 // --- End Enhanced Response Handling ---

                 // Check response.ok AFTER trying to parse JSON, as some APIs send errors in JSON with 200 OK
                 if (!response.ok) {
                     let errorMsg = `API è¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText}`;
                     if (data && data.error && data.error.message) { errorMsg += `\nDetails: ${data.error.message}`; }
                     else { errorMsg += `\nDetails: ${JSON.stringify(data)}`; } // Use already parsed data
                     throw new Error(errorMsg);
                 }

                 // --- Improved Content Extraction & Error Checking ---
                 let responseContent = null;
                 if (data && data.error && (data.error.message || data.error.code)) {
                     console.error("API returned an error object:", data.error);
                     throw new Error(`APIé”™è¯¯: ${data.error.message || `Code ${data.error.code}`}`);
                 }
                 else if (data.candidates?.[0]?.finishReason && data.candidates[0].finishReason !== "STOP") {
                     // Gemini: Check finishReason for safety blocks etc.
                     console.error("Gemini request finished with non-STOP reason:", data.candidates[0].finishReason, data.promptFeedback);
                      let reason = data.candidates[0].finishReason;
                      if (data.promptFeedback?.blockReason) {
                          reason += ` (Block Reason: ${data.promptFeedback.blockReason})`;
                      }
                      throw new Error(`è¯·æ±‚è¢«ç»ˆæ­¢: ${reason}`);
                 }
                 else if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
                     responseContent = data.candidates[0].content.parts[0].text;
                 }
                 else if (data.choices?.[0]?.finish_reason && data.choices[0].finish_reason !== "stop") {
                     // OpenAI: Check finish_reason
                     console.error("OpenAI request finished with non-stop reason:", data.choices[0].finish_reason);
                      throw new Error(`è¯·æ±‚è¢«ç»ˆæ­¢: ${data.choices[0].finish_reason}`);
                 }
                 else if (data.choices?.[0]?.message?.content) {
                     responseContent = data.choices[0].message.content;
                 }
                 else if (data.choices?.[0]?.error) {
                      console.error("API returned an error object within choices:", data.choices[0].error);
                      throw new Error(`APIé”™è¯¯: ${data.choices[0].error.message || JSON.stringify(data.choices[0].error)}`);
                 }
                 // No specific promptFeedback check here as Gemini's is covered by finishReason
                 else {
                     console.error("Could not find expected content path in API response.", data);
                     throw new Error("æ— æ³•ä» API å“åº”ä¸­æå–æœ‰æ•ˆå†…å®¹ã€‚"); // Keep original error message
                 }
                 // --- End Improved Content Extraction ---

                 console.log("Extracted Response Content (before parsing):", responseContent);

                 // --- JSON Parsing and Validation (Includes Fallback Return) ---
                 let parsedData;
                 try {
                     const cleanedText = responseContent.replace(/^```json\s*|```$/gs, '').trim();
                     if (!cleanedText) {
                         throw new Error("æå–åˆ°çš„å†…å®¹ä¸ºç©ºå­—ç¬¦ä¸²ã€‚");
                     }
                     parsedData = JSON.parse(cleanedText);

                     // Validation Logic (Keep as before)
                     if (!parsedData || typeof parsedData !== 'object') throw new Error("Parsed data is not an object.");
                     if (!parsedData.scene_state || typeof parsedData.scene_state !== 'object') throw new Error("Missing or invalid scene_state.");
                     if (typeof parsedData.scene_state.background_prompt !== 'string') throw new Error("Invalid background_prompt type.");
                     if (!Array.isArray(parsedData.scene_state.visible_characters)) throw new Error("Invalid visible_characters type.");
                     for(const charInfo of parsedData.scene_state.visible_characters) { if (typeof charInfo !== 'object' || charInfo === null) throw new Error("Invalid item in visible_characters array."); if (typeof charInfo.character_id !== 'string' || (charInfo.character_id !== 'player' && charInfo.character_id !== 'ai')) throw new Error("Invalid character_id in visible_characters."); if (typeof charInfo.emotion !== 'string' && charInfo.emotion !== null) throw new Error("Invalid emotion type in visible_characters."); }
                     if (!Array.isArray(parsedData.dialogue_segments)) throw new Error("Invalid dialogue_segments type.");
                     if (parsedData.dialogue_segments.length === 0) { console.warn("AI provided zero dialogue segments. Adding placeholder."); parsedData.dialogue_segments.push({speaker: "æ—ç™½", text:"(AIæœªè¿”å›å¯¹è¯å†…å®¹)", emotion: null}); } else { for(const segment of parsedData.dialogue_segments) { if (typeof segment !== 'object' || segment === null) throw new Error("Invalid item in dialogue_segments array."); if (typeof segment.speaker !== 'string') throw new Error("Invalid speaker type in dialogue_segments."); if (typeof segment.text !== 'string') throw new Error("Invalid text type in dialogue_segments."); segment.emotion = segment.emotion || null; } }
                     if (!Array.isArray(parsedData.choices)) throw new Error("Invalid choices type.");
                      if (parsedData.choices.length === 0) { console.warn("AI provided zero choices. Adding default."); parsedData.choices = ["[ç»§ç»­...]"]; } else { for(let i = 0; i < parsedData.choices.length; i++) { if (typeof parsedData.choices[i] !== 'string') throw new Error(`Invalid choice type at index ${i}.`); } }
                     if (isFirstCall) { if (!parsedData.initial_setup_details || typeof parsedData.initial_setup_details !== 'object') throw new Error("Initial setup response missing valid initial_setup_details object."); if (typeof parsedData.initial_setup_details.player_base_appearance_prompt !== 'string' || !parsedData.initial_setup_details.player_base_appearance_prompt.trim()) throw new Error("Initial setup missing valid player_base_appearance_prompt."); if (typeof parsedData.initial_setup_details.ai_base_appearance_prompt !== 'string' || !parsedData.initial_setup_details.ai_base_appearance_prompt.trim()) throw new Error("Initial setup missing valid ai_base_appearance_prompt."); console.log("Initial setup details received and validated."); }
                     else if (parsedData.initial_setup_details) { console.warn("AI incorrectly included initial_setup_details on a non-first turn. Ignoring it."); delete parsedData.initial_setup_details; }

                 } catch (parseError) {
                     console.error("Failed to parse or validate LLM JSON response:", parseError);
                     console.error("Received content that failed parsing:", responseContent); // Log the content that failed
                     const fallbackData = { scene_state: { background_prompt: "error background", visible_characters: [] }, dialogue_segments: [{ speaker: "ç³»ç»Ÿ", text: `æŠ±æ­‰ï¼Œè§£æAIå“åº”æ—¶å‡ºé”™ï¼š${parseError.message}`, emotion: null }], choices: ["[å°è¯•ç»§ç»­]"] };
                     if (!conversationHistory.length || !conversationHistory[conversationHistory.length - 1].isErrorFallback) { conversationHistory.push({ role: "model", parts: [{ text: JSON.stringify(fallbackData) }], isErrorFallback: true }); }
                     return fallbackData; // Return fallback data on parse error
                 }
                 // --- End JSON Parsing and Validation ---

                 // Only add to history if it wasn't an error handled above
                 conversationHistory.push({ role: "model", parts: [{ text: JSON.stringify(parsedData) }] });
                 return parsedData;

             } catch (error) { // Catch errors from fetch, response checks, or content extraction
                 console.error("è°ƒç”¨ Galgame LLM API è¿‡ç¨‹å‡ºé”™:", error); // More specific location
                 showGameError(error.message || "ä¸ AI çš„è¿æ¥ä¸­æ–­æˆ–å¤„ç†å“åº”å‡ºé”™ã€‚"); // More specific message
                 const fallbackData = { scene_state: { background_prompt: "error background", visible_characters: [] }, dialogue_segments: [{ speaker: "ç³»ç»Ÿ", text: `æŠ±æ­‰ï¼Œè¿æ¥æˆ–å¤„ç†AIå“åº”æ—¶å‡ºé”™ï¼š${error.message}`, emotion: null }], choices: ["[å°è¯•ç»§ç»­]"] };
                 // Avoid adding duplicate error messages if already added
                 if (!conversationHistory.length || !conversationHistory[conversationHistory.length - 1].isErrorFallback) {
                    conversationHistory.push({ role: "model", parts: [{ text: JSON.stringify(fallbackData) }], isErrorFallback: true });
                 }
                 return fallbackData; // Return fallback on general API errors
             }
        }


        // --- UI Update (Unchanged) ---
        function updateDialogueUI(parsedData) { console.log("Updating dialogue UI with parsed data:", parsedData); clearGameError(); currentDialogueSegments = parsedData.dialogue_segments || []; currentTurnChoices = parsedData.choices || []; currentSegmentIndex = 0; if (currentDialogueSegments.length > 0) { displayCurrentSegment(); if (currentDialogueSegments.length === 1) { processChoicesAndButtonState(); console.log("Single dialogue segment, processing choices."); } else { nextButton.style.display = 'block'; nextButton.disabled = false; choicesContainer.innerHTML = ''; console.log("Multi-segment dialogue. Next button enabled."); } } else { console.warn("Parsed data has no dialogue segments. Proceeding to choices."); dialogueText.innerHTML = ""; speakerName.textContent = "æ—ç™½"; processChoicesAndButtonState(); } setLoading(false); }
        function displayCurrentSegment() { if (!currentDialogueSegments || currentSegmentIndex >= currentDialogueSegments.length) { console.error("displayCurrentSegment called with invalid index or no segments."); processChoicesAndButtonState(); setLoading(false); return; } const segment = currentDialogueSegments[currentSegmentIndex]; console.log(`Displaying segment ${currentSegmentIndex + 1}/${currentDialogueSegments.length}:`, segment); speakerName.textContent = segment.speaker || "æœªçŸ¥"; try { const cleanHtml = typeof DOMPurify !== 'undefined' ? DOMPurify.sanitize(marked.parse(segment.text || "")) : marked.parse(segment.text || ""); dialogueText.innerHTML = cleanHtml; } catch (e) { console.error("Markdown parsing error for segment:", e); dialogueText.textContent = segment.text || ""; showGameError("å¯¹è¯ç‰‡æ®µæ ¼å¼è§£æå‡ºé”™ã€‚"); } dialogueBox.scrollTop = 0; choicesContainer.innerHTML = ''; nextButton.style.display = 'block'; const isLastSegment = currentSegmentIndex === currentDialogueSegments.length - 1; nextButton.disabled = isLastSegment; console.log(`Segment displayed. isLastSegment: ${isLastSegment}, nextButton disabled: ${nextButton.disabled}`); setLoading(false); }
        function processChoicesAndButtonState() { choicesContainer.innerHTML = ''; if (currentTurnChoices && currentTurnChoices.length > 0) { console.log("Processing final choices:", currentTurnChoices); nextButton.style.display = 'none'; currentTurnChoices.forEach((choiceText) => { const button = document.createElement('button'); button.classList.add('choice-button'); button.textContent = choiceText.replace(/^\[|\]$/g, ''); button.onclick = () => handleChoice_Galgame(choiceText); button.disabled = isLoading; choicesContainer.appendChild(button); }); nextButton.disabled = true; } else { console.error("No choices available to display. Game cannot proceed."); nextButton.style.display = 'block'; nextButton.disabled = true; showGameError("AI æœªæä¾›ä»»ä½•é€‰é¡¹ï¼Œæ•…äº‹æ— æ³•ç»§ç»­ã€‚"); } console.log("Choices processed and displayed."); setLoading(false); }


        // --- Game Flow Functions (startGame MODIFIED for new prompt logic) ---
        function startGame_Galgame() {
            console.log("startGame_Galgame called");
            if (!currentApiKey || !currentModel) { showGameError("è¯·å…ˆå®Œæˆå¹¶ä¿å­˜ API é…ç½®ï¼"); toggleConfigPanel(); return; }

            isGameStarted = true; nextButton.textContent = 'ç»§ç»­'; toggleHistoryBtn.disabled = false; conversationHistory = []; playerBaseAppearancePrompt = ''; aiBaseAppearancePrompt = ''; currentDialogueSegments = []; currentSegmentIndex = 0; currentTurnChoices = []; currentTurnParsedData = null; speakerName.textContent = 'æ—ç™½'; dialogueText.innerHTML = ''; spriteCache = {}; // Clear cache

             // --- Construct Initial Setup Prompt based on Image Uploads ---
            let initialSetupText = "=== æ¸¸æˆå¼€å§‹è®¾å®š ===\n";
            initialSetupText += `ç©å®¶åç§°: ${playerName || 'ç©å®¶'}\n`;

             // Player Setup Instruction
             if (playerImageBase64) {
                 initialSetupText += `ä»»åŠ¡1: æ ¹æ®ã€ç¬¬ä¸€å¼ ã€‘æä¾›çš„ç©å®¶å›¾ç‰‡ï¼Œç”Ÿæˆä¸€ä¸ªã€æå…¶è¯¦ç»†ä¸”è¿è´¯ã€‘çš„ç©å®¶ã€åŸºç¡€å¤–è²Œè‹±æ–‡æç¤ºè¯ã€‘(åŒ…æ‹¬å›¾ç‰‡ä¸­å¯è§çš„æ€§åˆ«ã€ä½“å‹ã€å‘å‹/è‰²ã€ç³è‰²ã€è„¸å‹ã€å…·ä½“æœè£…ç­‰)ã€‚ã€ç¦æ­¢ã€‘åŒ…å« 'same character/face/style' ç­‰æ— æ•ˆè¯è¯­ã€‚\n`;
             } else if (playerPersona) {
                 initialSetupText += `ç©å®¶è§’è‰²ç®€ä»‹: ${playerPersona}\n`;
                 initialSetupText += `ä»»åŠ¡1: åŸºäºç©å®¶ç®€ä»‹ï¼Œç”Ÿæˆä¸€ä¸ªã€æå…¶è¯¦ç»†ä¸”è¿è´¯ã€‘çš„ç©å®¶ã€åŸºç¡€å¤–è²Œè‹±æ–‡æç¤ºè¯ã€‘ (åŒ…æ‹¬æ€§åˆ«ã€å¤§è‡´èº«é«˜/ä½“å‹ã€å‘å‹ã€å‘è‰²ã€ç³è‰²ã€è„¸å‹ã€å…·ä½“æœè£…ç­‰)ã€‚å¦‚æœç®€ä»‹ä¸­ç¼ºå°‘ç»†èŠ‚ï¼Œè¯·åˆç†è¡¥å……ã€‚ã€ç¦æ­¢ã€‘åŒ…å« 'same character/face/style' ç­‰æ— æ•ˆè¯è¯­ã€‚\n`;
             } else {
                 initialSetupText += `ç©å®¶è§’è‰²ç®€ä»‹: (æ— ï¼Œç”±ä½ åˆ›é€ )\n`;
                 initialSetupText += `ä»»åŠ¡1: åˆ›é€ ä¸€ä¸ªåˆé€‚çš„ç©å®¶è§’è‰²ï¼Œå¹¶ç”Ÿæˆä¸€ä¸ªã€æå…¶è¯¦ç»†ä¸”è¿è´¯ã€‘çš„ç©å®¶ã€åŸºç¡€å¤–è²Œè‹±æ–‡æç¤ºè¯ã€‘ (åŒ…æ‹¬æ€§åˆ«ã€å¤§è‡´èº«é«˜/ä½“å‹ã€å‘å‹ã€å‘è‰²ã€ç³è‰²ã€è„¸å‹ã€å…·ä½“æœè£…ç­‰)ã€‚ã€ç¦æ­¢ã€‘åŒ…å« 'same character/face/style' ç­‰æ— æ•ˆè¯è¯­ã€‚\n`;
             }

             // AI Setup Instruction
             if (aiImageBase64) {
                 const imageIndexText = playerImageBase64 ? "ã€ç¬¬äºŒå¼ ã€‘" : "ã€ç¬¬ä¸€å¼ ã€‘"; // Adjust index based on player image presence
                 initialSetupText += `ä»»åŠ¡2: æ ¹æ®${imageIndexText}æä¾›çš„AIè§’è‰²å›¾ç‰‡ï¼Œç”Ÿæˆä¸€ä¸ªã€æå…¶è¯¦ç»†ä¸”è¿è´¯ã€‘çš„AIè§’è‰²ã€åŸºç¡€å¤–è²Œè‹±æ–‡æç¤ºè¯ã€‘(åŒä¸Šè¦æ±‚)ã€‚ã€ç¦æ­¢ã€‘åŒ…å« 'same character/face/style' ç­‰æ— æ•ˆè¯è¯­ã€‚\n`;
             } else if (currentAiPersona) {
                 initialSetupText += `AIå¯¹æ‰‹è§’è‰²è®¾å®š: ${currentAiPersona}\n`;
                 initialSetupText += `ä»»åŠ¡2: åŸºäºAIè§’è‰²è®¾å®šï¼Œç”Ÿæˆä¸€ä¸ªã€æå…¶è¯¦ç»†ä¸”è¿è´¯ã€‘çš„AIè§’è‰²ã€åŸºç¡€å¤–è²Œè‹±æ–‡æç¤ºè¯ã€‘ã€‚ã€ç¦æ­¢ã€‘åŒ…å« 'same character/face/style' ç­‰æ— æ•ˆè¯è¯­ã€‚\n`;
             } else {
                 initialSetupText += `AIå¯¹æ‰‹è§’è‰²è®¾å®š: (æ— ï¼Œç”±ä½ åˆ›é€ )\n`;
                 initialSetupText += `ä»»åŠ¡2: åˆ›é€ ä¸€ä¸ªåˆé€‚çš„AIå¯¹æ‰‹è§’è‰²ï¼Œå¹¶ç”Ÿæˆä¸€ä¸ªã€æå…¶è¯¦ç»†ä¸”è¿è´¯ã€‘çš„AIè§’è‰²ã€åŸºç¡€å¤–è²Œè‹±æ–‡æç¤ºè¯ã€‘ã€‚ã€ç¦æ­¢ã€‘åŒ…å« 'same character/face/style' ç­‰æ— æ•ˆè¯è¯­ã€‚\n`;
             }

            initialSetupText += `æœŸæœ›å¼€å±€: ${playerStart || 'ä¸€ä¸ªæœ‰è¶£æˆ–å¸¸è§çš„æ—¥å¸¸åœºæ™¯ã€‚'}\n`;
            initialSetupText += `æ¸¸æˆç±»å‹: äº’åŠ¨æ•…äº‹ (ä¸é™äºç‰¹å®šç±»å‹)\n`;
            initialSetupText += "=== ä»»åŠ¡3 (ç”Ÿæˆé¦–æ¬¡å“åº”) ===\n";
            initialSetupText += `è¯·ç”Ÿæˆæ¸¸æˆçš„å¼€åœºç™½ã€åœºæ™¯æè¿°å’Œç¬¬ä¸€ä¸ªå¯¹è¯ç‰‡æ®µã€‚è¯·ç¡®ä¿ã€é¦–æ¬¡å“åº”ã€‘çš„JSONåŒ…å«ä»¥ä¸‹å†…å®¹ï¼š\n`;
            initialSetupText += `1.  \`initial_setup_details\` å¯¹è±¡ï¼Œå†…å«ç”Ÿæˆçš„ \`player_base_appearance_prompt\` å’Œ \`ai_base_appearance_prompt\`ã€‚\n`;
            initialSetupText += `2.  \`scene_state\` å¯¹è±¡ï¼ŒåŒ…å« \`background_prompt\` å’Œ \`visible_characters\` æ•°ç»„ã€‚\n`;
            initialSetupText += `3.  \`dialogue_segments\` æ•°ç»„ã€‚\n`;
            initialSetupText += `4.  \`choices\` æ•°ç»„ã€‚\n`;
            initialSetupText += "è¯·ä¸¥æ ¼ä½¿ç”¨å‰é¢æè¿°çš„æ–°JSONæ ¼å¼è¾“å‡ºã€‚\n";
            initialSetupText += "=====================\n";

            console.log("Initial Setup Text Prompt:", initialSetupText);
            // The actual API request construction (including images) happens in callLLMApi_Galgame
            conversationHistory.push({ role: 'user', parts: [{ text: initialSetupText }], isSetup: true });
            proceedStory_Galgame();
        }

        async function proceedStory_Galgame(userChoice = null) {
            if (userChoice) { console.log("proceedStory_Galgame called with choice:", userChoice); }
            else { console.log("proceedStory_Galgame called for initial setup or next segment"); }

            setLoading(true);
            clearGameError();
            currentTurnParsedData = null;

            // --- FIX: Hide both sprites unconditionally at the start ---
            aiCharacterSprite.classList.add('hidden');
            playerCharacterSprite.classList.add('hidden');
            console.log("Sprites hidden at start of proceedStory");
            // --- END FIX ---

            try {
                const parsedData = await callLLMApi_Galgame(conversationHistory);
                currentTurnParsedData = parsedData;

                if (parsedData.initial_setup_details) {
                    console.log("--- æ”¶åˆ° Initial Setup Details ---"); // <<< è°ƒè¯•ç‚¹ 1
                    playerBaseAppearancePrompt = parsedData.initial_setup_details.player_base_appearance_prompt || '';
                    aiBaseAppearancePrompt = parsedData.initial_setup_details.ai_base_appearance_prompt || '';
                    console.log("å­˜å‚¨ Player Base Prompt:", playerBaseAppearancePrompt); // <<< è°ƒè¯•ç‚¹ 2
                    console.log("å­˜å‚¨ AI Base Prompt:", aiBaseAppearancePrompt); // <<< è°ƒè¯•ç‚¹ 3
                     // Clear images after using them for initial prompt generation
                     if (playerImageBase64) {
                         console.log("Clearing player image data after initial setup.");
                         clearImageUpload(playerImageUpload, playerImagePreview, clearPlayerImageBtn, (val) => playerImageBase64 = val);
                     }
                     if (aiImageBase64) {
                         console.log("Clearing AI image data after initial setup.");
                         clearImageUpload(aiImageUpload, aiImagePreview, clearAiImageBtn, (val) => aiImageBase64 = val);
                     }
                }

                updateDialogueUI(parsedData); // Display dialogue

                const imagePromises = [];
                const sceneState = parsedData.scene_state || {};
                let playerShouldBeVisible = false; // Reset visibility flags
                let aiShouldBeVisible = false;

                // Load background image
                imagePromises.push(loadDynamicImage(gameBackground, sceneState.background_prompt || "default anime background", 'background'));

                // Determine which characters should be visible and prepare their prompts
                const visibleCharacters = sceneState.visible_characters || [];
                console.log("--- å¼€å§‹å¤„ç† Visible Characters ---"); // <<< è°ƒè¯•ç‚¹ 4
                console.log("å½“å‰ Player Base Prompt:", playerBaseAppearancePrompt); // <<< è°ƒè¯•ç‚¹ 5
                console.log("å½“å‰ AI Base Prompt:", aiBaseAppearancePrompt); // <<< è°ƒè¯•ç‚¹ 6
                console.log("ä» API æ”¶åˆ°çš„ Visible Characters:", JSON.stringify(visibleCharacters)); // <<< è°ƒè¯•ç‚¹ 7

                visibleCharacters.forEach(charInfo => {
                    let basePrompt = ''; let imgElement = null; let altText = '';

                    if (charInfo.character_id === 'player' && playerBaseAppearancePrompt) { // æ£€æŸ¥è¿™é‡Œ
                        console.log("åŒ¹é…åˆ° Playerï¼Œå‡†å¤‡è®¾ç½®å¯è§"); // <<< è°ƒè¯•ç‚¹ 8
                        basePrompt = playerBaseAppearancePrompt;
                        imgElement = playerCharacterSprite;
                        altText = playerName || "ç©å®¶è§’è‰²";
                        playerShouldBeVisible = true;
                        console.log("playerShouldBeVisible å·²è®¾ä¸º:", playerShouldBeVisible); // <<< è°ƒè¯•ç‚¹ 9
                    } else if (charInfo.character_id === 'ai' && aiBaseAppearancePrompt) { // æ£€æŸ¥è¿™é‡Œ
                        console.log("åŒ¹é…åˆ° AIï¼Œå‡†å¤‡è®¾ç½®å¯è§"); // <<< è°ƒè¯•ç‚¹ 10
                        basePrompt = aiBaseAppearancePrompt;
                        imgElement = aiCharacterSprite;
                        const aiNameMatch = currentAiPersona.match(/\[([^\]]+)\]/);
                        altText = aiNameMatch ? aiNameMatch[1] : "AIè§’è‰²";
                        aiShouldBeVisible = true;
                         console.log("aiShouldBeVisible å·²è®¾ä¸º:", aiShouldBeVisible); // <<< è°ƒè¯•ç‚¹ 11
                    }

                    if (imgElement && basePrompt) {
                        let characterDetails = basePrompt;
                        if (charInfo.emotion && typeof charInfo.emotion === 'string' && charInfo.emotion.trim() !== "") {
                            characterDetails += `, ${charInfo.emotion.trim()}`;
                        }
                        imgElement.alt = altText;
                        imagePromises.push(loadDynamicImage(imgElement, characterDetails, 'character'));
                    } else {
                         console.warn(`æ— æ³•åŠ è½½è§’è‰² '${charInfo.character_id}' çš„å›¾ç‰‡ã€‚æ˜¯å¦æœ‰ Element: ${!!imgElement}, æ˜¯å¦æœ‰ Base Prompt: ${!!basePrompt}`); // <<< è°ƒè¯•ç‚¹ 12
                    }
                });

                console.log("--- Visible Characters å¤„ç†å®Œæ¯• ---"); // <<< è°ƒè¯•ç‚¹ 13
                console.log("ç­‰å¾…å›¾ç‰‡åŠ è½½..."); // <<< è°ƒè¯•ç‚¹ 14
                await Promise.allSettled(imagePromises); // Wait for all attempts
                console.log("å›¾ç‰‡åŠ è½½å®Œæˆã€‚"); // <<< è°ƒè¯•ç‚¹ 15


                console.log("--- æœ€ç»ˆå¯è§æ€§æ£€æŸ¥ ---"); // <<< è°ƒè¯•ç‚¹ 16
                console.log("playerShouldBeVisible:", playerShouldBeVisible); // <<< è°ƒè¯•ç‚¹ 17
                console.log("aiShouldBeVisible:", aiShouldBeVisible); // <<< è°ƒè¯•ç‚¹ 18

                // --- Simplified Visibility Logic ---
                // Only REMOVE 'hidden' if the character should be visible.
                if (playerShouldBeVisible) {
                    playerCharacterSprite.classList.remove('hidden');
                    playerCharacterSprite.style.opacity = 1; // Ensure opacity is set if unhidden
                    console.log("Player sprite SHOULD be visible - unhiding.");
                } else {
                     console.log("Player sprite should NOT be visible - keeping hidden.");
                }

                if (aiShouldBeVisible) {
                    aiCharacterSprite.classList.remove('hidden');
                     aiCharacterSprite.style.opacity = 1; // Ensure opacity is set if unhidden
                    console.log("AI sprite SHOULD be visible - unhiding.");
                } else {
                     console.log("AI sprite should NOT be visible - keeping hidden.");
                }
                // --- END Simplified Visibility Logic ---

            } catch (error) {
                console.error("Error proceeding Galgame story:", error);
                showGameError(`å¤„ç†æ•…äº‹æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`);
                // Ensure sprites remain hidden on error
                aiCharacterSprite.classList.add('hidden');
                playerCharacterSprite.classList.add('hidden');
                setLoading(false); // Ensure loading stops on unexpected errors
            }
        }

        // --- handleNext_Galgame, handleChoice_Galgame (Unchanged) ---
        function handleNext_Galgame() { console.log("handleNext_Galgame called."); if (isLoading || !isGameStarted) return; if (currentDialogueSegments && currentSegmentIndex < currentDialogueSegments.length - 1) { currentSegmentIndex++; setLoading(true); displayCurrentSegment(); if (currentSegmentIndex === currentDialogueSegments.length - 1) { console.log("Last segment reached via Next, processing choices."); processChoicesAndButtonState(); } } else { console.warn("handleNext_Galgame called unexpectedly."); nextButton.disabled = true; setLoading(false); } }
        function handleChoice_Galgame(choiceText) { console.log("handleChoice_Galgame called with:", choiceText, "isLoading:", isLoading); if (isLoading) return; console.log("Galgame User chose:", choiceText); choicesContainer.querySelectorAll('button').forEach(btn => btn.disabled = true); conversationHistory.push({ role: 'user', parts: [{ text: choiceText }], isSetup: false }); currentDialogueSegments = []; currentSegmentIndex = 0; currentTurnChoices = []; currentTurnParsedData = null; console.log(">>> About to call proceedStory_Galgame from handleChoice"); proceedStory_Galgame(); console.log("<<< Call to proceedStory_Galgame finished (in handleChoice_Galgame)"); }

        // --- Event Listeners (MODIFIED for Image Uploads) ---
        document.addEventListener('DOMContentLoaded', () => {
             console.log("DOM Content Loaded. Attaching listeners.");
             loadConfig(); // Load text config, images reset

             // Config panel listeners
             if (toggleConfigBtn) toggleConfigBtn.addEventListener('click', toggleConfigPanel);
             if (closeConfigBtn) closeConfigBtn.addEventListener('click', toggleConfigPanel);
             if (saveConfigBtn) { saveConfigBtn.addEventListener('click', () => { saveConfig(); configPanel.classList.remove('visible'); console.log("Config panel closed via Save button."); }); }

             // API listeners
             if (fetchModelsBtn) fetchModelsBtn.addEventListener('click', fetchLLMModels);
             const testKeyButtonElement = document.getElementById('test-key-btn');
             if (testKeyButtonElement) { testKeyButtonElement.addEventListener('click', testApiKey); }
             if (toggleApiKeyVisibilityBtn && apiKeyInput) { toggleApiKeyVisibilityBtn.addEventListener('click', () => { const isP = apiKeyInput.type === 'password'; apiKeyInput.type = isP ? 'text':'password'; toggleApiKeyVisibilityBtn.textContent = isP ? 'ğŸ‘ï¸â€ğŸ—¨ï¸':'ğŸ‘ï¸'; }); }

             // Config input listeners (saving state, but not images)
             if(modelSelect) modelSelect.addEventListener('change', saveConfig);
             if(aiPersonaInput) aiPersonaInput.addEventListener('input', saveConfig);
             if(apiKeyInput) apiKeyInput.addEventListener('input', saveConfig);
             if(apiUrlInput) apiUrlInput.addEventListener('input', saveConfig);
             if(playerNameInput) playerNameInput.addEventListener('input', saveConfig);
             if(playerPersonaInput) playerPersonaInput.addEventListener('input', saveConfig);
             if(playerStartInput) playerStartInput.addEventListener('input', saveConfig);

             // --- Image Upload Listeners ---
             if (playerImageUpload && playerImagePreview && clearPlayerImageBtn) {
                 playerImageUpload.addEventListener('change', () => handleImageUpload(playerImageUpload, playerImagePreview, clearPlayerImageBtn, (val) => playerImageBase64 = val));
                 clearPlayerImageBtn.addEventListener('click', () => clearImageUpload(playerImageUpload, playerImagePreview, clearPlayerImageBtn, (val) => playerImageBase64 = val));
             }
              if (aiImageUpload && aiImagePreview && clearAiImageBtn) {
                 aiImageUpload.addEventListener('change', () => handleImageUpload(aiImageUpload, aiImagePreview, clearAiImageBtn, (val) => aiImageBase64 = val));
                 clearAiImageBtn.addEventListener('click', () => clearImageUpload(aiImageUpload, aiImagePreview, clearAiImageBtn, (val) => aiImageBase64 = val));
             }
             // --- End Image Upload Listeners ---

             // Game control listeners
             if (nextButton) { nextButton.addEventListener('click', () => { if (!isGameStarted) { startGame_Galgame(); } else { handleNext_Galgame(); } }); }
             if (toggleHistoryBtn) toggleHistoryBtn.addEventListener('click', toggleHistoryPanel);
             if (closeHistoryBtn) closeHistoryBtn.addEventListener('click', toggleHistoryPanel);

             console.log("All listeners attached.");
        });

    </script>
    </body>
    </html>