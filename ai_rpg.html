<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üíñ AI Galgame | üå∏ ÊàëÁöÑ‰∫åÊ¨°ÂÖÉÂ∞èÁ™ù üå∏</title>
    <link rel="stylesheet" href="css/style.css"> <!-- Link to main style -->
    <!-- Marked.js for Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- DOMPurify for security -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.10/purify.min.js"></script>

    <style>
        /* --- Galgame Specific Styles --- */
        :root {
            /* Base Theme Colors (Can be overridden by themes) */
            --galgame-container-shadow: rgba(0, 0, 0, 0.2);
            --content-bg: #f0f8ff; /* AliceBlue fallback */
            --galgame-dialogue-bg: rgba(0, 0, 0, 0.65);
            --galgame-dialogue-backdrop-filter: blur(5px);
            --galgame-dialogue-border: rgba(255, 255, 255, 0.2);
            --galgame-dialogue-text-color: #ffffff;
            --galgame-speaker-name-color: #ffb6c1; /* LightPink */
            --galgame-scrollbar-track-bg: rgba(0, 0, 0, 0.1);
            --galgame-scrollbar-thumb-bg: rgba(255, 255, 255, 0.3);
            --galgame-scrollbar-thumb-hover-bg: rgba(255, 255, 255, 0.5);
            --galgame-control-btn-bg: rgba(255, 182, 193, 0.8); /* LightPink with alpha */
            --galgame-control-btn-color: #333;
            --galgame-control-btn-border: rgba(255, 255, 255, 0.3);
            --galgame-control-btn-hover-bg: rgba(255, 192, 203, 0.95); /* Pink */
            --galgame-history-btn-bg: rgba(173, 216, 230, 0.8); /* LightBlue */
            --galgame-history-btn-color: #333;
            --galgame-history-btn-hover-bg: rgba(135, 206, 250, 0.95); /* LightSkyBlue */
            --galgame-choice-btn-bg: rgba(255, 255, 255, 0.15);
            --galgame-choice-btn-color: #ffffff;
            --galgame-choice-btn-border: rgba(255, 255, 255, 0.3);
            --galgame-choice-btn-hover-bg: rgba(255, 255, 255, 0.3);
            --galgame-config-bg: rgba(240, 248, 255, 0.9); /* AliceBlue */
            --galgame-config-backdrop-filter: blur(8px);
            --galgame-config-border: rgba(0, 0, 0, 0.1);
            --galgame-config-text-color: #333;
            --galgame-config-label-color: #555;
            --galgame-config-input-bg: rgba(255, 255, 255, 0.7);
            --galgame-config-input-border: rgba(0, 0, 0, 0.2);
            --galgame-config-link-color: #ff69b4; /* HotPink */
            --galgame-save-btn-bg: #4CAF50; /* Green */
            --galgame-save-btn-hover-bg: #45a049;
            --galgame-close-btn-bg: #f44336; /* Red */
            --galgame-close-btn-hover-bg: #da190b;
            --galgame-loading-bg: rgba(0, 0, 0, 0.7);
            --galgame-loading-text-color: #ffffff;
            --galgame-error-bg: #ffdddd; /* Light red */
            --galgame-error-text-color: #d8000c; /* Dark red */
            --galgame-history-panel-bg: rgba(0, 0, 0, 0.85);
            --galgame-history-panel-backdrop-filter: blur(10px);
            --galgame-history-panel-border: rgba(255, 255, 255, 0.2);
            --galgame-history-panel-text-color: #e0e0e0;
            --galgame-history-panel-title-color: #ffb6c1; /* LightPink */
            --galgame-history-scrollbar-track-bg: rgba(255, 255, 255, 0.05);
            --galgame-history-scrollbar-thumb-bg: rgba(255, 255, 255, 0.2);
            --galgame-history-scrollbar-thumb-hover-bg: rgba(255, 255, 255, 0.4);
            --galgame-history-role-user-color: #add8e6; /* LightBlue */
            --galgame-history-role-model-color: #90ee90; /* LightGreen */
            --galgame-history-close-btn-bg: #6c757d; /* Gray */
            --galgame-history-close-btn-hover-bg: #5a6268;
        }

        body.theme-dark {
            --galgame-container-shadow: rgba(255, 192, 203, 0.15); /* Pink shadow */
            --content-bg: #1a1a2e; /* Dark blue fallback */
            --galgame-dialogue-bg: rgba(26, 26, 46, 0.8); /* Dark blue slightly transparent */
            --galgame-dialogue-backdrop-filter: blur(6px);
            --galgame-dialogue-border: rgba(255, 192, 203, 0.3); /* Pink border */
            --galgame-dialogue-text-color: #e0e0e0;
            --galgame-speaker-name-color: #f8c8dc; /* Lighter Pink */
            --galgame-scrollbar-track-bg: rgba(255, 255, 255, 0.05);
            --galgame-scrollbar-thumb-bg: rgba(255, 192, 203, 0.3); /* Pink thumb */
            --galgame-scrollbar-thumb-hover-bg: rgba(255, 192, 203, 0.5);
            --galgame-control-btn-bg: rgba(230, 60, 120, 0.7); /* Darker pink/magenta */
            --galgame-control-btn-color: #ffffff;
            --galgame-control-btn-border: rgba(255, 192, 203, 0.4);
            --galgame-control-btn-hover-bg: rgba(255, 80, 140, 0.9);
            --galgame-history-btn-bg: rgba(70, 70, 110, 0.7); /* Dark purple/blue */
            --galgame-history-btn-color: #ffffff;
            --galgame-history-btn-hover-bg: rgba(90, 90, 130, 0.9);
            --galgame-choice-btn-bg: rgba(0, 0, 0, 0.2);
            --galgame-choice-btn-color: #e0e0e0;
            --galgame-choice-btn-border: rgba(255, 192, 203, 0.4); /* Pink border */
            --galgame-choice-btn-hover-bg: rgba(255, 192, 203, 0.2); /* Pinkish hover */
            --galgame-config-bg: rgba(20, 20, 35, 0.95); /* Very dark blue */
            --galgame-config-backdrop-filter: blur(10px);
            --galgame-config-border: rgba(255, 192, 203, 0.2); /* Pink border */
            --galgame-config-text-color: #e0e0e0;
            --galgame-config-label-color: #aaa;
            --galgame-config-input-bg: rgba(0, 0, 0, 0.3);
            --galgame-config-input-border: rgba(255, 192, 203, 0.3);
            --galgame-config-link-color: #f8c8dc; /* Lighter Pink */
            --galgame-save-btn-bg: #008080; /* Teal */
            --galgame-save-btn-hover-bg: #006666;
            --galgame-close-btn-bg: #b22222; /* Firebrick */
            --galgame-close-btn-hover-bg: #8b0000; /* DarkRed */
            --galgame-loading-bg: rgba(0, 0, 0, 0.8);
            --galgame-loading-text-color: #f8c8dc;
            --galgame-error-bg: #5e1e1e; /* Dark red */
            --galgame-error-text-color: #ffcccc; /* Light pinkish */
            --galgame-history-panel-bg: rgba(15, 15, 25, 0.9);
            --galgame-history-panel-backdrop-filter: blur(12px);
            --galgame-history-panel-border: rgba(255, 192, 203, 0.2);
            --galgame-history-panel-text-color: #cccccc;
            --galgame-history-panel-title-color: #f8c8dc;
            --galgame-history-scrollbar-track-bg: rgba(255, 255, 255, 0.03);
            --galgame-history-scrollbar-thumb-bg: rgba(255, 192, 203, 0.2);
            --galgame-history-scrollbar-thumb-hover-bg: rgba(255, 192, 203, 0.4);
            --galgame-history-role-user-color: #aec6cf; /* Pastel blue */
            --galgame-history-role-model-color: #b3e6b3; /* Pastel green */
            --galgame-history-close-btn-bg: #444; /* Dark gray */
            --galgame-history-close-btn-hover-bg: #555;
        }


        /* Config Panel Enhancements for Image Upload */
        #config-panel {
            /* ... (keep existing styles) ... */
            max-height: 90vh; /* Allow more height for images */
            scrollbar-width: thin;
            scrollbar-color: var(--galgame-scrollbar-thumb-bg) var(--galgame-scrollbar-track-bg);
        }
        #config-panel::-webkit-scrollbar { width: 6px; }
        #config-panel::-webkit-scrollbar-track { background: var(--galgame-scrollbar-track-bg); border-radius: 3px;}
        #config-panel::-webkit-scrollbar-thumb { background-color: var(--galgame-scrollbar-thumb-bg); border-radius: 3px; }
        #config-panel::-webkit-scrollbar-thumb:hover { background-color: var(--galgame-scrollbar-thumb-hover-bg); }

         .image-upload-section {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
            border: 1px solid var(--galgame-config-input-border);
            padding: 10px;
            border-radius: 5px;
            background: rgba(0,0,0,0.1);
         }
         body.theme-dark .image-upload-section { background: rgba(255,255,255,0.05); }

         .image-upload-section input[type="file"] {
            /* Basic file input styling override */
            padding: 5px; /* Smaller padding */
            font-size: 0.9em;
            background: rgba(255,255,255,0.1);
            border: 1px dashed var(--galgame-config-input-border);
            flex-grow: 1; /* Allow input to take space */
            cursor: pointer;
            color: var(--galgame-config-label-color);
         }
         body.theme-dark .image-upload-section input[type="file"] { background: rgba(0,0,0,0.2); }

        /* Hide default file input text */
         .image-upload-section input[type="file"]::file-selector-button {
            padding: 6px 10px;
            border: none;
            background-color: var(--galgame-control-btn-bg);
            color: var(--galgame-control-btn-color);
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            font-size: 0.9em;
            transition: background-color 0.2s ease;
         }
         .image-upload-section input[type="file"]::file-selector-button:hover {
            background-color: var(--galgame-control-btn-hover-bg);
         }


         .image-preview-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
         }

         .image-preview {
            max-width: 80px;
            max-height: 80px;
            height: auto;
            width: auto;
            border-radius: 4px;
            border: 1px solid var(--galgame-config-input-border);
            object-fit: cover;
            display: none; /* Hidden by default */
         }
         .clear-image-btn {
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 3px 8px;
            font-size: 0.8em;
            cursor: pointer;
            display: none; /* Hidden by default */
         }
         .clear-image-btn:hover { background: #5a6268; }

        /* --- End Image Upload Styles --- */


        /* Main container */
        #galgame-container {
            position: relative;
            width: 100%;
            height: calc(100vh - 100px); /* Example: Full viewport height minus approximate header/footer */
            min-height: 500px; /* Minimum height */
            overflow: hidden;
            border-radius: 15px;
            box-shadow: 0 5px 20px var(--galgame-container-shadow, rgba(0,0,0,0.2));
            margin-top: 20px;
        }

        /* Background Image */
        #game-background {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--content-bg); /* Fallback color */
            background-size: cover; background-position: center; z-index: 1;
            transition: background-image 0.8s ease-in-out; /* Smoother transition */
            background-image: url('https://image.pollinations.ai/prompt/beautiful%20anime%20classroom%20background,%20large%20windows,%20sunlight%20streaming%20in,%20empty,%20detailed,%20peaceful%20atmosphere?width=1024&height=576&seed=101&nologo=true');
        }

        /* --- Character Sprite Areas --- */
        .character-area {
            position: absolute;
            bottom: 5%;
            height: 65%;
            width: auto; /* Allow width to adjust based on height */
            max-width: 40%; /* Limit width slightly more to fit two */
            z-index: 3;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out, transform 0.4s ease; /* Added transform */
        }

        /* AI Character (Right Side) */
        #ai-character-area {
            right: 5%; /* Position on the right */
            transform: none; /* Remove horizontal centering */
        }

        /* Player Character (Left Side) */
        #player-character-area {
            left: 5%; /* Position on the left */
            transform: none; /* Remove horizontal centering */
        }

        .character-sprite {
            display: block;
            max-height: 100%;
            max-width: 100%;
            height: auto;
            width: auto;
            object-fit: contain;
            filter: drop-shadow(3px 5px 8px rgba(0,0,0,0.4));
            transition: inherit; /* Inherit transition from parent .character-area */
            opacity: 1; /* Default visible */
            transform: scale(1); /* Default scale */
        }
        /* Class to hide sprites */
        .character-sprite.hidden {
            opacity: 0 !important; /* Use important to override potential inline styles during loading */
            transform: scale(0.95); /* Slight shrink effect */
            /* pointer-events: none; Ensure hidden sprites don't intercept events */
        }
        /* Specific ID for AI sprite if needed */
        #ai-character-sprite { }
        /* Specific ID for Player sprite */
        #player-character-sprite {
            /* Flip horizontally if desired */
             /* transform: scaleX(-1); */
        }


        /* Dialogue Box */
        #dialogue-box {
            position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 950px;
            min-height: 140px; max-height: 38%;
            background: var(--galgame-dialogue-bg);
            backdrop-filter: var(--galgame-dialogue-backdrop-filter);
            border-radius: 12px;
            border: 1px solid var(--galgame-dialogue-border);
            padding: 20px 30px;
            color: var(--galgame-dialogue-text-color);
            z-index: 4; overflow-y: auto;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            scrollbar-width: thin;
            scrollbar-color: var(--galgame-scrollbar-thumb-bg) var(--galgame-scrollbar-track-bg);
        }
         #dialogue-box::-webkit-scrollbar { width: 8px; }
         #dialogue-box::-webkit-scrollbar-track { background: var(--galgame-scrollbar-track-bg); border-radius: 4px;}
         #dialogue-box::-webkit-scrollbar-thumb { background-color: var(--galgame-scrollbar-thumb-bg); border-radius: 4px; border: 1px solid rgba(0, 0, 0, 0.3); }
         #dialogue-box::-webkit-scrollbar-thumb:hover { background-color: var(--galgame-scrollbar-thumb-hover-bg); }

        #speaker-name {
            font-weight: bold; margin-bottom: 10px;
            color: var(--galgame-speaker-name-color);
            font-size: 1.15em;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        #dialogue-text { line-height: 1.7; font-size: 1.05em; }
        /* Markdown Styles */
         #dialogue-text p { margin-bottom: 0.8em;}
         #dialogue-text p:last-child { margin-bottom: 0; } /* Remove margin from last paragraph */
         #dialogue-text h1, #dialogue-text h2, #dialogue-text h3 { margin-top: 0.5em; margin-bottom: 0.3em; color: var(--galgame-config-link-color); }
         #dialogue-text strong { color: var(--galgame-speaker-name-color); }
         #dialogue-text em { color: #90ee90; }
         body.theme-dark #dialogue-text em { color: #b3e6b3; } /* Pastel green for dark */
         #dialogue-text ul, #dialogue-text ol { padding-left: 25px; margin-bottom: 0.8em;}
         #dialogue-text li { margin-bottom: 0.3em;}
         #dialogue-text code { background-color: rgba(255,255,255,0.1); padding: 2px 5px; border-radius: 4px; font-family: 'Courier New', Courier, monospace; color: #f0f0f0; }
         body.theme-dark #dialogue-text code { background-color: rgba(0,0,0,0.3); color: #ccc; }
         #dialogue-text pre { background-color: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; overflow-x: auto; margin-bottom: 0.8em; }
         body.theme-dark #dialogue-text pre { background-color: rgba(0,0,0,0.5); }
         #dialogue-text pre code { background: none; padding: 0; }
         #dialogue-text blockquote { border-left: 3px solid var(--galgame-control-btn-bg); padding-left: 10px; margin: 0.8em 0; color: #ccc; font-style: italic; }
         body.theme-dark #dialogue-text blockquote { color: #aaa; border-left-color: var(--galgame-speaker-name-color); }
         #dialogue-text a { color: var(--galgame-config-link-color); text-decoration: underline; }
         #dialogue-text a:hover { filter: brightness(1.2); }

        /* Game Controls */
        #game-controls {
            position: absolute; bottom: 25px; right: 30px; z-index: 5;
            display: flex; gap: 12px; align-items: center;
        }
        .control-button {
             padding: 10px 20px; border: none; border-radius: 20px;
             background: var(--galgame-control-btn-bg); color: var(--galgame-control-btn-color);
             cursor: pointer; transition: all 0.3s ease; font-size: 1em; font-weight: 500;
             box-shadow: 0 4px 10px rgba(0,0,0,0.15); border: 1px solid var(--galgame-control-btn-border);
             backdrop-filter: blur(3px);
         }
         body.theme-dark .control-button { box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
         .control-button:hover:not(:disabled) { background: var(--galgame-control-btn-hover-bg); box-shadow: 0 6px 15px rgba(0,0,0,0.25); transform: translateY(-2px); }
         body.theme-dark .control-button:hover:not(:disabled) { box-shadow: 0 6px 15px rgba(0,0,0,0.4); }
         .control-button:disabled { background: var(--galgame-config-label-color); color: var(--galgame-config-input-bg); cursor: not-allowed; box-shadow: none; opacity: 0.6; transform: none; }
         #toggle-history-btn { background: var(--galgame-history-btn-bg); color: var(--galgame-history-btn-color); }
         #toggle-history-btn:hover:not(:disabled) { background: var(--galgame-history-btn-hover-bg); }

        /* Choices Container */
        #choices-container { display: flex; flex-direction: column; gap: 10px; margin-top: 15px; }
        .choice-button {
             display: block; width: 100%; text-align: left; padding: 10px 15px;
             border: 1px solid var(--galgame-choice-btn-border); border-radius: 8px;
             background: var(--galgame-choice-btn-bg); color: var(--galgame-choice-btn-color);
             cursor: pointer; transition: background-color 0.3s ease, border-color 0.3s ease; font-size: 0.95em;
             box-sizing: border-box;
         }
         .choice-button:hover { background: var(--galgame-choice-btn-hover-bg); border-color: var(--galgame-speaker-name-color); }

        /* Config Panel & Contents */
        #config-panel {
            position: absolute; top: 10px; right: 10px; width: 350px; /* Wider */
            background: var(--galgame-config-bg);
            backdrop-filter: var(--galgame-config-backdrop-filter);
            border-radius: 8px; padding: 20px; z-index: 10; color: var(--galgame-config-text-color);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); border: 1px solid var(--galgame-config-border);
            display: none; font-size: 0.9em; max-height: 90vh; overflow-y: auto; /* Increased max-height */
        }
        #config-panel.visible { display: block; }
        #config-panel h3 { margin-top: 0; margin-bottom: 15px; text-align: center; color: var(--galgame-config-link-color); }
        #config-panel .form-group { margin-bottom: 15px; }
        #config-panel label { color: var(--galgame-config-label-color); margin-bottom: 5px; font-size: 0.95em; display: block;} /* Ensure label is block */
        #config-panel input[type="text"], #config-panel input[type="password"],
        #config-panel input[type="url"], #config-panel .select-wrapper select,
        #config-panel textarea {
            width: 100%; padding: 8px 10px; border: 1px solid var(--galgame-config-input-border);
            border-radius: 5px; background: var(--galgame-config-input-bg); color: var(--galgame-config-text-color);
            font-size: 1em; box-sizing: border-box; font-family: inherit;
             appearance: none; -webkit-appearance: none; -moz-appearance: none;
        }
         #config-panel textarea { min-height: 60px; resize: vertical; } /* Allow vertical resize */
         #config-panel input:focus, #config-panel textarea:focus, #config-panel select:focus {
             outline: none; border-color: var(--galgame-config-link-color); box-shadow: 0 0 5px var(--galgame-config-link-color);
         }

        /* Select Wrapper (Assuming it exists from main style.css) */
        .select-wrapper { position: relative; }
        .select-wrapper::after {
            content: '‚ñº'; position: absolute; top: 50%; right: 10px; transform: translateY(-50%);
            font-size: 0.8em; color: var(--galgame-config-label-color); pointer-events: none;
        }

        #config-panel .config-buttons { display: flex; justify-content: space-between; margin-top: 20px; }
        #config-panel button { padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.3s; font-size: 0.9em; }
        #save-config-btn { background-color: var(--galgame-save-btn-bg); color: white;} #save-config-btn:hover { background-color: var(--galgame-save-btn-hover-bg);}
        #close-config-btn { background-color: var(--galgame-close-btn-bg); color: white;} #close-config-btn:hover { background-color: var(--galgame-close-btn-hover-bg);}
        #key-status { font-size: 0.85em; margin-top: 5px; display: inline-block; height: 1.2em; vertical-align: middle; }
        #key-status.testing { color: #ffc107; } #key-status.valid { color: #28a745; }
        #key-status.invalid { color: #dc3545; } #key-status.error { color: #ff8aae; }
        #toggle-config-btn {
            position: absolute; top: 20px; right: 20px; z-index: 15;
             background: var(--button-glass-bg); color: var(--button-primary-text); border: 1px solid var(--border-color-light);
             border-radius: 50%; width: 40px; height: 40px; font-size: 20px; cursor: pointer;
             backdrop-filter: blur(5px); transition: all 0.3s ease; display: flex; justify-content: center; align-items: center;
             box-shadow: 0 2px 5px rgba(0,0,0,0.2);
         }
          body.theme-dark #toggle-config-btn { background: var(--galgame-history-btn-bg); color: white; border-color: rgba(255, 192, 203, 0.3); }
         #toggle-config-btn:hover { background: var(--button-glass-hover-bg); transform: scale(1.1) rotate(45deg); }
          body.theme-dark #toggle-config-btn:hover { background: var(--galgame-history-btn-hover-bg); }

        /* Loading & Error Overlays */
        #game-loading-overlay { background: var(--galgame-loading-bg); color: var(--galgame-loading-text-color); position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 9; display: none; justify-content: center; align-items: center; flex-direction: column; gap: 15px; font-size: 1.5em; text-align: center; border-radius: 15px; backdrop-filter: blur(3px); }
        #game-loading-overlay.visible { display: flex; }
        #game-loading-overlay span { animation: pulse 1.5s infinite ease-in-out; }
        #game-loading-overlay .spinner { /* Optional simple spinner */
             border: 4px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top: 4px solid var(--galgame-loading-text-color);
             width: 40px; height: 40px; animation: spin 1s linear infinite;
         }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        #game-error-message { background: var(--galgame-error-bg); color: var(--galgame-error-text-color); position: absolute; top: 10px; left: 50%; transform: translateX(-50%); padding: 10px 20px; border-radius: 8px; z-index: 11; display: none; font-size: 0.95em; box-shadow: 0 3px 10px rgba(0,0,0,0.2); max-width: 90%; text-align: center; }

        /* History Panel */
        #history-panel {
            background: var(--galgame-history-panel-bg); backdrop-filter: var(--galgame-history-panel-backdrop-filter);
            border: 1px solid var(--galgame-history-panel-border); color: var(--galgame-history-panel-text-color);
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); /* Centered */
            width: 80%; max-width: 750px; height: 75%; max-height: 650px; border-radius: 10px; padding: 25px; z-index: 12; box-shadow: 0 5px 25px rgba(0,0,0,0.4); display: none; flex-direction: column; font-size: 0.95em;
        }
        #history-panel.visible { display: flex; }
        #history-panel h3 { color: var(--galgame-history-panel-title-color); margin-top: 0; margin-bottom: 15px; text-align: center; flex-shrink: 0;}
        #history-content {
            flex-grow: 1; overflow-y: auto; padding-right: 10px; margin-bottom: 15px; line-height: 1.6;
            scrollbar-width: thin;
            scrollbar-color: var(--galgame-history-scrollbar-thumb-bg) var(--galgame-history-scrollbar-track-bg);
        }
        #history-content::-webkit-scrollbar { width: 8px; }
        #history-content::-webkit-scrollbar-track { background: var(--galgame-history-scrollbar-track-bg); border-radius: 4px; }
        #history-content::-webkit-scrollbar-thumb { background-color: var(--galgame-history-scrollbar-thumb-bg); border-radius: 4px; border: 1px solid rgba(0, 0, 0, 0.5); }
        #history-content::-webkit-scrollbar-thumb:hover { background-color: var(--galgame-history-scrollbar-thumb-hover-bg); }
        #history-content .history-entry { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px dashed rgba(255, 255, 255, 0.15); }
         body.theme-dark #history-content .history-entry { border-bottom-color: rgba(255, 192, 203, 0.15); } /* Pinkish dash */
        #history-content .history-entry:last-child { border-bottom: none; }
        #history-content .history-role-user { font-weight: bold; color: var(--galgame-history-role-user-color); margin-bottom: 5px; }
        #history-content .history-role-model { font-weight: bold; color: var(--galgame-history-role-model-color); margin-bottom: 5px; }
        /* Nested history text for segments */
        #history-content .history-dialogue-segment { margin-left: 10px; margin-bottom: 5px; font-size: 0.98em; }
        #history-content .history-dialogue-segment .segment-speaker { font-weight: bold; color: var(--galgame-speaker-name-color); margin-right: 5px; }
        #history-content .history-dialogue-segment .segment-text {}
        #history-content .history-dialogue-segment .segment-text p {margin-bottom: 0.3em;} /* Adjust spacing in history */


        #close-history-btn {
             background-color: var(--galgame-history-close-btn-bg); color: white;
             padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.3s; font-size: 0.9em; align-self: center; flex-shrink: 0; margin-top: 10px; /* Added margin */
        }
        #close-history-btn:hover { background-color: var(--galgame-history-close-btn-hover-bg); }

        /* Config Section Styles */
        .config-section { border: 1px dashed var(--galgame-config-input-border); padding: 15px; margin-bottom: 20px; border-radius: 8px; background: rgba(255, 255, 255, 0.1); }
        body.theme-dark .config-section { background: rgba(200, 200, 220, 0.05); }
        .config-section h4 { margin-top: 0; margin-bottom: 10px; color: var(--galgame-config-link-color); border-bottom: 1px solid var(--galgame-config-input-border); padding-bottom: 5px; }
        .form-grid { display: grid; grid-template-columns: 1fr; gap: 15px; }
        .api-key-wrapper { position: relative; display: flex; align-items: center; }
        .api-key-wrapper input { padding-right: 45px; flex-grow: 1; }
        #toggle-api-key-visibility { position: absolute; right: 1px; top: 50%; transform: translateY(-50%); background: none; border: none; cursor: pointer; padding: 10px; color: var(--galgame-config-label-color); font-size: 1.2em; line-height: 1; opacity: 0.7; transition: opacity 0.2s; }
        #toggle-api-key-visibility:hover { opacity: 1; color: var(--galgame-config-text-color); }
        .api-url-wrapper { display: flex; gap: 0; align-items: stretch; }
        .api-url-wrapper input[type="url"] { flex-grow: 1; border-top-right-radius: 0; border-bottom-right-radius: 0; border-right: none; }
        #fetch-models-btn { flex-shrink: 0; padding: 8px 15px; border: 1px solid var(--galgame-config-input-border); border-left: none; border-top-left-radius: 0; border-bottom-left-radius: 0; background: var(--galgame-control-btn-bg); color: var(--galgame-control-btn-color); cursor: pointer; font-weight: 500; font-size: 0.9em; transition: all 0.3s ease; height: auto; }
        #fetch-models-btn:hover:not(:disabled) { background: var(--galgame-control-btn-hover-bg); }
        #fetch-models-btn:disabled { background: rgba(120, 120, 120, 0.3); color: var(--galgame-config-label-color); box-shadow: none; opacity: 0.5; cursor: not-allowed; }
        #model-loading-indicator { margin-left: 8px; color: var(--galgame-config-label-color); font-size: 1.2em; vertical-align: middle; display: none; animation: spin 1.5s linear infinite; } /* Added spin */
        .input-hint { font-size: 0.85em; color: var(--galgame-config-label-color); display:block; margin-top: 5px; opacity: 0.8; }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
             #galgame-container { height: calc(100vh - 80px); margin-top: 10px; }
             .character-area { height: 55%; max-width: 45%; bottom: 3%; } /* Adjust width/position */
             #ai-character-area { right: 2%; }
             #player-character-area { left: 2%; }
             #dialogue-box { width: 95%; min-height: 120px; max-height: 45%; padding: 15px 20px; bottom: 10px; }
             #speaker-name { font-size: 1.05em; } #dialogue-text { font-size: 0.95em; }
             #game-controls { bottom: 15px; right: 15px; gap: 8px; } .control-button { padding: 8px 15px; font-size: 0.9em; }
             #history-panel { width: 90%; height: 80%; top: 50%; transform: translate(-50%, -50%); }
             #config-panel { width: 90%; max-width: 350px; right: 5%; left: 5%; top: 5%; transform: none; } /* Centered better */
             #toggle-config-btn { top: 10px; right: 10px; width: 35px; height: 35px; font-size: 18px;}
             .image-upload-section { flex-direction: column; align-items: stretch; } /* Stack upload elements */
             .image-preview { max-width: 60px; max-height: 60px; }
         }
         @media (max-width: 480px) {
             .character-area { height: 50%; max-width: 55%; } /* Further adjust width */
             #ai-character-area { right: 1%; }
             #player-character-area { left: 1%; }
             #dialogue-box { max-height: 50%; padding: 10px 15px; }
             #speaker-name { font-size: 1em; } #dialogue-text { font-size: 0.9em; }
             .control-button { padding: 6px 12px; font-size: 0.85em; }
             #history-panel { width: 95%; height: 85%; padding: 15px; }
             #config-panel { padding: 15px; width: 90%; /* Consistent width */ }
             .image-preview { max-width: 50px; max-height: 50px; }
             #game-controls { flex-wrap: wrap; justify-content: flex-end; } /* Wrap controls if needed */
         }
    </style>
</head>
<body>
    <!-- Background, Sidebar, Toggle Button -->
    <div class="background"></div>
    <div id="sidebar">
        <nav id="sidebar-nav">
            <a href="index.html">üè† ‰∏ªÈ°µ</a>
            <a href="about.html">‚ú® ÂÖ≥‰∫éÊàë</a>
            <a href="blog_page1.html">üìù ÂçöÂÆ¢</a>
            <a href="contact.html">üíå ËÅîÁ≥ªÊàë</a>
            <a href="download.html">üìÅ Êñá‰ª∂‰∏ãËΩΩ</a>
            <a href="ai_draw.html">üé® AI ‰ΩúÁîª</a>
            <a href="tno_generator.html">üìú TNO‰∫ã‰ª∂ÁîüÊàê</a>
            <a href="if_game.html">üåå AI ‰∫íÂä®Â∞èËØ¥</a>
            <a href="ai_rpg.html">üíñ AI Galgame</a>
        </nav>
        <div class="theme-switcher">
            <h4>ÂàáÊç¢‰∏ªÈ¢ò:</h4>
            <div class="theme-buttons-container">
                <button data-theme="pastel" class="theme-button">üå∏ Á≤âÂΩ©Ê¢¶Â¢É</button>
                <button data-theme="dark" class="theme-button">üåô ÂçàÂ§úÊ®±ËêΩ</button>
            </div>
        </div>
    </div>
    <button id="toggle-btn">‚ò∞</button>

    <!-- Main Content Area -->
    <div class="content scroll-container">
        <header>
            <h1>AI Galgame ‰∫íÂä®ÊïÖ‰∫ã</h1>
             <button id="toggle-config-btn" title="ËÆæÁΩÆ">‚öô</button> <!-- Config Toggle -->
        </header>

        <main>
            <!-- Configuration Panel -->
            <div id="config-panel">
                <!-- Player Settings Section -->
                <div class="config-section">
                    <h4>Áé©ÂÆ∂ËÆæÂÆö</h4>
                    <div class="form-group">
                        <label for="player-name-input">‰Ω†ÁöÑÂêçÂ≠ó:</label>
                        <input type="text" id="player-name-input" placeholder="ËæìÂÖ•‰Ω†ÊÉ≥‰ΩøÁî®ÁöÑÂêçÂ≠ó">
                    </div>
                    <div class="form-group">
                        <label for="player-persona-input">‰Ω†ÁöÑËßíËâ≤ÁÆÄ‰ªã (ÂèØÈÄâÔºåËã•‰∏ä‰º†ÂõæÁâáÂàô‰ºòÂÖà‰ΩøÁî®ÂõæÁâá):</label>
                        <textarea id="player-persona-input" rows="2" placeholder="ÁÆÄÂçïÊèèËø∞‰Ω†ÁöÑËßíËâ≤ (‰æãÂ¶ÇÔºö‰∏Ä‰∏™ÊúâÁÇπÂÜÖÂêë‰ΩÜÂñÑËâØÁöÑÈ´ò‰∏≠Áîü)"></textarea>
                    </div>
                    <!-- Player Image Upload -->
                    <div class="form-group">
                         <label for="player-image-upload">‰∏ä‰º†‰Ω†ÁöÑËßíËâ≤ÂõæÁâá (ÂèØÈÄâ):</label>
                         <div class="image-upload-section">
                             <input type="file" id="player-image-upload" accept="image/png, image/jpeg, image/webp">
                             <div class="image-preview-container">
                                 <img id="player-image-preview" class="image-preview" src="#" alt="Áé©ÂÆ∂ÂõæÁâáÈ¢ÑËßà">
                                 <button id="clear-player-image-btn" class="clear-image-btn">Ê∏ÖÈô§</button>
                             </div>
                         </div>
                         <small class="input-hint">‰∏ä‰º†ÂõæÁâáÂêéÔºåAI‰ºöÂ∞ùËØïÊ†πÊçÆÂõæÁâáÁîüÊàêÂ§ñË≤åÊèèËø∞„ÄÇ</small>
                     </div>
                     <div class="form-group">
                        <label for="player-start-input">ÊúüÊúõÁöÑÂºÄÂ±Ä:</label>
                        <textarea id="player-start-input" rows="2" placeholder="ÊèèËø∞‰Ω†ÊÉ≥Ë¶ÅÁöÑÂºÄÂ±ÄÂú∫ÊôØ (‰æãÂ¶ÇÔºöÂú®Êñ∞Â≠¶Ê†°ÁöÑÁ¨¨‰∏ÄÂ§©Ëø∑Ë∑Ø‰∫Ü)"></textarea>
                    </div>
                </div>

                <!-- AI & API Settings Section -->
                <div class="config-section">
                     <h4>AI & API ËÆæÁΩÆ</h4>
                     <div class="form-grid">
                         <div class="form-group">
                            <label for="galgame-persona">AI ÂØπÊâãËßíËâ≤ËÆæÂÆö (ÂèØÈÄâÔºåËã•‰∏ä‰º†ÂõæÁâáÂàô‰ºòÂÖà‰ΩøÁî®ÂõæÁâá):</label>
                            <textarea id="galgame-persona" rows="2" placeholder="‰Ω†Â∏åÊúõAIÊâÆÊºî‰ªÄ‰πàËßíËâ≤Ôºü(‰æãÂ¶ÇÔºö‰∏Ä‰∏™ÂÇ≤Â®áÁöÑÂêåÁè≠ÂêåÂ≠¶ÔºåÂêçÂè´[‰∫öÈáåÊ≤ô]...)"></textarea>
                         </div>
                         <!-- AI Image Upload -->
                         <div class="form-group">
                              <label for="ai-image-upload">‰∏ä‰º†AIËßíËâ≤ÂõæÁâá (ÂèØÈÄâ):</label>
                              <div class="image-upload-section">
                                  <input type="file" id="ai-image-upload" accept="image/png, image/jpeg, image/webp">
                                  <div class="image-preview-container">
                                      <img id="ai-image-preview" class="image-preview" src="#" alt="AIÂõæÁâáÈ¢ÑËßà">
                                      <button id="clear-ai-image-btn" class="clear-image-btn">Ê∏ÖÈô§</button>
                                  </div>
                              </div>
                              <small class="input-hint">‰∏ä‰º†ÂõæÁâáÂêéÔºåAI‰ºöÂ∞ùËØïÊ†πÊçÆÂõæÁâáÁîüÊàêËØ•ËßíËâ≤ÁöÑÂ§ñË≤åÊèèËø∞„ÄÇ</small>
                          </div>
                          <!-- API Key, URL, Model -->
                          <div class="form-group">
                            <label for="llm-api-key">API ÂØÜÈí•:</label>
                            <div class="api-key-wrapper">
                                <input type="password" id="llm-api-key" placeholder="ËæìÂÖ• API Key (‰æãÂ¶Ç Gemini)">
                                <button id="toggle-api-key-visibility" title="ÂàáÊç¢ÂèØËßÅÊÄß">üëÅÔ∏è</button>
                            </div>
                             <span id="key-status"></span>
                             <button id="test-key-btn" class="control-button" style="padding: 6px 10px; font-size: 0.8em; margin-top: 5px;">ÊµãËØï Key</button>
                        </div>
                        <div class="form-group">
                            <label for="llm-api-url">API Âü∫Á°ÄÂú∞ÂùÄ:</label>
                            <div class="api-url-wrapper">
                                <input type="url" id="llm-api-url" placeholder="‰æãÂ¶Ç: https://generativelanguage.googleapis.com" value="https://generativelanguage.googleapis.com">
                                <button id="fetch-models-btn" title="Ëé∑ÂèñÂèØÁî®Ê®°ÂûãÂàóË°®">Ëé∑ÂèñÂàóË°®</button>
                            </div>
                             <small class="input-hint">(Google: ÁïôÁ©∫ÊàñÂ°´ ...googleapis.com; OpenAIÂÖºÂÆπ: Â°´Âà∞ /v1/ ÁªìÂ∞æ)</small>
                        </div>
                        <div class="form-group">
                            <label for="llm-model-select">ÈÄâÊã© LLM Ê®°Âûã:</label>
                             <div style="display: flex; align-items: center; gap: 10px;">
                                <div class="select-wrapper" style="flex-grow: 1;">
                                    <select id="llm-model-select" disabled>
                                        <option value="" disabled selected>-- ËØ∑ÂÖàËé∑ÂèñÊ®°ÂûãÂàóË°® --</option>
                                    </select>
                                </div>
                                <span id="model-loading-indicator" class="spinner" title="Ê≠£Âú®Âä†ËΩΩÊ®°Âûã..." style="width: 18px; height: 18px; border-width: 2px; display: none;"></span>
                             </div>
                        </div>
                     </div>
                 </div>

                <div class="config-buttons">
                    <button id="save-config-btn">‰øùÂ≠òËÆæÁΩÆ</button>
                    <button id="close-config-btn">ÂÖ≥Èó≠</button>
                </div>
            </div>

            <!-- Galgame UI Container -->
            <div id="galgame-container">
                <div id="game-background"></div>
                <div id="player-character-area" class="character-area">
                    <img id="player-character-sprite" src="#" alt="Áé©ÂÆ∂ËßíËâ≤" class="character-sprite hidden">
                </div>
                <div id="ai-character-area" class="character-area">
                    <img id="ai-character-sprite" src="#" alt="AIËßíËâ≤" class="character-sprite hidden">
                </div>
                <div id="dialogue-box">
                    <div id="speaker-name">ÊóÅÁôΩ</div>
                    <div id="dialogue-text">Âú®ËøôÈáåËÆæÁΩÆÁé©ÂÆ∂ÂêçÁß∞„ÄÅËÆæÂÆöÂíåÊúüÊúõÂºÄÂ±ÄÂêéÔºåÁÇπÂáª‚ÄúÂºÄÂßã‚Äù„ÄÇ</div>
                     <div id="choices-container"></div>
                </div>
                <div id="game-controls">
                    <button id="toggle-history-btn" class="control-button" title="Êü•ÁúãÂØπËØùÂéÜÂè≤" disabled>ÂéÜÂè≤</button>
                    <button id="next-button" class="control-button" disabled>ÂºÄÂßã (ËØ∑ÂÖàËÆæÁΩÆAPI)</button>
                </div>
                 <div id="game-loading-overlay">
                     <div class="spinner"></div>
                     <span>Â∞ëÂ•≥Á•àÁ•∑‰∏≠...</span>
                 </div>
                 <div id="game-error-message"></div>
            </div>

             <!-- History Panel -->
             <div id="history-panel">
                 <h3>ÂØπËØùÂéÜÂè≤ËÆ∞ÂΩï</h3>
                 <div id="history-content"></div>
                 <button id="close-history-btn">ÂÖ≥Èó≠</button>
             </div>
        </main>

        <footer>
            <p>¬© 2024 MOLIFULAN's Blog | Galgame powered by AI</p>
        </footer>
    </div>

    <!-- JS Files -->
    <script src="js/script.js"></script> <!-- Main site script -->
    <script>
        // --- Galgame Specific JS (v6 - Game State Persistence - FULL CODE) ---

        // --- DOM Element References ---
        const configPanel = document.getElementById('config-panel');
        const toggleConfigBtn = document.getElementById('toggle-config-btn');
        const saveConfigBtn = document.getElementById('save-config-btn');
        const closeConfigBtn = document.getElementById('close-config-btn');
        const apiKeyInput = document.getElementById('llm-api-key');
        const apiUrlInput = document.getElementById('llm-api-url');
        const fetchModelsBtn = document.getElementById('fetch-models-btn');
        const modelSelect = document.getElementById('llm-model-select');
        const modelLoadingIndicator = document.getElementById('model-loading-indicator');
        const toggleApiKeyVisibilityBtn = document.getElementById('toggle-api-key-visibility');
        const keyStatusSpan = document.getElementById('key-status');
        const aiPersonaInput = document.getElementById('galgame-persona');
        const playerNameInput = document.getElementById('player-name-input');
        const playerPersonaInput = document.getElementById('player-persona-input');
        const playerStartInput = document.getElementById('player-start-input');
        const dialogueBox = document.getElementById('dialogue-box');
        const speakerName = document.getElementById('speaker-name');
        const dialogueText = document.getElementById('dialogue-text');
        const choicesContainer = document.getElementById('choices-container');
        const nextButton = document.getElementById('next-button');
        const loadingOverlay = document.getElementById('game-loading-overlay');
        const gameErrorMessage = document.getElementById('game-error-message');
        const historyPanel = document.getElementById('history-panel');
        const historyContent = document.getElementById('history-content');
        const toggleHistoryBtn = document.getElementById('toggle-history-btn');
        const closeHistoryBtn = document.getElementById('close-history-btn');
        const gameBackground = document.getElementById('game-background');
        const aiCharacterSprite = document.getElementById('ai-character-sprite');
        const playerCharacterSprite = document.getElementById('player-character-sprite');
        // Image Upload Elements
        const playerImageUpload = document.getElementById('player-image-upload');
        const playerImagePreview = document.getElementById('player-image-preview');
        const clearPlayerImageBtn = document.getElementById('clear-player-image-btn');
        const aiImageUpload = document.getElementById('ai-image-upload');
        const aiImagePreview = document.getElementById('ai-image-preview');
        const clearAiImageBtn = document.getElementById('clear-ai-image-btn');


        // --- Constants ---
        const FIXED_STYLE_PROMPT = "masterpiece, best quality, ultra-detailed, extremely detailed illustration, high resolution, sharp focus, dramatic lighting, strong highlights, deep contrasting shadows, emphasized light interaction, professional game art style, Japanese anime art style, normal anime proportions, standard body ratio, NOT chibi, NO SD";
        const SPRITE_BACKGROUND_KEYWORDS = "plain white background, isolated on white";
        const ALLOWED_IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/webp'];
        const GALGAME_STORAGE_PREFIX = 'galGame_';
        const DEFAULT_API_URL_GALGAME = 'https://generativelanguage.googleapis.com';
        const GAME_STATE_STORAGE_KEY = GALGAME_STORAGE_PREFIX + 'gameState'; // <<< For saving/loading state

        // --- State Variables ---
        // API & AI Config (Loaded from localStorage config)
        let currentApiKey = '';
        let currentApiUrl = '';
        let currentModel = '';
        // Player/AI Setup (Loaded from localStorage config, can be overridden by game state)
        let currentAiPersona = '';
        let playerName = '';
        let playerPersona = ''; // Only used for initial prompt if no image
        let playerStart = '';   // Only used for initial prompt
        // Image Data (Temporary, in memory only)
        let playerImageBase64 = null;
        let aiImageBase64 = null;
        // Active Game State (Saved/Loaded from localStorage game state)
        let conversationHistory = [];
        let playerBaseAppearancePrompt = ''; // Generated by AI or based on persona
        let aiBaseAppearancePrompt = '';     // Generated by AI or based on persona
        let gameStoryPlan = null;            // Generated by AI
        let isGameStarted = false;
        // UI / Turn State (Not saved, reconstructed on load/turn)
        let isLoading = false;
        let spriteCache = {};
        let currentDialogueSegments = [];
        let currentSegmentIndex = 0;
        let currentTurnChoices = [];
        let currentTurnParsedData = null;

        // --- Helper Functions ---
        function getImageDataFromBase64(base64String) {
             if (!base64String || !base64String.startsWith('data:image')) { return null; }
             const parts = base64String.split(',');
             if (parts.length !== 2) return null;
             const mimeMatch = parts[0].match(/:(.*?);/);
             if (!mimeMatch || mimeMatch.length < 2) return null;
             return { mimeType: mimeMatch[1], data: parts[1] };
         }
        function handleImageUpload(fileInput, previewElement, clearButton, stateVariableSetter) {
             const file = fileInput.files[0];
             if (!file) { stateVariableSetter(null); previewElement.style.display = 'none'; clearButton.style.display = 'none'; return; }
             if (!ALLOWED_IMAGE_TYPES.includes(file.type)) { showGameError(`‰∏çÊîØÊåÅÁöÑÊñá‰ª∂Á±ªÂûã: ${file.type}. ËØ∑‰∏ä‰º† JPG, PNG, Êàñ WebP Ê†ºÂºèÂõæÁâá.`); fileInput.value = null; stateVariableSetter(null); previewElement.style.display = 'none'; clearButton.style.display = 'none'; return; }
             const reader = new FileReader();
             reader.onload = (e) => { stateVariableSetter(e.target.result); previewElement.src = e.target.result; previewElement.style.display = 'block'; clearButton.style.display = 'inline-block'; console.log(`Image loaded and stored for ${fileInput.id}`); };
             reader.onerror = (e) => { showGameError("ËØªÂèñÂõæÁâáÊñá‰ª∂Êó∂Âá∫Èîô."); console.error("FileReader error:", e); fileInput.value = null; stateVariableSetter(null); previewElement.style.display = 'none'; clearButton.style.display = 'none'; };
             reader.readAsDataURL(file);
         }
        function clearImageUpload(fileInput, previewElement, clearButton, stateVariableSetter) {
             fileInput.value = null; stateVariableSetter(null); previewElement.src = '#'; previewElement.style.display = 'none'; clearButton.style.display = 'none'; console.log(`Image cleared for ${fileInput.id}`);
         }


        // --- Error & Loading UI ---
        function showGameError(message, duration = 7000) {
             console.error("Game Info/Error:", message);
             gameErrorMessage.textContent = message;
             gameErrorMessage.style.display = 'block';
             if (loadingOverlay.classList.contains('visible')) { setLoading(false); } // Clear loading if showing error
             setTimeout(() => { clearGameError(); }, duration);
          }
        function clearGameError() {
             gameErrorMessage.style.display = 'none'; gameErrorMessage.textContent = '';
         }
        function setLoading(loading) {
             console.log("Setting loading state to:", loading);
             isLoading = loading;
             loadingOverlay.classList.toggle('visible', loading);

             // Update button states universally based on loading status
             const canInteract = currentApiKey && currentModel;
             const choicesExist = choicesContainer?.querySelector('.choice-button') !== null; // Check if choices are currently displayed
             const moreSegmentsAvailable = currentDialogueSegments && currentSegmentIndex < currentDialogueSegments.length - 1;

             if (nextButton) {
                 // Disabled if loading, no API, or (if game started) choices showing or no more segments
                 nextButton.disabled = loading || !canInteract || (isGameStarted && (choicesExist || !moreSegmentsAvailable));
             }
             if (toggleHistoryBtn) {
                 toggleHistoryBtn.disabled = loading || !canInteract || !isGameStarted;
             }
             if (toggleConfigBtn) {
                 toggleConfigBtn.disabled = loading;
             }
             document.querySelectorAll('.choice-button').forEach(btn => btn.disabled = loading);
         }

        // --- Configuration Logic ---
        function saveConfig() {
             const apiKey = apiKeyInput.value.trim();
             const apiUrl = apiUrlInput.value.trim() || DEFAULT_API_URL_GALGAME;
             const model = modelSelect.value;
             const aiPersona = aiPersonaInput.value.trim();
             const pName = playerNameInput.value.trim();
             const pPersona = playerPersonaInput.value.trim();
             const pStart = playerStartInput.value.trim();
             localStorage.setItem(GALGAME_STORAGE_PREFIX + 'apiKey', apiKey);
             localStorage.setItem(GALGAME_STORAGE_PREFIX + 'apiUrl', apiUrl);
             localStorage.setItem(GALGAME_STORAGE_PREFIX + 'model', model);
             localStorage.setItem(GALGAME_STORAGE_PREFIX + 'aiPersona', aiPersona);
             localStorage.setItem(GALGAME_STORAGE_PREFIX + 'playerName', pName);
             localStorage.setItem(GALGAME_STORAGE_PREFIX + 'playerPersona', pPersona);
             localStorage.setItem(GALGAME_STORAGE_PREFIX + 'playerStart', pStart);
             // Update active state variables from inputs
             currentApiKey = apiKey;
             currentApiUrl = apiUrl;
             currentModel = model;
             currentAiPersona = aiPersona;
             playerName = pName;
             playerPersona = pPersona;
             playerStart = pStart;
             console.log("Galgame Config saved:", { currentApiKey, currentApiUrl, currentModel, currentAiPersona, playerName, playerPersona, playerStart });
             updateStartButtonState(); // Update button enablement based on new config
         }
        function loadConfig() {
             // Load config from localStorage into state variables
             currentApiKey = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'apiKey') || '';
             currentApiUrl = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'apiUrl') || DEFAULT_API_URL_GALGAME;
             currentModel = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'model') || '';
             currentAiPersona = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'aiPersona') || '';
             playerName = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'playerName') || '';
             playerPersona = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'playerPersona') || '';
             playerStart = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'playerStart') || '';

             // Update input fields in the config panel
             apiKeyInput.value = currentApiKey;
             apiUrlInput.value = currentApiUrl === DEFAULT_API_URL_GALGAME ? '' : currentApiUrl; // Show placeholder if default
             modelSelect.innerHTML = '<option value="" disabled selected>-- Ëé∑ÂèñÊàñÈÄâÊã©Ê®°Âûã --</option>'; // Reset model dropdown
             if (currentModel) {
                 const o = document.createElement('option');
                 o.value = currentModel; o.textContent = currentModel + " (Â∑≤‰øùÂ≠ò)"; o.selected = true;
                 modelSelect.appendChild(o); modelSelect.disabled = false;
             } else { modelSelect.disabled = true; }
             aiPersonaInput.value = currentAiPersona;
             playerNameInput.value = playerName;
             playerPersonaInput.value = playerPersona;
             playerStartInput.value = playerStart;
             keyStatusSpan.textContent = ''; keyStatusSpan.className = ''; // Reset key status indicator
             console.log("Galgame Config loaded from localStorage.");
             // Initial UI setup (dialogue text, button state) is handled later by initializeNewGameUI or restoreGameState
         }
        function updateStartButtonState() {
             const canStart = currentApiKey && currentModel;
             if (!isGameStarted) {
                 // If game hasn't started, this button is for starting a new game
                 nextButton.textContent = canStart ? 'ÂºÄÂßã' : 'ÂºÄÂßã (ËØ∑ÂÖàËÆæÁΩÆAPI)';
                 nextButton.disabled = isLoading || !canStart;
                 toggleHistoryBtn.disabled = true; // History N/A before start
             } else {
                 // If game is in progress, this button is for advancing dialogue segments
                 const choicesExist = choicesContainer?.querySelector('.choice-button') !== null;
                 const moreSegmentsAvailable = currentDialogueSegments && currentSegmentIndex < currentDialogueSegments.length - 1;
                 nextButton.textContent = 'ÁªßÁª≠';
                 // Disable if loading, choices showing, or no more segments in current turn
                 nextButton.disabled = isLoading || !canStart || choicesExist || !moreSegmentsAvailable;
                 toggleHistoryBtn.disabled = isLoading || !canStart || !isGameStarted;
             }
         }
        function toggleConfigPanel() {
            configPanel.classList.toggle('visible');
         }
        async function fetchLLMModels() {
             const apiKey = apiKeyInput.value.trim(); const baseApiUrl = apiUrlInput.value.trim() || DEFAULT_API_URL_GALGAME;
             if (!apiKey) { showGameError('ËØ∑ÂÖàÂ°´ÂÜô API ÂØÜÈí•„ÄÇ'); return; }
             keyStatusSpan.textContent = ''; keyStatusSpan.className = ''; modelLoadingIndicator.style.display = 'inline-block'; fetchModelsBtn.disabled = true; modelSelect.disabled = true; modelSelect.innerHTML = '<option value="" disabled selected>-- Ê≠£Âú®Ëé∑Âèñ... --</option>';
             let modelListUrl = ''; let headers = { 'Content-Type': 'application/json' }; let method = 'GET';
             try {
                 if (baseApiUrl.includes('generativelanguage.googleapis.com')) { modelListUrl = baseApiUrl.replace(/\/$/, '') + `/v1beta/models?key=${apiKey}&pageSize=1000`; }
                 else if (baseApiUrl.includes('/v1')) { headers['Authorization'] = `Bearer ${apiKey}`; modelListUrl = baseApiUrl.replace(/\/v1\/?$/, '') + '/v1/models'; }
                 else { console.warn("Êú™Áü•Âú∞ÂùÄÊ†ºÂºèÔºåÂ∞ùËØï /v1/models"); headers['Authorization'] = `Bearer ${apiKey}`; modelListUrl = baseApiUrl.replace(/\/$/, '') + '/v1/models'; }
                 console.log("Fetching models from:", modelListUrl);
                 const response = await fetch(modelListUrl, { method, headers });
                 if (!response.ok) { const e = await response.text(); throw new Error(`Ëé∑ÂèñÂ§±Ë¥•: ${response.status} ${response.statusText}. ${e.substring(0,100)}`); }
                 const data = await response.json(); console.log("Model List Raw:", data);
                 let modelNames = [];
                 if (data.models?.length) { modelNames = data.models.map(m => m.name?.replace(/^models\//, '')).filter(Boolean).filter(name => !/embed|vision|instruct|text-|aqa|diffusion|image/i.test(name)).sort(); }
                 else if (data.data?.length) { modelNames = data.data.map(m => m.id).filter(Boolean).filter(id => !/embed|vision|instruct|text-|whisper|tts|davinci|babbage|curie|ada|image|diffusion/i.test(id)).sort(); }
                 else { throw new Error("Êó†Ê≥ïËØÜÂà´ÁöÑÊ®°ÂûãÂàóË°®Ê†ºÂºè„ÄÇ"); }
                 if (modelNames.length === 0) { throw new Error("Âú®Ê≠§ API Âú∞ÂùÄÊú™ÊâæÂà∞ÂèØÁî®ÁöÑËÅäÂ§©Ê®°Âûã„ÄÇ"); }
                 const previouslySelected = currentModel || localStorage.getItem(GALGAME_STORAGE_PREFIX + 'model'); // Use saved value as preference
                 modelSelect.innerHTML = '<option value="" disabled>-- ËØ∑ÈÄâÊã©‰∏Ä‰∏™Ê®°Âûã --</option>';
                 let foundPrevious = false;
                 modelNames.forEach(name => { const o=document.createElement('option'); o.value=name; o.textContent=name; if(name === previouslySelected) { o.selected = true; foundPrevious = true; } modelSelect.appendChild(o); });
                 if (!foundPrevious && modelSelect.options.length > 1) { modelSelect.selectedIndex = 1; } // Select first available if previous not found
                 else if (!foundPrevious && modelSelect.options.length <= 1) { modelSelect.selectedIndex = 0; } // Should not happen if models found
                 currentModel = modelSelect.value; // Update state
                 modelSelect.disabled = !currentModel;
                 clearGameError();
             } catch (error) {
                 console.error("Ëé∑ÂèñÊ®°ÂûãÂá∫Èîô:", error); showGameError(error.message || "Ëé∑ÂèñÊ®°ÂûãÂàóË°®Êó∂Âá∫Èîô„ÄÇ"); modelSelect.innerHTML = '<option value="" disabled selected>-- Ëé∑ÂèñÂ§±Ë¥• --</option>'; modelSelect.disabled = true;
             } finally {
                 modelLoadingIndicator.style.display = 'none'; fetchModelsBtn.disabled = false; modelSelect.disabled = modelSelect.options.length <= 1 || !modelSelect.value;
                 saveConfig(); // Save the selected model
             }
         }
        async function testApiKey() {
             const testKeyButtonElement = document.getElementById('test-key-btn'); const apiKey = apiKeyInput.value.trim(); const baseApiUrl = apiUrlInput.value.trim() || DEFAULT_API_URL_GALGAME;
             if (!apiKey) { keyStatusSpan.textContent = 'ËØ∑ËæìÂÖ• API Key'; keyStatusSpan.className = 'invalid'; return; }
             if (!testKeyButtonElement) { console.error("Êó†Ê≥ïÊâæÂà∞ÊµãËØïÊåâÈíÆÂÖÉÁ¥†!"); keyStatusSpan.textContent = 'È°µÈù¢ÈîôËØØ'; keyStatusSpan.className = 'error'; return; }
             keyStatusSpan.textContent = 'Ê≠£Âú®ÊµãËØï...'; keyStatusSpan.className = 'testing'; testKeyButtonElement.disabled = true;
             let testUrl = ''; let headers = {}; let method = 'GET';
             try {
                 if (baseApiUrl.includes('generativelanguage.googleapis.com')) { testUrl = baseApiUrl.replace(/\/$/, '') + `/v1beta/models?key=${apiKey}`; }
                 else if (baseApiUrl.includes('/v1')) { headers['Authorization'] = `Bearer ${apiKey}`; testUrl = baseApiUrl.replace(/\/v1\/?$/, '') + '/v1/models'; }
                 else { throw new Error("Êó†Ê≥ïÁ°ÆÂÆöÊµãËØï URL Ê†ºÂºè"); }
                 console.log("Testing API Key with URL:", testUrl);
                 const response = await fetch(testUrl, { method, headers });
                 if (response.ok) { keyStatusSpan.textContent = '‚úÖ Key ÊúâÊïà'; keyStatusSpan.className = 'valid'; }
                 else { let errorMsg = `‚ùå Key Êó†ÊïàÊàñURLÈîôËØØ (${response.status})`; try{ const errData = await response.json(); if(errData?.error?.message) errorMsg += `: ${errData.error.message}`; } catch(e){} keyStatusSpan.textContent = errorMsg; keyStatusSpan.className = 'invalid'; }
             } catch (error) {
                 keyStatusSpan.textContent = '‚ö†Ô∏è ÊµãËØïÂá∫Èîô (ÁΩëÁªú/URL?)'; keyStatusSpan.className = 'error'; console.error("Key test error:", error);
             } finally { testKeyButtonElement.disabled = false; }
         }

        // --- History Panel Logic ---
        function toggleHistoryPanel() {
             console.log("toggleHistoryPanel called. isLoading:", isLoading, "isGameStarted:", isGameStarted);
             if (isLoading) return;
             if (!isGameStarted || !currentApiKey || !currentModel) { showGameError("ËØ∑ÂÖàÂºÄÂßãÊ∏∏Êàè‰ª•Êü•ÁúãÂéÜÂè≤ËÆ∞ÂΩï„ÄÇ"); return; }
             if (historyPanel.classList.contains('visible')) { historyPanel.classList.remove('visible'); }
             else { displayHistory(); historyPanel.classList.add('visible'); }
         }
        function displayHistory() {
             console.log("Displaying history. Count:", conversationHistory.length);
             historyContent.innerHTML = ''; // Clear previous content
             if (conversationHistory.length === 0) { historyContent.innerHTML = '<p><i>ËøòÊ≤°ÊúâÂØπËØùËÆ∞ÂΩïÂë¢...</i></p>'; return; }

             // Optionally display story plan at the top
             if(gameStoryPlan && gameStoryPlan.outline && gameStoryPlan.endings) {
                 const planDiv = document.createElement('div');
                 planDiv.style.marginBottom = '20px';
                 planDiv.style.paddingBottom = '15px';
                 planDiv.style.borderBottom = '1px solid rgba(255,255,255,0.1)';
                 planDiv.style.opacity = '0.8';
                 planDiv.innerHTML = `<h4>ÊïÖ‰∫ãËÆ°Âàí</h4>
                     <p><b>Â§ßÁ∫≤:</b> ${gameStoryPlan.outline.join(' -> ')}</p>
                     <b>ÁªìÂ±Ä:</b><ul>${gameStoryPlan.endings.map(e => `<li><b>${e.name || e.id}:</b> ${e.description} (Êù°‰ª∂: ${e.trigger_conditions.join(', ')})</li>`).join('')}</ul>`;
                 historyContent.appendChild(planDiv);
             }

             conversationHistory.forEach(entry => {
                 if (entry.role === 'user' && entry.isSetup) { return; } // Skip setup prompt
                 const entryDiv = document.createElement('div'); entryDiv.classList.add('history-entry');
                 if (entry.role === 'user') {
                     const roleSpan = document.createElement('div'); roleSpan.classList.add('history-role-user'); roleSpan.textContent = `${playerName || '‰Ω†'}:`;
                     const textDiv = document.createElement('div'); textDiv.classList.add('history-text'); textDiv.textContent = entry.parts[0]?.text || '(Á©∫Ê∂àÊÅØ)';
                     entryDiv.appendChild(roleSpan); entryDiv.appendChild(textDiv);
                 } else if (entry.role === 'model') {
                     try {
                         const parsedData = JSON.parse(entry.parts[0]?.text || '{}');
                         const segments = parsedData.dialogue_segments || [];
                         const choices = parsedData.choices || [];
                         if (segments.length > 0) {
                             segments.forEach(segment => {
                                 const segmentDiv = document.createElement('div'); segmentDiv.classList.add('history-dialogue-segment');
                                 const speakerSpan = document.createElement('span'); speakerSpan.classList.add('segment-speaker'); speakerSpan.textContent = `${segment.speaker || '???'}:`;
                                 const textSpan = document.createElement('span'); textSpan.classList.add('segment-text');
                                 try { textSpan.innerHTML = typeof DOMPurify !== 'undefined' ? DOMPurify.sanitize(marked.parse(segment.text || '(Á©∫ÁâáÊÆµ)')) : marked.parse(segment.text || '(Á©∫ÁâáÊÆµ)'); } catch(e){ textSpan.textContent = segment.text || '(Á©∫ÁâáÊÆµ)'; }
                                 segmentDiv.appendChild(speakerSpan); segmentDiv.appendChild(textSpan);
                                 entryDiv.appendChild(segmentDiv);
                             });
                         } else { /* Handle case with no segments but maybe choices? unlikely */ }
                         if (choices.length > 0 && entry !== conversationHistory[conversationHistory.length - 1]) { // Show choices only for past turns
                             const choiceList = document.createElement('ul'); choiceList.style.fontSize = '0.9em'; choiceList.style.opacity = '0.7'; choiceList.style.marginTop = '8px'; choiceList.style.paddingLeft = '25px'; choiceList.innerHTML = '<i>Áé©ÂÆ∂ÈÄâÊã©‰∫Ü: ...</i>'; // Can't easily know which was chosen historically here
                             entryDiv.appendChild(choiceList);
                         }
                     } catch (e) {
                         console.error("Failed to parse model entry in history:", e, entry.parts[0]?.text);
                         const roleSpan = document.createElement('div'); roleSpan.classList.add('history-role-model'); roleSpan.textContent = `AI (ÂéüÂßã):`;
                         const textDiv = document.createElement('div'); textDiv.classList.add('history-text'); textDiv.textContent = entry.parts[0]?.text || '(Êó†Ê≥ïËß£Êûê)';
                         entryDiv.appendChild(roleSpan); entryDiv.appendChild(textDiv);
                     }
                 }
                 historyContent.appendChild(entryDiv);
             });
             historyContent.scrollTop = historyContent.scrollHeight; // Scroll to bottom
         }

        // --- Character Sprite Background Removal ---
        async function removeEdgeWhiteBackground(img) {
             return new Promise((resolve, reject) => {
                 const canvas = document.createElement('canvas');
                 const ctx = canvas.getContext('2d', { willReadFrequently: true });
                 const width = img.naturalWidth; const height = img.naturalHeight;
                 if (width === 0 || height === 0) { console.warn("Image has zero dimensions, cannot process."); resolve(img.src); return; }
                 canvas.width = width; canvas.height = height;
                 try {
                     ctx.drawImage(img, 0, 0);
                     const imageData = ctx.getImageData(0, 0, width, height);
                     const data = imageData.data;
                     const visited = new Uint8Array(width * height);

                     // --- Pass 1: Edge Flood Fill ---
                     const whiteThreshold = 255;
                     const floodFillTolerance = 7; // Tolerance for near-white
                     const effectiveFloodThreshold = whiteThreshold - floodFillTolerance;
                     function isNearWhiteForFlood(index) { if (index < 0 || index >= data.length || data[index+3] < 128) return false; const r = data[index]; const g = data[index + 1]; const b = data[index + 2]; return r >= effectiveFloodThreshold && g >= effectiveFloodThreshold && b >= effectiveFloodThreshold; }
                     function getIndex(x, y) { return (y * width + x) * 4; }
                     function getVisitedIndex(x, y) { return y * width + x; }
                     const queue = [];
                     for (let y = 0; y < height; y++) { for (let x = 0; x < width; x++) { if (y === 0 || y === height - 1 || x === 0 || x === width - 1) { const index = getIndex(x, y); const visitedIndex = getVisitedIndex(x,y); if (isNearWhiteForFlood(index) && !visited[visitedIndex]) { queue.push({ x, y }); visited[visitedIndex] = 1; } } } }
                     // console.log(`Starting Flood Fill Pass. Tolerance: ${floodFillTolerance}. Initial Queue:`, queue.length);
                     // let processedFloodFillCount = 0;
                     while (queue.length > 0) {
                         const { x, y } = queue.shift(); const index = getIndex(x, y);
                         if (data[index + 3] > 0) { data[index + 3] = 0; /*processedFloodFillCount++;*/ } // Make transparent
                         const neighbors = [ { nx: x + 1, ny: y }, { nx: x - 1, ny: y }, { nx: x, ny: y + 1 }, { nx: x, ny: y - 1 } ];
                         for (const {nx, ny} of neighbors) { if (nx >= 0 && nx < width && ny >= 0 && ny < height) { const neighborIndex = getIndex(nx, ny); const visitedIndex = getVisitedIndex(nx, ny); if (isNearWhiteForFlood(neighborIndex) && !visited[visitedIndex]) { visited[visitedIndex] = 1; queue.push({ x: nx, y: ny }); } } }
                     }
                     // console.log(`Flood fill finished. ${processedFloodFillCount} pixels made transparent.`);

                     // --- Pass 2: Cleanup Isolated Near-White Pixels ---
                     const cleanupTolerance = 4; // Strict tolerance
                     const effectiveCleanupThreshold = whiteThreshold - cleanupTolerance;
                     // let cleanedPixelCount = 0;
                     // console.log(`Starting Cleanup Pass. Strict Tolerance: ${cleanupTolerance}`);
                     for (let y = 1; y < height - 1; y++) {
                          for (let x = 1; x < width - 1; x++) {
                              const index = getIndex(x, y);
                              if (data[index + 3] > 0) { // Check if not already transparent
                                  const r = data[index]; const g = data[index + 1]; const b = data[index + 2];
                                  if (r >= effectiveCleanupThreshold && g >= effectiveCleanupThreshold && b >= effectiveCleanupThreshold) { // Check if very close to white
                                      let transparentNeighbors = 0;
                                      const neighborsIndices = [ getIndex(x+1, y), getIndex(x-1, y), getIndex(x, y+1), getIndex(x, y-1) ];
                                      for (const nIndex of neighborsIndices) { if (nIndex >= 0 && nIndex < data.length && data[nIndex + 3] === 0) { transparentNeighbors++; } }
                                      if (transparentNeighbors >= 3) { data[index + 3] = 0; /*cleanedPixelCount++;*/ } // Make speck transparent
                                  }
                              }
                          }
                     }
                     // console.log(`Cleanup pass finished. ${cleanedPixelCount} isolated pixels made transparent.`);
                     ctx.putImageData(imageData, 0, 0);
                     resolve(canvas.toDataURL('image/png'));
                 } catch (error) {
                      if (error.name === 'SecurityError') { console.error("Canvas processing error (likely CORS)...", error); resolve(img.src); } // Fallback on CORS
                      else { console.error("Canvas processing error in removeEdgeWhiteBackground:", error); resolve(img.src); } // Fallback on other errors
                 }
             });
         }
        // --- Image Loading ---
        async function loadDynamicImage(element, prompt, imageType = "background", nologo = true, seed = null) {
            const isCharacter = imageType === 'character';
            if (!prompt || !element) {
                 console.warn(`Skipping ${imageType} image: No prompt or element.`);
                 if (isCharacter) { element.classList.add('hidden'); element.style.opacity = null; element.removeAttribute('src'); }
                 return Promise.resolve();
             }

             const baseImagePrompt = prompt;
             // console.log(`Attempting to load ${imageType} image with base prompt: ${baseImagePrompt}`);
             let width, height, extraParams = "", finalPromptString = '';

             if (isCharacter) {
                 width = 768; height = 1024; extraParams = "&nofeed=true";
                 finalPromptString = `${FIXED_STYLE_PROMPT}, ${SPRITE_BACKGROUND_KEYWORDS}, ${baseImagePrompt}`;
                 // console.log("Final Character Prompt:", finalPromptString);

                 // Check cache first
                 if (spriteCache[finalPromptString]) {
                     // console.log(`Cache hit for character: ${finalPromptString.substring(0, 50)}...`);
                     element.src = spriteCache[finalPromptString];
                     // No need to call remove hidden here, handled by caller after Promise resolves
                     return Promise.resolve();
                 }
                 // If not cached, prepare for loading (caller should handle initial hidden state)
             } else { // Background
                 finalPromptString = `${baseImagePrompt}, anime style, visual novel background, detailed illustration, high quality`;
                 width = 1024; height = 1024; // Or maybe 1280x720? Adjust as needed
             }

             const nologoValue = nologo ? 'true' : 'false';
             // Using a fixed seed for reproducibility during a session might be useful for debugging
             // const seedValue = seed || Math.floor(Math.random()*1e7);
             const seedValue = Math.floor(Math.random()*1e7); // Keep random for now
             let finalUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPromptString)}?width=${width}&height=${height}&model=flux&nologo=${nologoValue}${extraParams}&seed=${seedValue}`;
             // console.log(`Loading ${imageType} image URL:`, finalUrl);

             return new Promise((resolve) => {
                 const img = new Image();
                 img.crossOrigin = "Anonymous"; // Attempt to enable CORS for canvas processing

                 img.onload = async () => {
                     // console.log(`${imageType} image preloaded/loaded successfully.`);
                     if (isCharacter) {
                         try {
                             // console.log(`Attempting white background removal for ${element.id}...`);
                             const processedUrl = await removeEdgeWhiteBackground(img);
                             element.src = processedUrl;
                             spriteCache[finalPromptString] = processedUrl; // Cache processed URL
                             // console.log(`White background removal finished for ${element.id}.`);
                         } catch (error) {
                             console.error(`Using original URL due to background removal error for ${element.id}:`, error);
                             element.src = finalUrl; // Fallback to original URL
                             spriteCache[finalPromptString] = finalUrl; // Cache original URL on error
                             showGameError(`Â§ÑÁêÜ ${element.alt} ËÉåÊôØÊó∂Âá∫Èîô„ÄÇ`);
                         }
                     } else { // Background
                         element.style.backgroundImage = `url('${finalUrl}')`;
                         // console.log(`Background image set for element:`, element);
                     }
                     resolve(); // Resolve after processing/setting background
                 };

                 img.onerror = (e) => {
                     console.error(`Error loading ${imageType} image:`, e, finalUrl);
                     showGameError(`${imageType === 'character' ? element.alt : 'ËÉåÊôØ'} Âä†ËΩΩÂ§±Ë¥•„ÄÇ`);
                     if (isCharacter) {
                         element.classList.add('hidden'); // Ensure it's hidden on error
                         element.style.opacity = null;
                         element.removeAttribute('src');
                     }
                     resolve(); // Resolve even on error so Promise.allSettled continues
                 };
                 img.src = finalUrl; // Start loading
             });
         }


        // --- LLM API Call ---
        async function callLLMApi_Galgame(promptHistory) {
             console.log("callLLMApi_Galgame initiated.");
             if (!currentApiKey || !currentModel || !currentApiUrl) { showGameError("API ÈÖçÁΩÆ‰∏çÂÆåÊï¥ÔºÅËØ∑Ê£ÄÊü•ËÆæÁΩÆ„ÄÇ"); const fallbackData = { scene_state: { background_prompt: "error config", visible_characters: [] }, dialogue_segments: [{ speaker: "Á≥ªÁªü", text: "API ÈÖçÁΩÆ‰∏çÂÆåÊï¥ÔºÅËØ∑Ê£ÄÊü•ËÆæÁΩÆ„ÄÇ", emotion: null }], choices: ["[ÂÖ≥Èó≠]"] }; if (isGameStarted && (!conversationHistory.length || !conversationHistory[conversationHistory.length - 1].isErrorFallback)) { conversationHistory.push({ role: "model", parts: [{ text: JSON.stringify(fallbackData) }], isErrorFallback: true }); } return fallbackData; }
             clearGameError();
             let finalApiUrl = currentApiUrl.trim(); let requestBody; let headers = { 'Content-Type': 'application/json' }; const isFirstCall = promptHistory.length === 1 && promptHistory[0].isSetup; let userPromptText = promptHistory[promptHistory.length - 1].parts[0].text;
             const systemInstruction = `‰Ω†Áé∞Âú®ÊòØ‰∏Ä‰∏™ Galgame (ËßÜËßâÂ∞èËØ¥) ÂºïÊìé„ÄÇ‰Ω†ÁöÑ‰ªªÂä°ÊòØ‰∏éÁé©ÂÆ∂ (${playerName || 'Áé©ÂÆ∂'}) ‰∫íÂä®ÔºåÂπ∂ÁîüÊàêÊ∏∏ÊàèÂÜÖÂÆπ„ÄÇ\nÁé©ÂÆ∂Âü∫Á°ÄÂ§ñË≤åÊèêÁ§∫ËØç(Áî±‰Ω†ÁîüÊàêÊàñÂÆåÂñÑ): ${playerBaseAppearancePrompt || '(Â∞öÊú™ÁîüÊàê)'}\nAIËßíËâ≤Âü∫Á°ÄÂ§ñË≤åÊèêÁ§∫ËØç(Áî±‰Ω†ÁîüÊàêÊàñÂÆåÂñÑ): ${aiBaseAppearancePrompt || '(Â∞öÊú™ÁîüÊàê)'}\n${currentAiPersona ? `AI ËßíËâ≤ËÆæÂÆö: ${currentAiPersona}\n` : ''}ËØ∑**‰∏•Ê†º**ÊåâÁÖß‰ª•‰∏ã JSON Ê†ºÂºèÁîüÊàêÂìçÂ∫îÔºå‰∏çË¶ÅÂåÖÂê´‰ªª‰ΩïÈ¢ùÂ§ñÁöÑËß£ÈáäÊàñ Markdown Ê†áËÆ∞ÂåÖË£π JSON Êú¨Ë∫´Ôºö\n\`\`\`json\n{\n  "scene_state": {\n    "background_prompt": "String (Âú∫ÊôØÁöÑËã±ÊñáÊèèËø∞, ËøôÊòØÊ∏∏ÊàèËÉåÊôØÂõæ, ‰∏çÊòØËßíËâ≤Á´ãÁªòËÉåÊôØ!)",\n    "visible_characters": [\n      {\n        "character_id": "'player' or 'ai'",\n        "emotion": "String or Null (ËßíËâ≤„ÄêÂΩìÂâç„ÄëÁöÑË°®ÊÉÖ/Âä®‰Ωú/ÁªÜÂæÆÂèòÂåñ, e.g., 'smiling slightly', 'surprised face', 'holding a pen', 'adjusting glasses')"\n      }\n      // ... ÂèØËÉΩÂåÖÂê´ 'player' Âíå/Êàñ 'ai'\n    ]\n  },\n  "dialogue_segments": [\n    {\n      "speaker": "String (AIËßíËâ≤Âêç, ${playerName ? "'" + playerName + "'" : "'Áé©ÂÆ∂'"}, 'ÊóÅÁôΩ', 'ÂÜÖÂøÉÊÉ≥Ê≥ï')",\n      "emotion": "String or Null (ËØ¥ËØùËÄÖË°®ÊÉÖ/Âä®‰Ωú, ÂØπÂ∫îÊ≠§„ÄêÂØπËØù„ÄëÂÜÖÂÆπ)",\n      "text": "String (ËØ•ÁâáÊÆµÁöÑÂØπËØù/ÊóÅÁôΩÊñáÊú¨, ÊîØÊåÅMarkdown)"\n    }\n    // ... more segments\n  ],\n  "choices": [\n    "String (ÈÄâÈ°π1)", \n    "String (ÈÄâÈ°π2)"\n  ],\n  "initial_setup_details": { \n     // !!! Ëøô‰∏™Â≠óÊÆµ„ÄêÂè™Âú®„ÄëÂìçÂ∫îÁ¨¨‰∏Ä‰∏™ËÆæÁΩÆËØ∑Ê±ÇÊó∂Âá∫Áé∞ !!!\n     "player_base_appearance_prompt": "String (ÁîüÊàê„ÄêÁÆÄË¶Å„ÄÅËøûË¥Ø„ÄëÁöÑÁé©ÂÆ∂Âü∫Á°ÄÂ§ñË≤åËã±ÊñáÊèêÁ§∫ËØç... **ÁªùÂØπ‰∏çË¶ÅÂåÖÂê´ËßíËâ≤ÂêçÂ≠óÔºå‰æãÂ¶Ç 'Player'ÔºÅ**)",\n     "ai_base_appearance_prompt": "String (ÁîüÊàê„ÄêÁÆÄË¶Å„ÄÅËøûË¥Ø„ÄëÁöÑAIËßíËâ≤Âü∫Á°ÄÂ§ñË≤åËã±ÊñáÊèêÁ§∫ËØç... **ÁªùÂØπ‰∏çË¶ÅÂåÖÂê´ËßíËâ≤ÂêçÂ≠óÔºå‰æãÂ¶ÇAIËÆæÂÆö‰∏≠ÁöÑÂêçÂ≠óÔºÅ**)"\n  },\n  "story_plan": { \n      // !!! Ëøô‰∏™Â≠óÊÆµ„ÄêÂè™Âú®„ÄëÂìçÂ∫îÁ¨¨‰∏Ä‰∏™ËÆæÁΩÆËØ∑Ê±ÇÊó∂Âá∫Áé∞ !!!\n      "outline": ["String (Èò∂ÊÆµ1ÊèèËø∞)", "..."],\n      "endings": [ { "id": "...", "name": "...", "description": "...", "trigger_conditions": ["..."] }, ... ],\n      "key_decisions": ["String (ÂÖ≥ÈîÆÈÄâÊã©ÁÇπ1ÊèèËø∞)", "..."]\n  }\n}\n\`\`\`\n*   **scene_state**: ÊèèËø∞ÂΩìÂâçÂú∫ÊôØËßÜËßâÁä∂ÊÄÅ„ÄÇ\n    *   **background_prompt**: ...\n    *   **visible_characters**: ... \`emotion\` ... **„ÄêÁªùÂØπÁ¶ÅÊ≠¢„Äë** ...ÈáçÊñ∞ÊèèËø∞ËßíËâ≤ÁöÑÊ†∏ÂøÉÁâπÂæÅ..., **Âπ∂‰∏îÁªùÂØπÁ¶ÅÊ≠¢ÂåÖÂê´‰ªª‰ΩïËßíËâ≤ÂêçÂ≠óÔºÅ** ...\n*   **dialogue_segments**: ...\n*   **choices**: ...\n*   **initial_setup_details**: „ÄêÂè™Âú®È¶ñÊ¨°ÂìçÂ∫îÊó∂Êèê‰æõ„Äë... **ÈáçË¶ÅÔºö** ÁîüÊàêÂü∫Á°ÄÂ§ñË≤åÊèêÁ§∫ËØçÊó∂Ôºå**ÁªùÂØπ‰∏çË¶ÅÂåÖÂê´ËßíËâ≤ÂêçÂ≠ó**...\n*   **story_plan**: „ÄêÂè™Âú®È¶ñÊ¨°ÂìçÂ∫îÊó∂Êèê‰æõ„Äë...\n*   **È£éÊ†ºÂíåÁ´ãÁªòËÉåÊôØ**: ...\n\nËøôÊòØ‰πãÂâçÁöÑÂØπËØùÂéÜÂè≤ÔºàÊúÄËøëÂá†Êù°ÔºâÔºö\n${JSON.stringify(promptHistory.slice(-6, -1).map(h => `${h.role === 'user' ? (playerName || 'Áé©ÂÆ∂') : 'AI Response (Segments)'}: ${h.role === 'user' ? h.parts[0].text : '(...)'}`)).substring(0, 1000)}...\n\nÁî®Êà∑ÁöÑÊúÄÊñ∞ËæìÂÖ•/ÈÄâÊã©ÊòØ: "${userPromptText}"\n\nËØ∑ÁîüÊàê JSON Ê†ºÂºèÁöÑÂìçÂ∫î„ÄÇ`;

             try {
                 // --- API Request Body Construction ---
                 if (finalApiUrl.includes('generativelanguage.googleapis.com')) {
                     if (!finalApiUrl.includes('/v1beta/models')) { finalApiUrl = finalApiUrl.replace(/\/$/, '') + `/v1beta/models/${currentModel}:generateContent?key=${currentApiKey}`; } else { finalApiUrl += `?key=${currentApiKey}`; }
                     let geminiContents = [];
                     promptHistory.slice(0, isFirstCall ? -1 : undefined).slice(-7).forEach(h => { const role = (h.role === 'model' ? 'model' : 'user'); if (geminiContents.length > 0 && geminiContents[geminiContents.length - 1].role === role) { if (role === 'model') geminiContents.push({ role: 'user', parts: [{ text: "(Continue...)" }] }); else geminiContents.push({ role: 'model', parts: [{ text: "{}" }] }); } geminiContents.push({ role: role, parts: [{ text: h.parts[0].text }] }); });
                     let currentUserParts = []; if (isFirstCall) { const playerData = getImageDataFromBase64(playerImageBase64); if (playerData) { currentUserParts.push({ inline_data: { mime_type: playerData.mimeType, data: playerData.data } }); console.log("Adding player image to Gemini request"); } const aiData = getImageDataFromBase64(aiImageBase64); if (aiData) { currentUserParts.push({ inline_data: { mime_type: aiData.mimeType, data: aiData.data } }); console.log("Adding AI image to Gemini request"); } } currentUserParts.push({ text: userPromptText });
                     geminiContents.push({ role: 'user', parts: currentUserParts });
                     requestBody = JSON.stringify({ contents: geminiContents, generationConfig: { responseMimeType: "application/json" } });
                 } else if (finalApiUrl.includes('/v1')) {
                     headers['Authorization'] = `Bearer ${currentApiKey}`; if (!finalApiUrl.includes('/chat/completions')) { finalApiUrl = finalApiUrl.replace(/\/v1\/?$/, '') + '/v1/chat/completions'; }
                     let openAiMessages = []; openAiMessages.push({ "role": "system", "content": systemInstruction }); promptHistory.slice(0, -1).slice(-7).forEach(h => { openAiMessages.push({ role: h.role === 'model' ? 'assistant' : 'user', content: h.parts[0].text }); });
                     let currentUserContent = []; currentUserContent.push({ type: "text", text: userPromptText }); if (isFirstCall) { if (playerImageBase64) { currentUserContent.push({ type: "image_url", image_url: { url: playerImageBase64 } }); } if (aiImageBase64) { currentUserContent.push({ type: "image_url", image_url: { url: aiImageBase64 } }); } } openAiMessages.push({ role: "user", content: currentUserContent });
                     requestBody = JSON.stringify({ model: currentModel, messages: openAiMessages, max_tokens: 8192, response_format: { type: "json_object" } });
                 } else { throw new Error("Êó†Ê≥ïËØÜÂà´ÁöÑ API Âü∫Á°ÄÂú∞ÂùÄÊ†ºÂºè„ÄÇ"); }
                 // console.log("Calling Galgame LLM API:", finalApiUrl);

                 // --- API Call and Response Handling ---
                 const response = await fetch(finalApiUrl, { method: 'POST', headers, body: requestBody });
                 // console.log("LLM API Response Status:", response.status);
                 let data; try { data = await response.json(); /* console.log("LLM API Raw Response Data:", JSON.stringify(data, null, 2)); */ } catch (jsonError) { console.error("Failed to parse API response as JSON:", jsonError); try { const textResponse = await response.text(); console.error("API Raw Response Text:", textResponse); throw new Error(`APIÂìçÂ∫î‰∏çÊòØÊúâÊïàÁöÑJSONÊ†ºÂºè: ${textResponse.substring(0, 100)}...`); } catch (textError) { throw new Error("APIÂìçÂ∫î‰∏çÊòØÊúâÊïàÁöÑJSONÊ†ºÂºèÔºå‰∏îÊó†Ê≥ïËØªÂèñÊñáÊú¨ÂÜÖÂÆπ„ÄÇ"); } }
                 if (!response.ok) { let errorMsg = `API ËØ∑Ê±ÇÂ§±Ë¥•: ${response.status} ${response.statusText}`; if (data?.error?.message) { errorMsg += `\nDetails: ${data.error.message}`; } else { errorMsg += `\nDetails: ${JSON.stringify(data)}`; } throw new Error(errorMsg); }

                 // --- Content Extraction ---
                 let responseContent = null; if (data?.error?.message || data?.error?.code) { throw new Error(`APIÈîôËØØ: ${data.error.message || `Code ${data.error.code}`}`); } else if (data.candidates?.[0]?.finishReason && data.candidates[0].finishReason !== "STOP") { let reason = data.candidates[0].finishReason; if (data.promptFeedback?.blockReason) { reason += ` (Block Reason: ${data.promptFeedback.blockReason})`; } throw new Error(`ËØ∑Ê±ÇË¢´ÁªàÊ≠¢: ${reason}`); } else if (data.candidates?.[0]?.content?.parts?.[0]?.text) { responseContent = data.candidates[0].content.parts[0].text; } else if (data.choices?.[0]?.finish_reason && data.choices[0].finish_reason !== "stop") { throw new Error(`ËØ∑Ê±ÇË¢´ÁªàÊ≠¢: ${data.choices[0].finish_reason}`); } else if (data.choices?.[0]?.message?.content) { responseContent = data.choices[0].message.content; } else if (data.choices?.[0]?.error) { throw new Error(`APIÈîôËØØ: ${data.choices[0].error.message || JSON.stringify(data.choices[0].error)}`); } else { throw new Error("Êó†Ê≥ï‰ªé API ÂìçÂ∫î‰∏≠ÊèêÂèñÊúâÊïàÂÜÖÂÆπ„ÄÇ"); }
                 // console.log("Extracted Response Content (before parsing):", responseContent);

                 // --- JSON Parsing and Validation ---
                 let parsedData;
                 try {
                     const cleanedText = responseContent.replace(/^```json\s*|```$/gs, '').trim(); if (!cleanedText) { throw new Error("ÊèêÂèñÂà∞ÁöÑÂÜÖÂÆπ‰∏∫Á©∫Â≠óÁ¨¶‰∏≤„ÄÇ"); } parsedData = JSON.parse(cleanedText);
                     // Basic Validation
                     if (!parsedData || typeof parsedData !== 'object') throw new Error("Parsed data is not an object.");
                     if (!parsedData.scene_state || typeof parsedData.scene_state !== 'object') throw new Error("Missing or invalid scene_state.");
                     if (typeof parsedData.scene_state.background_prompt !== 'string') throw new Error("Invalid background_prompt type.");
                     if (!Array.isArray(parsedData.scene_state.visible_characters)) throw new Error("Invalid visible_characters type.");
                     for(const charInfo of parsedData.scene_state.visible_characters) { if (typeof charInfo !== 'object' || charInfo === null || typeof charInfo.character_id !== 'string' || (charInfo.character_id !== 'player' && charInfo.character_id !== 'ai') || (typeof charInfo.emotion !== 'string' && charInfo.emotion !== null)) throw new Error("Invalid item in visible_characters."); }
                     if (!Array.isArray(parsedData.dialogue_segments)) throw new Error("Invalid dialogue_segments type.");
                     if (parsedData.dialogue_segments.length === 0) { parsedData.dialogue_segments.push({speaker: "ÊóÅÁôΩ", text:"(AIÊú™ËøîÂõûÂØπËØùÂÜÖÂÆπ)", emotion: null}); } else { for(const segment of parsedData.dialogue_segments) { if (typeof segment !== 'object' || segment === null || typeof segment.speaker !== 'string' || typeof segment.text !== 'string') throw new Error("Invalid item in dialogue_segments."); segment.emotion = segment.emotion || null; } }
                     if (!Array.isArray(parsedData.choices)) throw new Error("Invalid choices type.");
                     if (parsedData.choices.length === 0) { parsedData.choices = ["[ÁªßÁª≠...]"]; } else { for(let i = 0; i < parsedData.choices.length; i++) { if (typeof parsedData.choices[i] !== 'string') throw new Error(`Invalid choice type at index ${i}.`); } }

                     // Specific Handling for Initial Call Fields
                     if (isFirstCall) {
                         if (!parsedData.initial_setup_details || typeof parsedData.initial_setup_details !== 'object') throw new Error("Initial setup response missing valid initial_setup_details object.");
                         if (typeof parsedData.initial_setup_details.player_base_appearance_prompt !== 'string' || !parsedData.initial_setup_details.player_base_appearance_prompt.trim()) throw new Error("Initial setup missing valid player_base_appearance_prompt.");
                         if (typeof parsedData.initial_setup_details.ai_base_appearance_prompt !== 'string' || !parsedData.initial_setup_details.ai_base_appearance_prompt.trim()) throw new Error("Initial setup missing valid ai_base_appearance_prompt.");
                         console.log("Initial setup details received and validated.");

                         if (!parsedData.story_plan || typeof parsedData.story_plan !== 'object') { console.warn("Initial setup response missing valid story_plan object. Proceeding without plan."); gameStoryPlan = null; }
                         else { if (!Array.isArray(parsedData.story_plan.outline) || !Array.isArray(parsedData.story_plan.endings)) { console.warn("Invalid story_plan structure. Proceeding without plan."); gameStoryPlan = null; } else { console.log("Story plan received and validated."); gameStoryPlan = parsedData.story_plan; console.log("Stored Story Plan:", JSON.stringify(gameStoryPlan, null, 2)); } }
                     } else {
                         if (parsedData.initial_setup_details) { console.warn("AI incorrectly included initial_setup_details. Ignoring."); delete parsedData.initial_setup_details; }
                         if (parsedData.story_plan) { console.warn("AI incorrectly included story_plan. Ignoring."); delete parsedData.story_plan; }
                     }
                 } catch (parseError) { console.error("Failed to parse or validate LLM JSON response:", parseError); console.error("Received content that failed parsing:", responseContent); const fallbackData = { scene_state: { background_prompt: "error background", visible_characters: [] }, dialogue_segments: [{ speaker: "Á≥ªÁªü", text: `Êä±Ê≠âÔºåËß£ÊûêAIÂìçÂ∫îÊó∂Âá∫ÈîôÔºö${parseError.message}`, emotion: null }], choices: ["[Â∞ùËØïÁªßÁª≠]"] }; if (!conversationHistory.length || !conversationHistory[conversationHistory.length - 1].isErrorFallback) { conversationHistory.push({ role: "model", parts: [{ text: JSON.stringify(fallbackData) }], isErrorFallback: true }); } return fallbackData; }

                 conversationHistory.push({ role: "model", parts: [{ text: JSON.stringify(parsedData) }] });
                 return parsedData;
             } catch (error) { console.error("Ë∞ÉÁî® Galgame LLM API ËøáÁ®ãÂá∫Èîô:", error); showGameError(error.message || "‰∏é AI ÁöÑËøûÊé•‰∏≠Êñ≠ÊàñÂ§ÑÁêÜÂìçÂ∫îÂá∫Èîô„ÄÇ"); const fallbackData = { scene_state: { background_prompt: "error background", visible_characters: [] }, dialogue_segments: [{ speaker: "Á≥ªÁªü", text: `Êä±Ê≠âÔºåËøûÊé•ÊàñÂ§ÑÁêÜAIÂìçÂ∫îÊó∂Âá∫ÈîôÔºö${error.message}`, emotion: null }], choices: ["[Â∞ùËØïÁªßÁª≠]"] }; if (!conversationHistory.length || !conversationHistory[conversationHistory.length - 1].isErrorFallback) { conversationHistory.push({ role: "model", parts: [{ text: JSON.stringify(fallbackData) }], isErrorFallback: true }); } return fallbackData; }
        }


        // --- UI Update Functions ---
        function updateDialogueUI(parsedData) {
             console.log("Updating dialogue UI with parsed data:", parsedData);
             clearGameError();
             currentDialogueSegments = parsedData.dialogue_segments || [];
             currentTurnChoices = parsedData.choices || [];
             currentSegmentIndex = 0;

             if (currentDialogueSegments.length > 0) {
                 displayCurrentSegment(); // Display the first segment
                 // Determine button state after displaying first segment
                 const choicesExist = currentTurnChoices && currentTurnChoices.length > 0;
                 const moreSegments = currentDialogueSegments.length > 1;
                 nextButton.style.display = moreSegments ? 'block' : 'none'; // Show "Next" only if multiple segments
                 nextButton.disabled = isLoading || !moreSegments; // Disable if no more segments initially
                 if (!moreSegments) { // If only one segment, process choices immediately
                    processChoicesAndButtonState();
                 } else {
                    choicesContainer.innerHTML = ''; // Clear choices if showing segments first
                 }
             } else {
                 // No dialogue segments, proceed directly to choices
                 console.warn("Parsed data has no dialogue segments. Proceeding to choices.");
                 dialogueText.innerHTML = ""; speakerName.textContent = "ÊóÅÁôΩ";
                 processChoicesAndButtonState();
             }
             setLoading(false); // Stop loading indicator after UI update starts
         }
        function displayCurrentSegment() {
             if (!currentDialogueSegments || currentSegmentIndex >= currentDialogueSegments.length) {
                 console.error("displayCurrentSegment called with invalid index or no segments.");
                 processChoicesAndButtonState(); // Fallback to choices if something went wrong
                 setLoading(false); return;
             }
             const segment = currentDialogueSegments[currentSegmentIndex];
             // console.log(`Displaying segment ${currentSegmentIndex + 1}/${currentDialogueSegments.length}:`, segment);
             speakerName.textContent = segment.speaker || "Êú™Áü•";
             try {
                 const cleanHtml = typeof DOMPurify !== 'undefined' ? DOMPurify.sanitize(marked.parse(segment.text || "")) : marked.parse(segment.text || "");
                 dialogueText.innerHTML = cleanHtml;
             } catch (e) { console.error("Markdown parsing error for segment:", e); dialogueText.textContent = segment.text || ""; showGameError("ÂØπËØùÁâáÊÆµÊ†ºÂºèËß£ÊûêÂá∫Èîô„ÄÇ"); }
             dialogueBox.scrollTop = 0; // Scroll to top of dialogue box
             choicesContainer.innerHTML = ''; // Clear choices while showing segment

             // Update "Next" button state
             const isLastSegment = currentSegmentIndex === currentDialogueSegments.length - 1;
             nextButton.style.display = 'block'; // Always show if displaying segments
             nextButton.disabled = isLoading || isLastSegment; // Disable only if it's the last one
             if (isLastSegment) {
                 processChoicesAndButtonState(); // Show choices immediately after the last segment
             }
             // setLoading(false); // Don't set loading false here, let updateDialogueUI handle it
         }
        function processChoicesAndButtonState() {
             choicesContainer.innerHTML = ''; // Clear previous choices
             if (currentTurnChoices && currentTurnChoices.length > 0) {
                 // console.log("Processing final choices:", currentTurnChoices);
                 nextButton.style.display = 'none'; // Hide "Next" button when choices appear
                 currentTurnChoices.forEach((choiceText) => {
                     const button = document.createElement('button');
                     button.classList.add('choice-button');
                     button.textContent = choiceText.replace(/^\[|\]$/g, ''); // Remove potential brackets
                     button.onclick = () => handleChoice_Galgame(choiceText);
                     button.disabled = isLoading; // Ensure choices are disabled while loading
                     choicesContainer.appendChild(button);
                 });
                 nextButton.disabled = true; // Keep next button disabled
             } else {
                 // This case should ideally not happen if the AI follows instructions
                 console.error("No choices available to display. Game cannot proceed.");
                 nextButton.style.display = 'block'; // Show next button maybe? Or an end message?
                 nextButton.disabled = true; // Definitely disable
                 showGameError("AI Êú™Êèê‰æõ‰ªª‰ΩïÈÄâÈ°πÔºåÊïÖ‰∫ãÊó†Ê≥ïÁªßÁª≠„ÄÇ");
             }
             // console.log("Choices processed and displayed.");
             // setLoading(false); // Let updateDialogueUI handle final setLoading(false)
         }


        // --- Game Flow Functions ---
        function startGame_Galgame() {
             console.log("startGame_Galgame called");
             if (!currentApiKey || !currentModel) { showGameError("ËØ∑ÂÖàÂÆåÊàêÂπ∂‰øùÂ≠ò API ÈÖçÁΩÆÔºÅ"); toggleConfigPanel(); return; }

             // Reset all game state variables
             isGameStarted = true;
             conversationHistory = [];
             playerBaseAppearancePrompt = '';
             aiBaseAppearancePrompt = '';
             gameStoryPlan = null;
             spriteCache = {}; // Clear image cache
             currentDialogueSegments = [];
             currentSegmentIndex = 0;
             currentTurnChoices = [];
             currentTurnParsedData = null;

             // Update UI for game start
             nextButton.textContent = 'ÁªßÁª≠';
             toggleHistoryBtn.disabled = false; // Enable history button
             speakerName.textContent = 'ÊóÅÁôΩ';
             dialogueText.innerHTML = ''; // Clear initial text
             choicesContainer.innerHTML = ''; // Clear any leftover choices

             // Construct Initial Setup Prompt with Story Planning Request
             let initialSetupText = "=== Ê∏∏ÊàèÂºÄÂßãËÆæÂÆö ===\n";
             initialSetupText += `Áé©ÂÆ∂ÂêçÁß∞: ${playerName || 'Áé©ÂÆ∂'}\n`;
             // Player Setup Instruction (Task 1)
             if (playerImageBase64) { initialSetupText += `‰ªªÂä°1: Ê†πÊçÆ„ÄêÁ¨¨‰∏ÄÂº†„ÄëÊèê‰æõÁöÑÁé©ÂÆ∂ÂõæÁâáÔºåÁîüÊàê‰∏Ä‰∏™„ÄêÊûÅÂÖ∂ËØ¶ÁªÜ‰∏îËøûË¥Ø„ÄëÁöÑÁé©ÂÆ∂„ÄêÂü∫Á°ÄÂ§ñË≤åËã±ÊñáÊèêÁ§∫ËØç„Äë...„ÄêÁ¶ÅÊ≠¢„ÄëÂåÖÂê´ 'same character/face/style' Á≠âÊó†ÊïàËØçËØ≠„ÄÇ **ÁªùÂØπ‰∏çË¶ÅÂåÖÂê´ËßíËâ≤ÂêçÂ≠óÔºÅ**\n`; }
             else if (playerPersona) { initialSetupText += `Áé©ÂÆ∂ËßíËâ≤ÁÆÄ‰ªã: ${playerPersona}\n‰ªªÂä°1: Âü∫‰∫éÁé©ÂÆ∂ÁÆÄ‰ªãÔºåÁîüÊàê‰∏Ä‰∏™„ÄêÊûÅÂÖ∂ËØ¶ÁªÜ‰∏îËøûË¥Ø„ÄëÁöÑÁé©ÂÆ∂„ÄêÂü∫Á°ÄÂ§ñË≤åËã±ÊñáÊèêÁ§∫ËØç„Äë...„ÄêÁ¶ÅÊ≠¢„ÄëÂåÖÂê´ 'same character/face/style' Á≠âÊó†ÊïàËØçËØ≠„ÄÇ **ÁªùÂØπ‰∏çË¶ÅÂåÖÂê´ËßíËâ≤ÂêçÂ≠óÔºÅ**\n`; }
             else { initialSetupText += `Áé©ÂÆ∂ËßíËâ≤ÁÆÄ‰ªã: (Êó†ÔºåÁî±‰Ω†ÂàõÈÄ†)\n‰ªªÂä°1: ÂàõÈÄ†‰∏Ä‰∏™ÂêàÈÄÇÁöÑÁé©ÂÆ∂ËßíËâ≤ÔºåÂπ∂ÁîüÊàê‰∏Ä‰∏™„ÄêÊûÅÂÖ∂ËØ¶ÁªÜ‰∏îËøûË¥Ø„ÄëÁöÑÁé©ÂÆ∂„ÄêÂü∫Á°ÄÂ§ñË≤åËã±ÊñáÊèêÁ§∫ËØç„Äë...„ÄêÁ¶ÅÊ≠¢„ÄëÂåÖÂê´ 'same character/face/style' Á≠âÊó†ÊïàËØçËØ≠„ÄÇ **ÁªùÂØπ‰∏çË¶ÅÂåÖÂê´ËßíËâ≤ÂêçÂ≠óÔºÅ**\n`; }
             // AI Setup Instruction (Task 2)
             if (aiImageBase64) { const imageIndexText = playerImageBase64 ? "„ÄêÁ¨¨‰∫åÂº†„Äë" : "„ÄêÁ¨¨‰∏ÄÂº†„Äë"; initialSetupText += `‰ªªÂä°2: Ê†πÊçÆ${imageIndexText}Êèê‰æõÁöÑAIËßíËâ≤ÂõæÁâáÔºåÁîüÊàê‰∏Ä‰∏™„ÄêÊûÅÂÖ∂ËØ¶ÁªÜ‰∏îËøûË¥Ø„ÄëÁöÑAIËßíËâ≤„ÄêÂü∫Á°ÄÂ§ñË≤åËã±ÊñáÊèêÁ§∫ËØç„Äë...„ÄêÁ¶ÅÊ≠¢„ÄëÂåÖÂê´ 'same character/face/style' Á≠âÊó†ÊïàËØçËØ≠„ÄÇ **ÁªùÂØπ‰∏çË¶ÅÂåÖÂê´ËßíËâ≤ÂêçÂ≠óÔºÅ**\n`; }
             else if (currentAiPersona) { initialSetupText += `AIÂØπÊâãËßíËâ≤ËÆæÂÆö: ${currentAiPersona}\n‰ªªÂä°2: Âü∫‰∫éAIËßíËâ≤ËÆæÂÆöÔºåÁîüÊàê‰∏Ä‰∏™„ÄêÊûÅÂÖ∂ËØ¶ÁªÜ‰∏îËøûË¥Ø„ÄëÁöÑAIËßíËâ≤„ÄêÂü∫Á°ÄÂ§ñË≤åËã±ÊñáÊèêÁ§∫ËØç„Äë...„ÄêÁ¶ÅÊ≠¢„ÄëÂåÖÂê´ 'same character/face/style' Á≠âÊó†ÊïàËØçËØ≠„ÄÇ **ÁªùÂØπ‰∏çË¶ÅÂåÖÂê´ËßíËâ≤ÂêçÂ≠óÔºÅ**\n`; }
             else { initialSetupText += `AIÂØπÊâãËßíËâ≤ËÆæÂÆö: (Êó†ÔºåÁî±‰Ω†ÂàõÈÄ†)\n‰ªªÂä°2: ÂàõÈÄ†‰∏Ä‰∏™ÂêàÈÄÇÁöÑAIÂØπÊâãËßíËâ≤ÔºåÂπ∂ÁîüÊàê‰∏Ä‰∏™„ÄêÊûÅÂÖ∂ËØ¶ÁªÜ‰∏îËøûË¥Ø„ÄëÁöÑAIËßíËâ≤„ÄêÂü∫Á°ÄÂ§ñË≤åËã±ÊñáÊèêÁ§∫ËØç„Äë...„ÄêÁ¶ÅÊ≠¢„ÄëÂåÖÂê´ 'same character/face/style' Á≠âÊó†ÊïàËØçËØ≠„ÄÇ **ÁªùÂØπ‰∏çË¶ÅÂåÖÂê´ËßíËâ≤ÂêçÂ≠óÔºÅ**\n`; }
             // Game Setup (Task 3 & 4)
             initialSetupText += `ÊúüÊúõÂºÄÂ±Ä: ${playerStart || '‰∏Ä‰∏™ÊúâË∂£ÊàñÂ∏∏ËßÅÁöÑÊó•Â∏∏Âú∫ÊôØ„ÄÇ'}\nÊ∏∏ÊàèÁ±ªÂûã: ‰∫íÂä®ÊïÖ‰∫ã (‰∏çÈôê‰∫éÁâπÂÆöÁ±ªÂûã)\n`;
             initialSetupText += "=== ‰ªªÂä°3 (ÊïÖ‰∫ãËßÑÂàí) ===\nËØ∑Âú®ÂºÄÂßãÁîüÊàêÂÖ∑‰ΩìÂØπËØùÂâçÔºåÂÖà‰∏∫Êú¨Ê¨°‰∫íÂä®ÊïÖ‰∫ãÊûÑÊÄù‰∏Ä‰∏™Êï¥‰ΩìËÆ°Âàí„ÄÇÂåÖÂê´Ôºö\n1. **ÊïÖ‰∫ãÂ§ßÁ∫≤ (Outline):** ÁÆÄË¶ÅÂàóÂá∫‰∏ªË¶ÅÂèëÂ±ïÈò∂ÊÆµÔºà3-5 ‰∏™Ôºâ„ÄÇ\n2. **Â§öÁªìÂ±ÄÂÆö‰πâ (Endings):** ËÆæËÆ° 2-3 ‰∏™‰∏çÂêåÁªìÂ±ÄÔºàÂê´ÂêçÁß∞„ÄÅÊèèËø∞„ÄÅÊ†∏ÂøÉÊù°‰ª∂Ôºâ„ÄÇ\n3. **ÂÖ≥ÈîÆÈÄâÊã©ÁÇπ (Key Decisions):** ÊåáÂá∫Â§ßÁ∫≤‰∏≠ÂΩ±ÂìçÁªìÂ±ÄÁöÑÂÖ≥ÈîÆÈÄâÊã©Èò∂ÊÆµ„ÄÇ\n";
             initialSetupText += "=== ‰ªªÂä°4 (ÁîüÊàêÈ¶ñÊ¨°ÂìçÂ∫î) ===\nËØ∑ÁîüÊàêÊ∏∏ÊàèÁöÑÂºÄÂú∫ÁôΩ„ÄÅÂú∫ÊôØÊèèËø∞ÂíåÁ¨¨‰∏Ä‰∏™ÂØπËØùÁâáÊÆµ„ÄÇÁ°Æ‰øù„ÄêÈ¶ñÊ¨°ÂìçÂ∫î„ÄëÁöÑJSONÂåÖÂê´Ôºö\n1. `initial_setup_details` (Âê´ appearance prompts)„ÄÇ\n2. `scene_state`„ÄÇ\n3. `dialogue_segments`„ÄÇ\n4. `choices`„ÄÇ\n5. **`story_plan` ÂØπË±° (Âê´ÊûÑÊÄùÁöÑ outline, endings, key_decisions)**„ÄÇ\nËØ∑‰∏•Ê†º‰ΩøÁî®ÂâçÈù¢ÊèèËø∞ÁöÑÊñ∞JSONÊ†ºÂºèËæìÂá∫„ÄÇ\n=====================\n";

             // console.log("Initial Setup Text Prompt:", initialSetupText);
             conversationHistory.push({ role: 'user', parts: [{ text: initialSetupText }], isSetup: true });
             proceedStory_Galgame(); // Start the first turn
         }
        async function proceedStory_Galgame(userChoice = null) {
             if (userChoice) { console.log("Proceeding story with choice:", userChoice); }
             else { console.log("Proceeding story (initial or next segment)"); }

             setLoading(true);
             clearGameError();
             // Reset turn-specific temp state
             currentTurnParsedData = null;
             currentDialogueSegments = [];
             currentSegmentIndex = 0;
             currentTurnChoices = [];

             // Hide sprites before API call and image loading
             aiCharacterSprite.classList.add('hidden'); aiCharacterSprite.style.opacity = null; aiCharacterSprite.removeAttribute('src');
             playerCharacterSprite.classList.add('hidden'); playerCharacterSprite.style.opacity = null; playerCharacterSprite.removeAttribute('src');
             // console.log("Sprites hidden & src cleared at start of proceedStory");

             try {
                 // Call the API - includes logic to store story_plan on first call
                 const parsedData = await callLLMApi_Galgame(conversationHistory);
                 currentTurnParsedData = parsedData; // Store for potential later use this turn

                 // Handle initial setup details (appearance prompts) if present (only on first call)
                 if (parsedData.initial_setup_details) {
                     console.log("--- Processing Initial Setup Details ---");
                     playerBaseAppearancePrompt = parsedData.initial_setup_details.player_base_appearance_prompt || '';
                     aiBaseAppearancePrompt = parsedData.initial_setup_details.ai_base_appearance_prompt || '';
                     console.log("Stored Player Base Prompt:", playerBaseAppearancePrompt.substring(0,100) + "...");
                     console.log("Stored AI Base Prompt:", aiBaseAppearancePrompt.substring(0,100) + "...");
                      // Clear uploaded image data after use (no longer needed)
                      if (playerImageBase64) { console.log("Clearing player image data after initial setup."); clearImageUpload(playerImageUpload, playerImagePreview, clearPlayerImageBtn, (val) => playerImageBase64 = val); }
                      if (aiImageBase64) { console.log("Clearing AI image data after initial setup."); clearImageUpload(aiImageUpload, aiImagePreview, clearAiImageBtn, (val) => aiImageBase64 = val); }
                 }
                 // gameStoryPlan is stored inside callLLMApi_Galgame

                 // Update UI with new dialogue/choices - this also sets setLoading(false) internally
                 updateDialogueUI(parsedData);

                 // --- Load Images based on the new scene_state ---
                 const imagePromises = [];
                 const sceneState = parsedData.scene_state || {};
                 let playerShouldBeVisible = false; let aiShouldBeVisible = false;

                 // Load background first
                 imagePromises.push(loadDynamicImage(gameBackground, sceneState.background_prompt || "default anime background", 'background'));

                 // Prepare character sprites based on visibility and prompts
                 const visibleCharacters = sceneState.visible_characters || [];
                 // console.log("--- Preparing Visible Characters ---");
                 // console.log("Visible Characters Data:", JSON.stringify(visibleCharacters));

                 visibleCharacters.forEach(charInfo => {
                     let basePrompt = ''; let imgElement = null; let altText = '';
                     if (charInfo.character_id === 'player' && playerBaseAppearancePrompt) { basePrompt = playerBaseAppearancePrompt; imgElement = playerCharacterSprite; altText = playerName || "Áé©ÂÆ∂ËßíËâ≤"; playerShouldBeVisible = true; }
                     else if (charInfo.character_id === 'ai' && aiBaseAppearancePrompt) { basePrompt = aiBaseAppearancePrompt; imgElement = aiCharacterSprite; const aiNameMatch = currentAiPersona?.match(/\[([^\]]+)\]/); altText = aiNameMatch ? aiNameMatch[1] : "AIËßíËâ≤"; aiShouldBeVisible = true; }

                     if (imgElement && basePrompt) {
                         let characterDetails = basePrompt; if (charInfo.emotion?.trim()) { characterDetails += `, ${charInfo.emotion.trim()}`; } // Append emotion if present
                         imgElement.alt = altText;
                         // Only start loading if the character should be visible
                         if ((charInfo.character_id === 'player' && playerShouldBeVisible) || (charInfo.character_id === 'ai' && aiShouldBeVisible)) {
                             imagePromises.push(loadDynamicImage(imgElement, characterDetails, 'character'));
                         }
                     } // else: Skip if no element or base prompt
                 });

                 // console.log("Waiting for images to load/process...");
                 await Promise.allSettled(imagePromises); // Wait for all images to load/fail
                 // console.log("Image loading/processing finished.");

                 // --- Final Visibility Check After Loading ---
                 // console.log("Final visibility check: Player=", playerShouldBeVisible, " AI=", aiShouldBeVisible);
                 playerCharacterSprite.classList.toggle('hidden', !playerShouldBeVisible);
                 aiCharacterSprite.classList.toggle('hidden', !aiShouldBeVisible);
                 // Reset opacity if they became visible, let CSS handle transition
                 if (playerShouldBeVisible) playerCharacterSprite.style.opacity = '';
                 if (aiShouldBeVisible) aiCharacterSprite.style.opacity = '';

                 // --- Save Game State After Successful Turn ---
                 saveGameState();

             } catch (error) {
                 console.error("Error proceeding Galgame story:", error);
                 showGameError(`Â§ÑÁêÜÊïÖ‰∫ãÊó∂ÂèëÁîüÈîôËØØ: ${error.message}`);
                 // Ensure sprites hidden and loading stopped on error
                 aiCharacterSprite.classList.add('hidden'); playerCharacterSprite.classList.add('hidden');
                 aiCharacterSprite.style.opacity = null; playerCharacterSprite.style.opacity = null;
                 aiCharacterSprite.removeAttribute('src'); playerCharacterSprite.removeAttribute('src');
                 setLoading(false);
             }
             // setLoading(false) is handled by updateDialogueUI or the catch block
         }
        function handleNext_Galgame() {
             // console.log("handleNext_Galgame called.");
             if (isLoading || !isGameStarted) return;
             if (currentDialogueSegments && currentSegmentIndex < currentDialogueSegments.length - 1) {
                 currentSegmentIndex++;
                 // setLoading(true); // Maybe not needed just for segment change? Depends on feel.
                 displayCurrentSegment(); // Display next segment
             } else {
                 // This case means "Next" was clicked on the last segment, which shouldn't happen if disabled correctly
                 console.warn("handleNext_Galgame called unexpectedly (likely on last segment).");
                 nextButton.disabled = true; // Ensure disabled
                 // setLoading(false);
             }
         }
        function handleChoice_Galgame(choiceText) {
             // console.log("handleChoice_Galgame called with:", choiceText, "isLoading:", isLoading);
             if (isLoading) return;
             console.log("Galgame User chose:", choiceText);
             // Disable choice buttons immediately
             choicesContainer.querySelectorAll('button').forEach(btn => btn.disabled = true);
             // Add choice to history
             conversationHistory.push({ role: 'user', parts: [{ text: choiceText }], isSetup: false });
             // Reset temporary turn state (dialogue segments/index/choices)
             currentDialogueSegments = []; currentSegmentIndex = 0; currentTurnChoices = []; currentTurnParsedData = null;
             // console.log(">>> About to call proceedStory_Galgame from handleChoice");
             proceedStory_Galgame(choiceText); // Pass choice for context if needed by proceedStory
             // console.log("<<< Call to proceedStory_Galgame finished (in handleChoice_Galgame)");
         }

        // --- Game State Persistence Functions ---
        function saveGameState() {
             if (!isGameStarted) { console.log("Game not started, not saving state."); return; }
             const gameState = {
                 conversationHistory: conversationHistory,
                 playerBaseAppearancePrompt: playerBaseAppearancePrompt,
                 aiBaseAppearancePrompt: aiBaseAppearancePrompt,
                 gameStoryPlan: gameStoryPlan,
                 playerName: playerName, // Save current player name
                 currentAiPersona: currentAiPersona, // Save current AI persona
                 isGameStarted: isGameStarted,
                 timestamp: Date.now()
             };
             try {
                 // Limit history size to prevent storage overflow (e.g., keep last 50 turns = 100 entries)
                 const maxHistoryEntries = 100;
                 if (gameState.conversationHistory.length > maxHistoryEntries) {
                     console.warn(`History length (${gameState.conversationHistory.length}) exceeds limit (${maxHistoryEntries}). Trimming.`);
                     gameState.conversationHistory = gameState.conversationHistory.slice(-maxHistoryEntries);
                 }
                 localStorage.setItem(GAME_STATE_STORAGE_KEY, JSON.stringify(gameState));
                 console.log("Game state saved.", { historyLength: gameState.conversationHistory.length, timestamp: new Date(gameState.timestamp).toLocaleTimeString() });
             } catch (error) {
                 console.error("Error saving game state:", error);
                 // Provide more context for storage full error
                 if (error.name === 'QuotaExceededError') {
                      showGameError("Êó†Ê≥ï‰øùÂ≠òÊ∏∏ÊàèËøõÂ∫¶ÔºöÊµèËßàÂô®Â≠òÂÇ®Á©∫Èó¥Â∑≤Êª°ÔºÅËØ∑Â∞ùËØïÊ∏ÖÁêÜÊàñÂú®Êñ∞ÊµèËßàÂô®‰∏≠ÊâìÂºÄ„ÄÇ");
                 } else {
                      showGameError("Êó†Ê≥ï‰øùÂ≠òÊ∏∏ÊàèËøõÂ∫¶ÔºåÂèëÁîüÊú™Áü•ÈîôËØØ„ÄÇ");
                 }
             }
         }
        function clearGameState() {
             localStorage.removeItem(GAME_STATE_STORAGE_KEY);
             console.log("Game state cleared from localStorage.");
         }
        function showRestorePrompt(savedState) {
             const lastSaveTime = new Date(savedState.timestamp).toLocaleString();
             // Using a timeout to ensure the message appears after initial loading/rendering
             setTimeout(() => {
                  if (confirm(`ÂèëÁé∞‰∏äÊ¨°ÁöÑÊ∏∏ÊàèËøõÂ∫¶ (‰øùÂ≠ò‰∫é ${lastSaveTime})„ÄÇ\nË¶ÅÁªßÁª≠ÂêóÔºü\n(ÁÇπÂáª‚ÄúÂèñÊ∂à‚ÄùÂ∞ÜÂºÄÂßãÊñ∞Ê∏∏Êàè)`)) {
                     restoreGameState(savedState);
                 } else {
                     clearGameState(); // User chose not to restore
                     initializeNewGameUI();
                     showGameError("Â∑≤ÂøΩÁï•‰∏äÊ¨°ËøõÂ∫¶„ÄÇËØ∑ÈÖçÁΩÆÂπ∂ÁÇπÂáª‚ÄúÂºÄÂßã‚ÄùÂàõÂª∫Êñ∞Ê∏∏Êàè„ÄÇ", 3000);
                 }
             }, 100); // Short delay
         }
        function restoreGameState(state) {
             console.log("Restoring game state...");
             try {
                 // Restore core state variables
                 conversationHistory = state.conversationHistory || [];
                 playerBaseAppearancePrompt = state.playerBaseAppearancePrompt || '';
                 aiBaseAppearancePrompt = state.aiBaseAppearancePrompt || '';
                 gameStoryPlan = state.gameStoryPlan || null;
                 playerName = state.playerName || ''; // Use saved name
                 currentAiPersona = state.currentAiPersona || ''; // Use saved persona
                 isGameStarted = state.isGameStarted || false; // Should be true if state exists

                 // Update config inputs to reflect restored state for user reference
                 playerNameInput.value = playerName;
                 aiPersonaInput.value = currentAiPersona;
                 // API Key/Model/URL remain from loaded config, not game state

                 if (!isGameStarted) {
                     throw new Error("Saved state indicates game wasn't started."); // Should not happen
                 }
                 if (conversationHistory.length === 0) {
                      throw new Error("Saved state has empty history."); // Also unlikely if saved correctly
                 }

                 // Find the last *model* response to restore the UI state
                 let lastModelEntry = null;
                 for (let i = conversationHistory.length - 1; i >= 0; i--) {
                     if (conversationHistory[i].role === 'model') { lastModelEntry = conversationHistory[i]; break; }
                 }

                 if (!lastModelEntry?.parts?.[0]?.text) {
                      throw new Error("Could not find valid last model response in history.");
                 }

                 const lastParsedData = JSON.parse(lastModelEntry.parts[0].text); // Assume valid JSON
                 currentTurnParsedData = lastParsedData; // Store for context

                 // Restore UI based on the last saved model response (dialogue, choices)
                 // updateDialogueUI also handles setLoading(false) at the end
                 updateDialogueUI(lastParsedData);

                 // --- Trigger Image Loading for the Restored State ---
                 setLoading(true); // Show loading overlay during image restore
                 const imagePromises = []; const sceneState = lastParsedData.scene_state || {};
                 let playerShouldBeVisible = false; let aiShouldBeVisible = false;
                 imagePromises.push(loadDynamicImage(gameBackground, sceneState.background_prompt || "default anime background", 'background'));
                 const visibleCharacters = sceneState.visible_characters || [];
                 visibleCharacters.forEach(charInfo => { let basePrompt = ''; let imgElement = null; let altText = ''; if (charInfo.character_id === 'player' && playerBaseAppearancePrompt) { basePrompt = playerBaseAppearancePrompt; imgElement = playerCharacterSprite; altText = playerName || "Áé©ÂÆ∂ËßíËâ≤"; playerShouldBeVisible = true; } else if (charInfo.character_id === 'ai' && aiBaseAppearancePrompt) { basePrompt = aiBaseAppearancePrompt; imgElement = aiCharacterSprite; const aiNameMatch = currentAiPersona?.match(/\[([^\]]+)\]/); altText = aiNameMatch ? aiNameMatch[1] : "AIËßíËâ≤"; aiShouldBeVisible = true; } if (imgElement && basePrompt) { let characterDetails = basePrompt; if (charInfo.emotion?.trim()) { characterDetails += `, ${charInfo.emotion.trim()}`; } imgElement.alt = altText; if ((charInfo.character_id === 'player' && playerShouldBeVisible) || (charInfo.character_id === 'ai' && aiShouldBeVisible)) { imagePromises.push(loadDynamicImage(imgElement, characterDetails, 'character')); } } });

                 Promise.allSettled(imagePromises).then(() => {
                      console.log("Images restored.");
                      // Final visibility check after images loaded
                      playerCharacterSprite.classList.toggle('hidden', !playerShouldBeVisible);
                      aiCharacterSprite.classList.toggle('hidden', !aiShouldBeVisible);
                      if (playerShouldBeVisible) playerCharacterSprite.style.opacity = '';
                      if (aiShouldBeVisible) aiCharacterSprite.style.opacity = '';
                      setLoading(false); // Hide loading overlay AFTER images are done
                      updateStartButtonState(); // Ensure buttons are correctly enabled/disabled
                 });
                 // --- End Image Loading ---

                 console.log("Game state restored successfully.");
                 // Add a small indicator in the dialogue
                  const restoreMsg = document.createElement('p'); restoreMsg.style.opacity = '0.7'; restoreMsg.style.fontSize = '0.9em'; restoreMsg.style.marginTop = '10px'; restoreMsg.innerHTML = '<i>--- Ê∏∏ÊàèËøõÂ∫¶Â∑≤ÊÅ¢Â§ç ---</i>';
                  dialogueText.appendChild(restoreMsg); dialogueBox.scrollTop = dialogueBox.scrollHeight; // Scroll down

             } catch (error) {
                 console.error("Error restoring game state:", error);
                 showGameError("ÊÅ¢Â§çÊ∏∏ÊàèËøõÂ∫¶Êó∂Âá∫ÈîôÔºåÂ∞ÜÂºÄÂßãÊñ∞Ê∏∏Êàè„ÄÇ");
                 clearGameState(); // Clear the bad state
                 initializeNewGameUI(); // Prepare for a new game
             }
         }
        function initializeNewGameUI() {
             console.log("Initializing UI for a new game.");
             // Reset game-specific state variables
             isGameStarted = false; conversationHistory = []; playerBaseAppearancePrompt = ''; aiBaseAppearancePrompt = ''; gameStoryPlan = null; spriteCache = {}; currentDialogueSegments = []; currentSegmentIndex = 0; currentTurnChoices = []; currentTurnParsedData = null;

             // Update UI elements to initial state based on current *config* values
             const canStart = currentApiKey && currentModel;
             let infoText = "";
             if (canStart) {
                 infoText = "API ËÆæÁΩÆÂ∑≤Âä†ËΩΩ„ÄÇ\n";
                 if (playerName) infoText += `Áé©ÂÆ∂ÂêçÁß∞: ${playerName}\n`; // Use state var which reflects loaded config
                 if (playerPersona) infoText += `Áé©ÂÆ∂ËÆæÂÆö: ${playerPersona.substring(0, 50)}...\n`;
                 if (currentAiPersona) infoText += `AI ËßíËâ≤: ${currentAiPersona.substring(0, 50)}...\n`;
                 if (playerStart) infoText += `ÂºÄÂ±ÄÊèêÁ§∫: ${playerStart.substring(0, 50)}...\n`;
                 infoText += "ÁÇπÂáª‚ÄúÂºÄÂßã‚ÄùËøõÂÖ•ÊïÖ‰∫ã„ÄÇ";
             } else {
                 infoText = "Ê¨¢ËøéÊù•Âà∞ AI Galgame ‰∫íÂä®ÊïÖ‰∫ãÔºÅ\nËØ∑ÁÇπÂáªÂè≥‰∏äËßíÁöÑ **‚öô** ËÆæÁΩÆ‰Ω†ÁöÑ API KeyÔºåÂπ∂ÈÄâÊã©‰∏Ä‰∏™Ê®°Âûã„ÄÇ\nÔºàÂèØÈÄâÔºâËÆæÁΩÆÁé©ÂÆ∂ÂêçÁß∞„ÄÅËÆæÂÆö„ÄÅ‰∏ä‰º†ÂõæÁâáÂíåÊúüÊúõÂºÄÂ±Ä„ÄÇ\nÂáÜÂ§áÂ•ΩÂêéÔºåÁÇπÂáª‚ÄúÂºÄÂßã‚ÄùÊåâÈíÆ„ÄÇ";
             }
             dialogueText.innerHTML = marked.parse(infoText); // Use marked for initial text too
             speakerName.textContent = "ÊóÅÁôΩ";
             choicesContainer.innerHTML = ''; // Clear choices area

             // Ensure sprites are hidden and cleared
             aiCharacterSprite.classList.add('hidden'); playerCharacterSprite.classList.add('hidden');
             aiCharacterSprite.removeAttribute('src'); playerCharacterSprite.removeAttribute('src');
             aiCharacterSprite.style.opacity = null; playerCharacterSprite.style.opacity = null;


             // Clear image previews in config panel (if user chose new game)
             clearImageUpload(playerImageUpload, playerImagePreview, clearPlayerImageBtn, (val) => playerImageBase64 = val);
             clearImageUpload(aiImageUpload, aiImagePreview, clearAiImageBtn, (val) => aiImageBase64 = val);

             updateStartButtonState(); // Set initial button state correctly
         }
        function handleNextOrStart() { // Wrapper for the main action button
              if (isLoading) return; // Prevent action while loading

              if (!isGameStarted) {
                  // If game hasn't started, this button starts a NEW game
                  clearGameState(); // Ensure no old state lingers if user manually starts
                  startGame_Galgame();
              } else {
                  // If game is started, this button advances dialogue segments
                  handleNext_Galgame();
              }
          }


        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
             console.log("DOM Content Loaded. Initializing...");
             loadConfig(); // Load API keys, model, personas etc. first

             // Check for saved game state AFTER loading config
             let savedState = null;
             try {
                 const savedStateString = localStorage.getItem(GAME_STATE_STORAGE_KEY);
                 if (savedStateString) {
                     savedState = JSON.parse(savedStateString);
                     // Basic validation
                     if (!savedState || !savedState.conversationHistory || typeof savedState.isGameStarted === 'undefined') {
                         console.warn("Invalid saved game state found, ignoring."); savedState = null; clearGameState();
                     } else { console.log("Valid saved game state found, timestamp:", new Date(savedState.timestamp)); }
                 }
             } catch (error) { console.error("Error loading/parsing saved game state:", error); savedState = null; clearGameState(); }

             // Decide whether to restore or initialize fresh
             if (savedState && savedState.isGameStarted) { // Only restore if game was actually started
                 showRestorePrompt(savedState); // Will call restoreGameState or initializeNewGameUI
             } else {
                 if (savedState && !savedState.isGameStarted) { clearGameState(); } // Clear useless save data
                 initializeNewGameUI(); // Initialize for a new game
             }

             // --- Attach Event Listeners ---
             if (toggleConfigBtn) toggleConfigBtn.addEventListener('click', toggleConfigPanel);
             if (closeConfigBtn) closeConfigBtn.addEventListener('click', toggleConfigPanel);
             if (saveConfigBtn) {
                 saveConfigBtn.addEventListener('click', () => {
                     saveConfig(); // Save config changes
                     if (!isGameStarted) {
                         // If config saved before game starts, clear potentially incompatible old game state
                         clearGameState();
                         initializeNewGameUI(); // Re-initialize UI based on new config
                     }
                     configPanel.classList.remove('visible'); // Close panel
                     console.log("Config saved and panel closed.");
                 });
             }
             if (fetchModelsBtn) fetchModelsBtn.addEventListener('click', fetchLLMModels);
             const testKeyButtonElement = document.getElementById('test-key-btn'); if (testKeyButtonElement) { testKeyButtonElement.addEventListener('click', testApiKey); }
             if (toggleApiKeyVisibilityBtn && apiKeyInput) { toggleApiKeyVisibilityBtn.addEventListener('click', () => { const isP = apiKeyInput.type === 'password'; apiKeyInput.type = isP ? 'text':'password'; toggleApiKeyVisibilityBtn.textContent = isP ? 'üëÅÔ∏è‚Äçüó®Ô∏è':'üëÅÔ∏è'; }); }
             // Config inputs trigger save on change
             if(modelSelect) modelSelect.addEventListener('change', saveConfig); if(aiPersonaInput) aiPersonaInput.addEventListener('input', saveConfig); if(apiKeyInput) apiKeyInput.addEventListener('input', saveConfig); if(apiUrlInput) apiUrlInput.addEventListener('input', saveConfig); if(playerNameInput) playerNameInput.addEventListener('input', saveConfig); if(playerPersonaInput) playerPersonaInput.addEventListener('input', saveConfig); if(playerStartInput) playerStartInput.addEventListener('input', saveConfig);
             // Image Upload Listeners
             if (playerImageUpload && playerImagePreview && clearPlayerImageBtn) { playerImageUpload.addEventListener('change', () => handleImageUpload(playerImageUpload, playerImagePreview, clearPlayerImageBtn, (val) => playerImageBase64 = val)); clearPlayerImageBtn.addEventListener('click', () => clearImageUpload(playerImageUpload, playerImagePreview, clearPlayerImageBtn, (val) => playerImageBase64 = val)); }
             if (aiImageUpload && aiImagePreview && clearAiImageBtn) { aiImageUpload.addEventListener('change', () => handleImageUpload(aiImageUpload, aiImagePreview, clearAiImageBtn, (val) => aiImageBase64 = val)); clearAiImageBtn.addEventListener('click', () => clearImageUpload(aiImageUpload, aiImagePreview, clearAiImageBtn, (val) => aiImageBase64 = val)); }
             // Game Control Listeners
             if (nextButton) { nextButton.addEventListener('click', handleNextOrStart); } // Use the wrapper function
             if (toggleHistoryBtn) toggleHistoryBtn.addEventListener('click', toggleHistoryPanel);
             if (closeHistoryBtn) closeHistoryBtn.addEventListener('click', toggleHistoryPanel);

             console.log("All event listeners attached.");
        });

    </script>
    </body>
    </html>