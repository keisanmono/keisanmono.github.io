<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ’– AI Galgame | ğŸŒ¸ æˆ‘çš„äºŒæ¬¡å…ƒå°çª ğŸŒ¸</title>
    <link rel="stylesheet" href="css/style.css"> <!-- ä¸»ç«™æ ·å¼é“¾æ¥ -->
    <!-- Marked.js ç”¨äºMarkdownæ¸²æŸ“ -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- DOMPurify ç”¨äºå®‰å…¨å¤„ç† -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.10/purify.min.js"></script>
    <!-- KaTeX CSS (ç§»é™¤ integrity å’Œ crossorigin) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">

    <!-- KaTeX JS (ç§»é™¤ integrity å’Œ crossorigin) -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>

    <!-- KaTeX Auto-render Extension (ç§»é™¤ integrity å’Œ crossorigin) -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"></script>
    <style>
        /* --- Galgame ä¸“ç”¨æ ·å¼ --- */
        /* ä¸»å®¹å™¨ */
        #galgame-container {
            position: relative;
            width: 100%;
            height: calc(100vh - 100px);
            min-height: 500px;
            overflow: hidden;
            border-radius: 15px;
            box-shadow: 0 5px 20px var(--galgame-container-shadow, rgba(0, 0, 0, 0.2));
            margin-top: 20px;
        }

        /* èƒŒæ™¯å›¾ç‰‡ */
        #game-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--content-bg);
            background-size: cover;
            background-position: center;
            z-index: 1;
            transition: background-image 0.8s ease-in-out;
        }

        /* --- è§’è‰²ç²¾çµåŒºåŸŸ --- */
        .character-area {
            position: absolute;
            bottom: 5%;
            height: 65%;
            width: auto;
            max-width: 40%;
            z-index: 3;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
        }

        /* AIè§’è‰²(å³ä¾§) */
        #ai-character-area {
            right: 5%;
            transform: none;
        }

        /* ç©å®¶è§’è‰²(å·¦ä¾§) */
        #player-character-area {
            left: 5%;
            transform: none;
        }

        .character-sprite {
            display: block;
            max-height: 100%;
            max-width: 100%;
            height: auto;
            width: auto;
            object-fit: contain;
            filter: drop-shadow(3px 5px 8px rgba(0, 0, 0, 0.4));
            transition: transform 0.4s ease, opacity 0.5s ease;
            opacity: 1;
        }

        /* éšè—ç²¾çµçš„ç±» */
        .character-sprite.hidden {
            opacity: 0;
            transform: scale(0.95);
        }

        /* AIç²¾çµçš„ç‰¹å®šID */
        #ai-character-sprite {}

        /* ç©å®¶ç²¾çµçš„ç‰¹å®šID */
        #player-character-sprite {
            /* æ°´å¹³ç¿»è½¬(å¦‚éœ€è¦) */
            /* transform: scaleX(-1); */
        }


        /* å¯¹è¯æ¡† */
        #dialogue-box {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 950px;
            min-height: 140px;
            max-height: 38%;
            background: var(--galgame-dialogue-bg, rgba(0, 0, 0, 0.7));
            backdrop-filter: var(--galgame-dialogue-backdrop-filter, blur(10px));
            border-radius: 12px;
            border: 1px solid var(--galgame-dialogue-border, rgba(255, 255, 255, 0.2));
            padding: 20px 30px;
            color: var(--galgame-dialogue-text-color, #fff);
            z-index: 4;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            scrollbar-width: thin;
            scrollbar-color: var(--galgame-scrollbar-thumb-bg, rgba(255, 255, 255, 0.3)) var(--galgame-scrollbar-track-bg, rgba(0, 0, 0, 0.2));
        }

        #dialogue-box::-webkit-scrollbar {
            width: 8px;
        }

        #dialogue-box::-webkit-scrollbar-track {
            background: var(--galgame-scrollbar-track-bg, rgba(0, 0, 0, 0.2));
            border-radius: 4px;
        }

        #dialogue-box::-webkit-scrollbar-thumb {
            background-color: var(--galgame-scrollbar-thumb-bg, rgba(255, 255, 255, 0.3));
            border-radius: 4px;
            border: 1px solid rgba(0, 0, 0, 0.3);
        }

        #dialogue-box::-webkit-scrollbar-thumb:hover {
            background-color: var(--galgame-scrollbar-thumb-hover-bg, rgba(255, 255, 255, 0.5));
        }

        #speaker-name {
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--galgame-speaker-name-color, #ffcc99);
            font-size: 1.15em;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        #dialogue-text {
            line-height: 1.7;
            font-size: 1.05em;
        }

        /* Markdownæ ·å¼ */
        #dialogue-text p {
            margin-bottom: 0.8em;
        }

        #dialogue-text h1,
        #dialogue-text h2,
        #dialogue-text h3 {
            margin-top: 0.5em;
            margin-bottom: 0.3em;
            color: var(--galgame-config-link-color, #88aaff);
        }

        #dialogue-text strong {
            color: var(--galgame-speaker-name-color, #ffcc99);
        }

        #dialogue-text em {
            color: #90ee90;
        }

        #dialogue-text ul,
        #dialogue-text ol {
            padding-left: 25px;
            margin-bottom: 0.8em;
        }

        #dialogue-text li {
            margin-bottom: 0.3em;
        }

        #dialogue-text code {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
            color: #f0f0f0;
        }

        #dialogue-text pre {
            background-color: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 0.8em;
        }

        #dialogue-text pre code {
            background: none;
            padding: 0;
        }

        #dialogue-text blockquote {
            border-left: 3px solid var(--galgame-control-btn-bg, #6495ed);
            padding-left: 10px;
            margin: 0.8em 0;
            color: #ccc;
            font-style: italic;
        }

        #dialogue-text a {
            color: var(--galgame-config-link-color, #88aaff);
            text-decoration: underline;
        }

        #dialogue-text a:hover {
            filter: brightness(1.2);
        }

        /* æ¸¸æˆæ§åˆ¶ */
        #game-controls {
            position: absolute;
            bottom: 25px;
            right: 30px;
            z-index: 5;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .control-button {
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            background: var(--galgame-control-btn-bg, rgba(100, 149, 237, 0.7));
            color: var(--galgame-control-btn-color, #fff);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-weight: 500;
            box-shadow: 0 4px 10px var(--shadow-color-medium, rgba(0, 0, 0, 0.3));
            border: 1px solid var(--galgame-control-btn-border, rgba(255, 255, 255, 0.15));
            backdrop-filter: blur(3px);
        }

        .control-button:hover:not(:disabled) {
            background: var(--galgame-control-btn-hover-bg, rgba(130, 169, 247, 0.85));
            box-shadow: 0 6px 15px var(--shadow-color-dark, rgba(0, 0, 0, 0.4));
            transform: translateY(-2px);
        }

        .control-button:disabled {
            background: var(--text-color-lighter, #999);
            cursor: not-allowed;
            box-shadow: none;
            opacity: 0.7;
        }

        #toggle-history-btn {
            background: var(--galgame-history-btn-bg, rgba(75, 75, 75, 0.7));
            color: var(--galgame-history-btn-color, #fff);
        }

        #toggle-history-btn:hover:not(:disabled) {
            background: var(--galgame-history-btn-hover-bg, rgba(95, 95, 95, 0.85));
        }

        /* é€‰æ‹©å®¹å™¨ */
        #choices-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }

        .choice-button {
            display: block;
            width: 100%;
            text-align: left;
            padding: 10px 15px;
            border: 1px solid var(--galgame-choice-btn-border, rgba(255, 255, 255, 0.2));
            border-radius: 8px;
            background: var(--galgame-choice-btn-bg, rgba(40, 40, 40, 0.8));
            color: var(--galgame-choice-btn-color, #fff);
            cursor: pointer;
            transition: background-color 0.3s ease;
            font-size: 0.95em;
        }

        .choice-button:hover {
            background: var(--galgame-choice-btn-hover-bg, rgba(80, 80, 80, 0.9));
        }

        /* é…ç½®é¢æ¿å’Œå†…å®¹ */
        #config-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 350px;
            background: var(--galgame-config-bg, rgba(30, 30, 30, 0.85));
            backdrop-filter: var(--galgame-config-backdrop-filter, blur(10px));
            border-radius: 8px;
            padding: 20px;
            z-index: 10;
            color: var(--galgame-config-text-color, #e0e0e0);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--galgame-config-border, rgba(255, 255, 255, 0.15));
            display: none;
            font-size: 0.9em;
            max-height: 80vh;
            overflow-y: auto;
        }

        #config-panel.visible {
            display: block;
        }

        #config-panel h3 {
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
            color: var(--galgame-config-link-color, #88aaff);
        }

        #config-panel .form-group {
            margin-bottom: 15px;
        }

        #config-panel label {
            color: var(--galgame-config-label-color, #cccccc);
            margin-bottom: 5px;
            font-size: 0.95em;
            display: block;
        }

        #config-panel input[type="text"],
        #config-panel input[type="password"],
        #config-panel input[type="url"],
        #config-panel .select-wrapper select,
        #config-panel textarea {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid var(--galgame-config-input-border, rgba(255, 255, 255, 0.2));
            border-radius: 5px;
            background: var(--galgame-config-input-bg, rgba(50, 50, 50, 0.6));
            color: var(--galgame-config-text-color, #e0e0e0);
            font-size: 1em;
            box-sizing: border-box;
            font-family: inherit;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
        }

        #config-panel textarea {
            min-height: 60px;
        }

        #config-panel .select-wrapper::after {
            color: var(--galgame-config-label-color, #cccccc);
        }

        #config-panel .config-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        #config-panel button {
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-size: 0.9em;
        }

        #save-config-btn {
            background-color: var(--galgame-save-btn-bg, #4caf50);
            color: white;
        }

        #save-config-btn:hover {
            background-color: var(--galgame-save-btn-hover-bg, #3d8b40);
        }

        #close-config-btn {
            background-color: var(--galgame-close-btn-bg, #f44336);
            color: white;
        }

        #close-config-btn:hover {
            background-color: var(--galgame-close-btn-hover-bg, #d32f2f);
        }

        #key-status {
            font-size: 0.85em;
            margin-top: 5px;
            display: inline-block;
            height: 1.2em;
        }

        #key-status.testing {
            color: #ffc107;
        }

        #key-status.valid {
            color: #28a745;
        }

        #key-status.invalid {
            color: #dc3545;
        }

        #key-status.error {
            color: #ff8aae;
        }

        #toggle-config-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 15;
            background: var(--button-glass-bg, rgba(255, 255, 255, 0.15));
            color: var(--button-primary-text, #fff);
            border: 1px solid var(--border-color-light, rgba(255, 255, 255, 0.2));
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 20px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #toggle-config-btn:hover {
            background: var(--button-glass-hover-bg, rgba(255, 255, 255, 0.25));
            transform: scale(1.1) rotate(45deg);
        }

        /* åŠ è½½å’Œé”™è¯¯è¦†ç›–å±‚ */
        #game-loading-overlay {
            background: var(--galgame-loading-bg, rgba(0, 0, 0, 0.7));
            color: var(--galgame-loading-text-color, #fff);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9;
            display: none;
            justify-content: center;
            align-items: center;
            font-size: 1.2em;
        }

        #game-loading-overlay.visible {
            display: flex;
        }

        #game-loading-overlay span {
            animation: pulse 1.5s infinite ease-in-out;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        #game-error-message {
            background: var(--galgame-error-bg, rgba(220, 53, 69, 0.9));
            color: var(--galgame-error-text-color, #fff);
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 20;
            display: none;
            max-width: 80%;
            text-align: center;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }

        /* å†å²é¢æ¿ */
        #history-panel {
            background: var(--galgame-history-panel-bg, rgba(30, 30, 30, 0.85));
            backdrop-filter: var(--galgame-history-panel-backdrop-filter, blur(10px));
            border: 1px solid var(--galgame-history-panel-border, rgba(255, 255, 255, 0.15));
            color: var(--galgame-history-panel-text-color, #e0e0e0);
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 70%;
            max-width: 700px;
            height: 70%;
            max-height: 600px;
            border-radius: 10px;
            padding: 25px;
            z-index: 12;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
            display: none;
            flex-direction: column;
        }

        #history-panel.visible {
            display: flex;
        }

        #history-panel h3 {
            color: var(--galgame-history-panel-title-color, #88aaff);
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
            flex-shrink: 0;
        }

        #history-content {
            flex-grow: 1;
            overflow-y: auto;
            padding-right: 10px;
            margin-bottom: 15px;
            line-height: 1.6;
            scrollbar-color: var(--galgame-history-scrollbar-thumb-bg, rgba(255, 255, 255, 0.3)) var(--galgame-history-scrollbar-track-bg, rgba(0, 0, 0, 0.2));
        }

        #history-content::-webkit-scrollbar {
            width: 8px;
        }

        #history-content::-webkit-scrollbar-track {
            background: var(--galgame-history-scrollbar-track-bg, rgba(0, 0, 0, 0.2));
            border-radius: 4px;
        }

        #history-content::-webkit-scrollbar-thumb {
            background-color: var(--galgame-history-scrollbar-thumb-bg, rgba(255, 255, 255, 0.3));
            border-radius: 4px;
            border: 1px solid rgba(0, 0, 0, 0.5);
        }

        #history-content::-webkit-scrollbar-thumb:hover {
            background-color: var(--galgame-history-scrollbar-thumb-hover-bg, rgba(255, 255, 255, 0.5));
        }

        #history-content .history-entry {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.15);
        }

        #history-content .history-entry:last-child {
            border-bottom: none;
        }

        #history-content .history-role-user {
            font-weight: bold;
            color: var(--galgame-history-role-user-color, #88cc88);
            margin-bottom: 5px;
        }

        #history-content .history-role-model {
            font-weight: bold;
            color: var(--galgame-history-role-model-color, #88aaff);
            margin-bottom: 5px;
        }

        /* åµŒå¥—å†å²æ–‡æœ¬ç‰‡æ®µ */
        #history-content .history-dialogue-segment {
            margin-left: 10px;
            margin-bottom: 5px;
            font-size: 0.98em;
        }

        #history-content .history-dialogue-segment .segment-speaker {
            font-weight: bold;
            color: var(--galgame-speaker-name-color, #ffcc99);
            margin-right: 5px;
        }

        #history-content .history-dialogue-segment .segment-text {}

        #history-content .history-dialogue-segment .segment-text p {
            margin-bottom: 0.3em;
        }

        #close-history-btn {
            background-color: var(--galgame-history-close-btn-bg, #6c757d);
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-size: 0.9em;
            align-self: center;
            flex-shrink: 0;
        }

        #close-history-btn:hover {
            background-color: var(--galgame-history-close-btn-hover-bg, #5a6268);
        }

        /* é…ç½®åŒºåŸŸæ ·å¼ */
        .config-section {
            border: 1px dashed var(--galgame-config-input-border, rgba(255, 255, 255, 0.2));
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            background: rgba(10, 10, 10, 0.1);
        }

        body.theme-dark .config-section {
            background: rgba(200, 200, 220, 0.05);
        }

        .config-section h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: var(--galgame-config-link-color, #88aaff);
            border-bottom: 1px solid var(--galgame-config-input-border, rgba(255, 255, 255, 0.2));
            padding-bottom: 5px;
        }

        .form-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .api-key-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .api-key-wrapper input {
            padding-right: 45px;
            flex-grow: 1;
        }

        #toggle-api-key-visibility {
            position: absolute;
            right: 1px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 10px;
            color: var(--galgame-config-text-color, #e0e0e0);
            opacity: 0.5;
        }

        #toggle-api-key-visibility:hover {
            opacity: 1;
            color: var(--galgame-config-text-color, #e0e0e0);
        }

        .api-url-wrapper {
            display: flex;
            gap: 0;
            align-items: stretch;
        }

        .api-url-wrapper input[type="url"] {
            flex-grow: 1;
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
            border-right: none;
        }

        #fetch-models-btn {
            flex-shrink: 0;
            padding: 8px 15px;
            border: 1px solid var(--galgame-config-input-border, rgba(255, 255, 255, 0.2));
            border-left: none;
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
            background: var(--galgame-control-btn-bg, rgba(100, 149, 237, 0.7));
            color: var(--galgame-control-btn-color, #fff);
            cursor: pointer;
            transition: background 0.2s ease;
        }

        #fetch-models-btn:hover {
            background: var(--galgame-control-btn-hover-bg, rgba(130, 169, 247, 0.85));
        }

        #fetch-models-btn:disabled {
            background: rgba(255, 255, 255, 0.1);
            color: var(--galgame-config-label-color, #cccccc);
            box-shadow: none;
            opacity: 0.5;
        }

        #model-loading-indicator {
            margin-left: 8px;
            color: var(--galgame-config-label-color, #cccccc);
            font-size: 1.2em;
            vertical-align: middle;
            display: none;
        }

        .input-hint {
            font-size: 0.85em;
            color: var(--galgame-config-label-color, #cccccc);
            display: block;
            margin-top: 5px;
            opacity: 0.8;
        }

        /* å›¾ç‰‡ä¸Šä¼ æ ·å¼ */
        .image-upload-section {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
            border: 1px solid var(--galgame-config-input-border, rgba(255, 255, 255, 0.2));
            padding: 10px;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.1);
        }

        body.theme-dark .image-upload-section {
            background: rgba(255, 255, 255, 0.05);
        }

        .image-upload-section input[type="file"] {
            padding: 5px;
            font-size: 0.9em;
            background: rgba(255, 255, 255, 0.1);
            border: 1px dashed var(--galgame-config-input-border, rgba(255, 255, 255, 0.2));
            flex-grow: 1;
            cursor: pointer;
            color: var(--galgame-config-label-color, #cccccc);
        }

        .image-upload-section input[type="file"]::file-selector-button {
            padding: 6px 10px;
            border: none;
            background-color: var(--galgame-control-btn-bg, rgba(100, 149, 237, 0.7));
            color: var(--galgame-control-btn-color, #fff);
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            font-size: 0.9em;
            transition: background-color 0.2s ease;
        }

        .image-upload-section input[type="file"]::file-selector-button:hover {
            background-color: var(--galgame-control-btn-hover-bg, rgba(130, 169, 247, 0.85));
        }

        .image-preview-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .image-preview {
            max-width: 80px;
            max-height: 80px;
            height: auto;
            width: auto;
            border-radius: 4px;
            border: 1px solid var(--galgame-config-input-border, rgba(255, 255, 255, 0.2));
            object-fit: cover;
            display: none;
            /* é»˜è®¤éšè— */
        }

        .clear-image-btn {
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 3px 8px;
            font-size: 0.8em;
            cursor: pointer;
            display: none;
            /* é»˜è®¤éšè— */
        }

        .clear-image-btn:hover {
            background: #5a6268;
        }

        /* æ•…äº‹è¿›åº¦æ¡ */
        .story-progress-bar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 18px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 9px;
            overflow: hidden;
            z-index: 5;
            border: 1px solid var(--galgame-dialogue-border, rgba(255, 255, 255, 0.2));
        }

        .story-progress-bar .progress-inner {
            height: 100%;
            background: linear-gradient(to right, #4a8af4, #9c59b6);
            transition: width 0.5s ease;
        }

        .story-progress-bar .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            color: white;
            text-shadow: 0px 0px 2px rgba(0, 0, 0, 0.8);
            white-space: nowrap;
        }

        /* ç« èŠ‚æ ‡è®° */
        .chapter-marker {
            display: flex;
            align-items: center;
            margin: 20px 0;
            gap: 15px;
        }

        .chapter-line {
            height: 1px;
            background: rgba(255, 255, 255, 0.3);
            flex-grow: 1;
        }

        .chapter-title {
            font-weight: bold;
            color: #ffcc99;
            font-size: 1.1em;
            white-space: nowrap;
            text-shadow: 0px 0px 3px rgba(0, 0, 0, 0.5);
        }

        /* é€‰æ‹©å½±å“æç¤º */
        .choice-impact {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            color: white;
            font-size: 0.9em;
            z-index: 10;
            opacity: 1;
            transition: opacity 1s ease;
        }

        .choice-impact.fadeout {
            opacity: 0;
        }

        .choice-impact.relationship-up {
            background: rgba(46, 204, 113, 0.8);
        }

        .choice-impact.relationship-down {
            background: rgba(231, 76, 60, 0.8);
        }

        .choice-impact.story-branch {
            background: rgba(52, 152, 219, 0.8);
        }

        .choice-impact.progress-significant {
            background: rgba(155, 89, 182, 0.8);
        }

        /* æ•…äº‹ç»“å±€é¢æ¿ */
        .story-ending-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 600px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            z-index: 20;
            color: white;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
            animation: fadeIn 1s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .ending-header {
            margin-bottom: 20px;
        }

        .ending-header h2 {
            font-size: 1.8em;
            margin-bottom: 10px;
            color: #ffcc99;
        }

        .ending-type {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
        }

        .ending-type.good {
            background: rgba(46, 204, 113, 0.8);
        }

        .ending-type.neutral {
            background: rgba(241, 196, 15, 0.8);
        }

        .ending-type.bad {
            background: rgba(231, 76, 60, 0.8);
        }

        .ending-content {
            line-height: 1.7;
            margin-bottom: 30px;
            text-align: left;
            max-height: 40vh;
            overflow-y: auto;
            padding: 10px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
        }

        .ending-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .ending-buttons button {
            padding: 10px 25px;
            border: none;
            border-radius: 25px;
            background: rgba(100, 149, 237, 0.7);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
        }

        .ending-buttons button:hover {
            background: rgba(130, 169, 247, 0.85);
            transform: translateY(-2px);
        }

        .restart-button {
            background: #4a8af4 !important;
        }

        .share-button {
            background: #9c59b6 !important;
        }

        /* èŒƒå›´è¾“å…¥æ¡†æ ·å¼ */
        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            height: 6px;
            border-radius: 3px;
            margin: 10px 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--galgame-control-btn-bg, rgba(100, 149, 237, 0.7));
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--galgame-control-btn-bg, rgba(100, 149, 237, 0.7));
            cursor: pointer;
            border: none;
        }

        .range-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            color: var(--galgame-config-label-color, #cccccc);
        }

        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 768px) {
            #galgame-container {
                height: calc(100vh - 80px);
            }

            .character-area {
                height: 55%;
                max-width: 45%;
            }

            #dialogue-box {
                width: 95%;
                min-height: 120px;
                max-height: 45%;
                padding: 15px 20px;
            }

            #speaker-name {
                font-size: 1.05em;
            }

            #dialogue-text {
                font-size: 0.95em;
            }

            #game-controls {
                bottom: 15px;
                right: 15px;
                gap: 8px;
            }

            .control-button {
                padding: 8px 15px;
                font-size: 0.9em;
            }

            #history-panel {
                width: 90%;
                height: 75%;
            }

            #config-panel {
                width: 90%;
                max-width: 350px;
                right: 50%;
                transform: translateX(50%);
                top: 5%;
            }

            #toggle-config-btn {
                top: 10px;
                right: 10px;
                width: 35px;
                height: 35px;
                font-size: 18px;
            }

            .image-upload-section {
                flex-direction: column;
                align-items: stretch;
            }

            .image-preview {
                max-width: 60px;
                max-height: 60px;
            }

            .story-progress-bar {
                width: 90%;
            }
        }

        @media (max-width: 480px) {
            .character-area {
                height: 50%;
                max-width: 55%;
            }

            #ai-character-area {
                right: 2%;
            }

            #player-character-area {
                left: 2%;
            }

            #dialogue-box {
                max-height: 50%;
                padding: 10px 15px;
            }

            #speaker-name {
                font-size: 1em;
            }

            #dialogue-text {
                font-size: 0.9em;
            }

            .control-button {
                padding: 6px 12px;
                font-size: 0.85em;
            }

            #history-panel {
                width: 95%;
                height: 80%;
                padding: 15px;
            }

            #config-panel {
                padding: 15px;
                width: 95%;
            }

            .image-preview {
                max-width: 50px;
                max-height: 50px;
            }

            #game-controls {
                flex-direction: column;
                right: 10px;
                bottom: auto;
                top: 60px;
                gap: 5px;
            }

            .choice-button {
                padding: 12px 15px;
                margin-bottom: 8px;
            }

            .story-ending-panel {
                width: 95%;
                padding: 20px;
            }
        }
    </style>
</head>

<body>
    <!-- èƒŒæ™¯ã€ä¾§è¾¹æ ã€åˆ‡æ¢æŒ‰é’® -->
    <div class="background"></div>
    <div id="sidebar">
        <nav id="sidebar-nav">
            <a href="index.html">ğŸ  ä¸»é¡µ</a>
            <a href="about.html">âœ¨ å…³äºæˆ‘</a>
            <a href="blog_page1.html">ğŸ“ åšå®¢</a>
            <a href="contact.html">ğŸ’Œ è”ç³»æˆ‘</a>
            <a href="download.html">ğŸ“ æ–‡ä»¶ä¸‹è½½</a>
            <a href="ai_draw.html">ğŸ¨ AI ä½œç”»</a>
            <a href="tno_generator.html">ğŸ“œ TNOäº‹ä»¶ç”Ÿæˆ</a>
            <a href="if_game.html">ğŸŒŒ AI äº’åŠ¨å°è¯´</a>
            <a href="ai_rpg.html">ğŸ’– AI Galgame</a>
        </nav>
        <div class="theme-switcher">
            <h4>åˆ‡æ¢ä¸»é¢˜:</h4>
            <div class="theme-buttons-container">
                <button data-theme="pastel" class="theme-button">ğŸŒ¸ ç²‰å½©æ¢¦å¢ƒ</button>
                <button data-theme="dark" class="theme-button">ğŸŒ™ åˆå¤œæ¨±è½</button>
            </div>
        </div>
    </div>
    <button id="toggle-btn">â˜°</button>

    <!-- ä¸»è¦å†…å®¹åŒºåŸŸ -->
    <div class="content scroll-container">
        <header>
            <h1>AI Galgame äº’åŠ¨æ•…äº‹</h1>
            <button id="toggle-config-btn" title="è®¾ç½®">âš™</button> <!-- è®¾ç½®åˆ‡æ¢ -->
        </header>

        <main>
            <!-- é…ç½®é¢æ¿ (æ·»åŠ äº†æ•…äº‹è®¾ç½®) -->
            <div id="config-panel">
                <!-- ç©å®¶è®¾ç½®éƒ¨åˆ† -->
                <div class="config-section">
                    <h4>ç©å®¶è®¾å®š</h4>
                    <div class="form-group">
                        <label for="player-name-input">ä½ çš„åå­—:</label>
                        <input type="text" id="player-name-input" placeholder="è¾“å…¥ä½ æƒ³ä½¿ç”¨çš„åå­—" aria-required="true">
                    </div>
                    <div class="form-group">
                        <label for="player-persona-input">ä½ çš„è§’è‰²ç®€ä»‹ (å¯é€‰ï¼Œè‹¥ä¸Šä¼ å›¾ç‰‡åˆ™ä¼˜å…ˆä½¿ç”¨å›¾ç‰‡):</label>
                        <textarea id="player-persona-input" rows="2"
                            placeholder="ç®€å•æè¿°ä½ çš„è§’è‰² (ä¾‹å¦‚ï¼šä¸€ä¸ªæœ‰ç‚¹å†…å‘ä½†å–„è‰¯çš„é«˜ä¸­ç”Ÿ)"></textarea>
                    </div>
                    <!-- ç©å®¶å›¾ç‰‡ä¸Šä¼  -->
                    <div class="form-group">
                        <label for="player-image-upload">ä¸Šä¼ ä½ çš„è§’è‰²å›¾ç‰‡ (å¯é€‰):</label>
                        <div class="image-upload-section">
                            <input type="file" id="player-image-upload" accept="image/png, image/jpeg, image/webp">
                            <div class="image-preview-container">
                                <img id="player-image-preview" class="image-preview" src="#" alt="ç©å®¶å›¾ç‰‡é¢„è§ˆ">
                                <button id="clear-player-image-btn" class="clear-image-btn">æ¸…é™¤</button>
                            </div>
                        </div>
                        <small class="input-hint">ä¸Šä¼ å›¾ç‰‡åï¼ŒAIä¼šå°è¯•æ ¹æ®å›¾ç‰‡ç”Ÿæˆå¤–è²Œæè¿°ã€‚</small>
                    </div>
                    <div class="form-group">
                        <label for="player-start-input">æœŸæœ›çš„å¼€å±€:</label>
                        <textarea id="player-start-input" rows="2" placeholder="æè¿°ä½ æƒ³è¦çš„å¼€åœºåœºæ™¯ (ä¾‹å¦‚ï¼šåœ¨æ–°å­¦æ ¡çš„ç¬¬ä¸€å¤©è¿·è·¯äº†)"></textarea>
                    </div>
                </div>

                <!-- æ•…äº‹è®¾ç½®éƒ¨åˆ† (æ–°å¢) -->
                <div class="config-section">
                    <h4>æ•…äº‹è®¾ç½®</h4>
                    <div class="form-group">
                        <label for="story-theme-select">æ•…äº‹ä¸»é¢˜:</label>
                        <div class="select-wrapper">
                            <select id="story-theme-select">
                                <option value="romance">æ‹çˆ±æ•…äº‹</option>
                                <option value="mystery">æ‚¬ç–‘æ¨ç†</option>
                                <option value="fantasy">å¥‡å¹»å†’é™©</option>
                                <option value="school">æ ¡å›­æ—¥å¸¸</option>
                                <option value="scifi">ç§‘å¹»æœªæ¥</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="story-length-select">æ•…äº‹é•¿åº¦:</label>
                        <div class="select-wrapper">
                            <select id="story-length-select">
                                <option value="short">çŸ­ç¯‡ (5-10åˆ†é’Ÿ)</option>
                                <option value="medium" selected>ä¸­ç¯‡ (10-20åˆ†é’Ÿ)</option>
                                <option value="long">é•¿ç¯‡ (20-30åˆ†é’Ÿ)</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="story-complexity-range">å‰§æƒ…åˆ†æ”¯å¤æ‚åº¦:</label>
                        <input type="range" id="story-complexity-range" min="1" max="5" value="3">
                        <div class="range-labels">
                            <span>ç®€å•</span>
                            <span>å¤æ‚</span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="character-template-select">é€‰æ‹©é¢„è®¾è§’è‰²æ¨¡æ¿(å¯é€‰):</label>
                        <div class="select-wrapper">
                            <select id="character-template-select">
                                <option value="" selected>-- é€‰æ‹©è§’è‰²æ¨¡æ¿ --</option>
                                <option value="tsundere">å‚²å¨‡åŒå­¦</option>
                                <option value="kuudere">å†·é…·å­¦å§</option>
                                <option value="childhood">é’æ¢…ç«¹é©¬</option>
                                <option value="teacher">ç¥ç§˜è€å¸ˆ</option>
                                <option value="alien">å¼‚ä¸–ç•Œæ¥å®¢</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- AI & APIè®¾ç½®éƒ¨åˆ† -->
                <div class="config-section">
                    <h4>AI & API è®¾ç½®</h4>
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="galgame-persona">AI å¯¹æ‰‹è§’è‰²è®¾å®š (å¯é€‰ï¼Œè‹¥ä¸Šä¼ å›¾ç‰‡åˆ™ä¼˜å…ˆä½¿ç”¨å›¾ç‰‡):</label>
                            <textarea id="galgame-persona" rows="2"
                                placeholder="ä½ å¸Œæœ›AIæ‰®æ¼”ä»€ä¹ˆè§’è‰²ï¼Ÿ(ä¾‹å¦‚ï¼šä¸€ä¸ªå‚²å¨‡çš„åŒç­åŒå­¦ï¼Œåå«[äºšé‡Œæ²™]...)"></textarea>
                        </div>
                        <!-- AI å›¾ç‰‡ä¸Šä¼  -->
                        <div class="form-group">
                            <label for="ai-image-upload">ä¸Šä¼ AIè§’è‰²å›¾ç‰‡ (å¯é€‰):</label>
                            <div class="image-upload-section">
                                <input type="file" id="ai-image-upload" accept="image/png, image/jpeg, image/webp">
                                <div class="image-preview-container">
                                    <img id="ai-image-preview" class="image-preview" src="#" alt="AIå›¾ç‰‡é¢„è§ˆ">
                                    <button id="clear-ai-image-btn" class="clear-image-btn">æ¸…é™¤</button>
                                </div>
                            </div>
                            <small class="input-hint">ä¸Šä¼ å›¾ç‰‡åï¼ŒAIä¼šå°è¯•æ ¹æ®å›¾ç‰‡ç”Ÿæˆè¯¥è§’è‰²çš„å¤–è²Œæè¿°ã€‚</small>
                        </div>
                        <!-- APIå¯†é’¥ã€URLã€æ¨¡å‹ -->
                        <div class="form-group">
                            <label for="llm-api-key">API å¯†é’¥:</label>
                            <div class="api-key-wrapper">
                                <input type="password" id="llm-api-key" placeholder="è¾“å…¥ API Key (ä¾‹å¦‚ Gemini)">
                                <button id="toggle-api-key-visibility" title="åˆ‡æ¢å¯è§æ€§">ğŸ‘ï¸</button>
                            </div>
                            <span id="key-status"></span>
                            <button id="test-key-btn" class="control-button"
                                style="padding: 6px 10px; font-size: 0.8em; margin-top: 5px;">æµ‹è¯• Key</button>
                        </div>
                        <div class="form-group">
                            <label for="llm-api-url">API åŸºç¡€åœ°å€:</label>
                            <div class="api-url-wrapper">
                                <input type="url" id="llm-api-url"
                                    placeholder="ä¾‹å¦‚: https://generativelanguage.googleapis.com"
                                    value="https://generativelanguage.googleapis.com">
                                <button id="fetch-models-btn" title="è·å–å¯ç”¨æ¨¡å‹åˆ—è¡¨">è·å–åˆ—è¡¨</button>
                            </div>
                            <small class="input-hint">(Google: ç•™ç©ºæˆ–å¡« ...googleapis.com; OpenAIå…¼å®¹: å¡«åˆ° /v1/ ç»“å°¾)</small>
                        </div>
                        <div class="form-group">
                            <label for="llm-model-select">é€‰æ‹© LLM æ¨¡å‹:</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <div class="select-wrapper" style="flex-grow: 1;">
                                    <select id="llm-model-select" disabled>
                                        <option value="" disabled selected>-- è¯·å…ˆè·å–æ¨¡å‹åˆ—è¡¨ --</option>
                                    </select>
                                </div>
                                <span id="model-loading-indicator" title="æ­£åœ¨åŠ è½½æ¨¡å‹...">ğŸ”„</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="config-buttons">
                    <button id="save-config-btn">ä¿å­˜è®¾ç½®</button>
                    <button id="close-config-btn">å…³é—­</button>
                </div>
            </div>

            <!-- Galgame UIå®¹å™¨ (æ·»åŠ äº†æ•…äº‹è¿›åº¦æ¡) -->
            <div id="galgame-container">
                <div id="game-background"></div>
                <!-- æ·»åŠ æ•…äº‹è¿›åº¦æ¡ -->
                <div id="story-progress" class="story-progress-bar" style="display: none;">
                    <div class="progress-inner" style="width: 0%"></div>
                    <span class="progress-text">æ•…äº‹è¿›åº¦: 0% | ç¬¬1å¹• | å‰©ä½™å›åˆ: 0</span>
                </div>
                <div id="player-character-area" class="character-area">
                    <img id="player-character-sprite" src="#" alt="ç©å®¶è§’è‰²" class="character-sprite hidden">
                </div>
                <div id="ai-character-area" class="character-area">
                    <img id="ai-character-sprite" src="#" alt="AIè§’è‰²" class="character-sprite hidden">
                </div>
                <div id="dialogue-box">
                    <div id="speaker-name">æ—ç™½</div>
                    <div id="dialogue-text">åœ¨è¿™é‡Œè®¾ç½®ç©å®¶åç§°ã€è®¾å®šå’ŒæœŸæœ›å¼€å±€åï¼Œç‚¹å‡»"å¼€å§‹"ã€‚</div>
                    <div id="choices-container"></div>
                </div>
                <div id="game-controls">
                    <button id="toggle-history-btn" class="control-button" title="æŸ¥çœ‹å¯¹è¯å†å²" disabled>å†å²</button>
                    <button id="next-button" class="control-button" disabled>å¼€å§‹ (è¯·å…ˆè®¾ç½®API)</button>
                </div>
                <div id="game-loading-overlay"><span>å°‘å¥³ç¥ˆç¥·ä¸­...</span></div>
                <div id="game-error-message"></div>
            </div>

            <!-- å†å²é¢æ¿ -->
            <div id="history-panel">
                <h3>å¯¹è¯å†å²è®°å½•</h3>
                <div id="history-content"></div>
                <button id="close-history-btn">å…³é—­</button>
            </div>
        </main>

        <footer>
            <p>Â© 2024 MOLIFULAN's Blog | Galgame powered by AI</p>
        </footer>
    </div>

    <!-- JSæ–‡ä»¶ -->
    <script src="js/script.js"></script> <!-- ä¸»ç«™è„šæœ¬ -->
    <script>
        // --- Galgameä¸“ç”¨JS (å¢å¼ºäº†æ•…äº‹è§„åˆ’) ---
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOMå…ƒç´ å¼•ç”¨ ---
            console.log('DOMContentLoaded äº‹ä»¶è§¦å‘äº†ã€‚æ£€æŸ¥ renderMathInElement ç±»å‹:', typeof renderMathInElement); // â˜… åŠ ä¸Šè¿™è¡Œ
            const configPanel = document.getElementById('config-panel');
            const toggleConfigBtn = document.getElementById('toggle-config-btn');
            const saveConfigBtn = document.getElementById('save-config-btn');
            const closeConfigBtn = document.getElementById('close-config-btn');
            const apiKeyInput = document.getElementById('llm-api-key');
            const apiUrlInput = document.getElementById('llm-api-url');
            const fetchModelsBtn = document.getElementById('fetch-models-btn');
            const modelSelect = document.getElementById('llm-model-select');
            const modelLoadingIndicator = document.getElementById('model-loading-indicator');
            const toggleApiKeyVisibilityBtn = document.getElementById('toggle-api-key-visibility');
            const keyStatusSpan = document.getElementById('key-status');
            const aiPersonaInput = document.getElementById('galgame-persona');
            const playerNameInput = document.getElementById('player-name-input');
            const playerPersonaInput = document.getElementById('player-persona-input');
            const playerStartInput = document.getElementById('player-start-input');
            const dialogueBox = document.getElementById('dialogue-box');
            const speakerName = document.getElementById('speaker-name');
            const dialogueText = document.getElementById('dialogue-text');
            const choicesContainer = document.getElementById('choices-container');
            const nextButton = document.getElementById('next-button');
            const loadingOverlay = document.getElementById('game-loading-overlay');
            const gameErrorMessage = document.getElementById('game-error-message');
            const historyPanel = document.getElementById('history-panel');
            const historyContent = document.getElementById('history-content');
            const toggleHistoryBtn = document.getElementById('toggle-history-btn');
            const closeHistoryBtn = document.getElementById('close-history-btn');
            const gameBackground = document.getElementById('game-background');
            const aiCharacterSprite = document.getElementById('ai-character-sprite');
            const playerCharacterSprite = document.getElementById('player-character-sprite');
            // å›¾ç‰‡ä¸Šä¼ å…ƒç´ 
            const playerImageUpload = document.getElementById('player-image-upload');
            const playerImagePreview = document.getElementById('player-image-preview');
            const clearPlayerImageBtn = document.getElementById('clear-player-image-btn');
            const aiImageUpload = document.getElementById('ai-image-upload');
            const aiImagePreview = document.getElementById('ai-image-preview');
            const clearAiImageBtn = document.getElementById('clear-ai-image-btn');
            // æ•…äº‹è®¾ç½®å…ƒç´ 
            const storyThemeSelect = document.getElementById('story-theme-select');
            const storyLengthSelect = document.getElementById('story-length-select');
            const storyComplexityRange = document.getElementById('story-complexity-range');
            const characterTemplateSelect = document.getElementById('character-template-select');
            const storyProgressBar = document.getElementById('story-progress');


            // --- å¸¸é‡ ---
            const FIXED_STYLE_PROMPT = "masterpiece, best quality, ultra-detailed, extremely detailed illustration, high resolution, sharp focus, dramatic lighting, strong highlights, deep contrasting shadows";
            const SPRITE_BACKGROUND_KEYWORDS = "plain white background, isolated on white";
            const ALLOWED_IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/webp'];
            const GALGAME_STORAGE_PREFIX = 'galGame_';
            const DEFAULT_API_URL_GALGAME = 'https://generativelanguage.googleapis.com';

            // --- è§’è‰²æ¨¡æ¿ ---
            const characterTemplates = {
                "tsundere": {
                    name: "äºšé‡Œæ²™",
                    persona: "ä¸€ä¸ªå‚²å¨‡çš„åŒç­åŒå­¦ï¼Œå¹³æ—¶è£…ä½œä¸åœ¨æ„ï¼Œä½†å®é™…ä¸Šå¾ˆå…³å¿ƒä¸»è§’ã€‚æœ‰ç€é•¿é•¿çš„åŒé©¬å°¾å’Œçº¢è‰²çœ¼ç›ï¼Œè¯´è¯æ—¶ç»å¸¸è„¸çº¢ã€‚æ€§æ ¼å€”å¼ºä½†å†…å¿ƒæ¸©æŸ”ï¼Œä¸æ“…é•¿è¡¨è¾¾çœŸå®æ„Ÿå—ã€‚"
                },
                "kuudere": {
                    name: "é›ªä¹ƒ",
                    persona: "ç¥ç§˜çš„å­¦å§ï¼Œæ€»æ˜¯åœ¨å›¾ä¹¦é¦†çœ‹ä¹¦ï¼ŒçŸ¥è¯†æ¸Šåšä½†å¾ˆå°‘è¯´è¯ã€‚æœ‰ç€é½è‚©çš„é»‘è‰²çŸ­å‘å’Œæ·±è“è‰²çœ¼ç›ï¼Œè¡¨æƒ…å¾ˆå°‘å˜åŒ–ã€‚æ€§æ ¼å†·é™ç†æ™ºï¼Œå†…å¿ƒæ·±å¤„æ¸´æœ›æ¸©æš–çš„å‹æƒ…ã€‚"
                },
                "childhood": {
                    name: "å°æ˜¥",
                    persona: "ä»å°ä¸€èµ·é•¿å¤§çš„é’æ¢…ç«¹é©¬ï¼Œæ´»æ³¼å¼€æœ—ï¼Œå¯¹ä¸»è§’éå¸¸äº†è§£ã€‚æœ‰ç€æ£•è‰²çš„çŸ­å‘å’Œé˜³å…‰èˆ¬çš„ç¬‘å®¹ã€‚ç»å¸¸ç…§é¡¾ä¸»è§’ï¼Œä½†ä¹Ÿæ‹…å¿ƒéšç€é•¿å¤§å½¼æ­¤ä¼šæ¸è¡Œæ¸è¿œã€‚"
                },
                "teacher": {
                    name: "ç¥å´è€å¸ˆ",
                    persona: "æ–°æ¥çš„å¹´è½»ç¾æœ¯è€å¸ˆï¼Œç¥ç§˜ä¸”å……æ»¡é­…åŠ›ï¼ŒèƒŒæ™¯ä¸ä¸ºäººçŸ¥ã€‚æœ‰ç€ç´«è‰²é•¿å‘å’Œæ¸©æŸ”çš„å¾®ç¬‘ï¼Œä½†çœ¼ç¥ä¸­è—ç€ç§˜å¯†ã€‚å¯¹å­¦ç”Ÿå‹å–„ä½†ä¿æŒè·ç¦»ï¼Œä¼¼ä¹æœ‰ä¸ä¸ºäººçŸ¥çš„è¿‡å»ã€‚"
                },
                "alien": {
                    name: "æ˜Ÿç’ƒ",
                    persona: "çªç„¶å‡ºç°çš„è½¬å­¦ç”Ÿï¼Œå®é™…æ˜¯æ¥è‡ªå¼‚ä¸–ç•Œ/å¤–æ˜Ÿçƒçš„è®¿å®¢ã€‚æœ‰ç€é“¶ç™½è‰²çš„é•¿å‘å’Œç´«è‰²çš„çœ¼ç›ï¼Œå¯¹äººç±»ä¸–ç•Œçš„å¸¸è¯†æ„Ÿåˆ°å›°æƒ‘ã€‚æ‹¥æœ‰è¶…å¸¸çš„èƒ½åŠ›ï¼Œæ¥åˆ°è¿™é‡Œä¼¼ä¹æœ‰ç€ç‰¹æ®Šçš„ä½¿å‘½ã€‚"
                }
            };

            // æ•…äº‹ä¸»é¢˜åç§°ç”¨äºæç¤º
            const storyThemeNames = {
                "romance": "æ‹çˆ±",
                "mystery": "æ‚¬ç–‘æ¨ç†",
                "fantasy": "å¥‡å¹»å†’é™©",
                "school": "æ ¡å›­æ—¥å¸¸",
                "scifi": "ç§‘å¹»æœªæ¥"
            };

            // --- çŠ¶æ€å˜é‡ ---
            // API & AI
            let currentApiKey = '';
            let currentApiUrl = '';
            let currentModel = '';
            let currentAiPersona = '';
            // ç©å®¶
            let playerName = '';
            let playerPersona = '';
            let playerStart = '';
            // å›¾ç‰‡æ•°æ®(Base64å­—ç¬¦ä¸²) - ä¸ä¿å­˜åœ¨localStorage
            let playerImageBase64 = null;
            let aiImageBase64 = null;
            // è§’è‰²å¤–è§‚
            let playerBaseAppearancePrompt = '';
            let aiBaseAppearancePrompt = '';
            let spriteCache = {};
            // æ¸¸æˆçŠ¶æ€
            let conversationHistory = [];
            let isGameStarted = false;
            let isLoading = false;
            let currentDialogueSegments = [];
            let currentSegmentIndex = 0;
            let currentTurnChoices = [];
            let currentTurnParsedData = null;

            // --- æ•…äº‹è·Ÿè¸ªå™¨å¯¹è±¡ ---
            const StoryTracker = {
                // æ•…äº‹å…ƒæ•°æ®
                metadata: {
                    currentAct: 1,
                    totalActs: 3,
                    progress: 0, // 0-100
                    branchPath: "main",
                    availableEndings: [], // ç”±AIåœ¨é¦–ä¸ªå“åº”ä¸­å¡«å……
                    currentEnding: null,
                    remainingTurns: 15
                },

                // åˆå§‹åŒ–æ•…äº‹è·Ÿè¸ªå™¨
                initialize(storyTheme, storyLength, complexity) {
                    this.metadata = {
                        currentAct: 1,
                        totalActs: storyLength === "short" ? 2 : (storyLength === "medium" ? 3 : 4),
                        progress: 0,
                        branchPath: "main",
                        availableEndings: [],
                        currentEnding: null,
                        remainingTurns: storyLength === "short" ? 10 : (storyLength === "medium" ? 15 : 20)
                    };

                    return {
                        story_metadata: this.metadata,
                        story_theme: storyTheme,
                        complexity: complexity,
                        request_type: "initialize_story"
                    };
                },

                // ä»AIå“åº”æ›´æ–°
                updateFromAIResponse(response) {
                    if (response && response.story_metadata) {
                        this.metadata = { ...this.metadata, ...response.story_metadata };
                        this.updateProgressUI();
                    }

                    // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾æ•…äº‹ç»“å±€
                    if (this.metadata.progress >= 100 || this.metadata.currentEnding) {
                        setTimeout(() => {
                            displayStoryEnding(this.metadata.currentEnding || {
                                type: "neutral",
                                name: "æ•…äº‹ç»“æŸ",
                                description: "ä½ çš„æ•…äº‹å·²ç»ç»“æŸã€‚è°¢è°¢æ¸¸ç©ï¼"
                            });
                        }, 2000);
                    }
                },

                // æ›´æ–°è¿›åº¦UI
                updateProgressUI() {
                    storyProgressBar.style.display = 'block';
                    const progressInner = storyProgressBar.querySelector('.progress-inner');
                    const progressText = storyProgressBar.querySelector('.progress-text');

                    progressInner.style.width = `${this.metadata.progress}%`;
                    progressText.textContent = `æ•…äº‹è¿›åº¦: ${this.metadata.progress}% | ç¬¬${this.metadata.currentAct}å¹• | å‰©ä½™å›åˆ: ${this.metadata.remainingTurns}`;
                },

                // é‡ç½®è·Ÿè¸ªå™¨
                reset() {
                    this.metadata = {
                        currentAct: 1,
                        totalActs: 3,
                        progress: 0,
                        branchPath: "main",
                        availableEndings: [],
                        currentEnding: null,
                        remainingTurns: 15
                    };
                    storyProgressBar.style.display = 'none';
                }
            };

            // --- è¾…åŠ©å‡½æ•° ---
            // é˜²æŠ–å‡½æ•°ç”¨äºè¾“å…¥å˜æ›´
            function debounce(func, wait) {
                let timeout;
                return function (...args) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), wait);
                };
            }

            // ä»æ•°æ®URLä¸­æå–MIMEç±»å‹å’Œbase64æ•°æ®
            function getImageDataFromBase64(base64String) {
                if (!base64String || !base64String.startsWith('data:image')) {
                    return null;
                }
                const parts = base64String.split(',');
                if (parts.length !== 2) return null;
                const mimeMatch = parts[0].match(/:(.*?);/);
                if (!mimeMatch || mimeMatch.length < 2) return null;
                return {
                    mimeType: mimeMatch[1],
                    data: parts[1]
                };
            }

            // å›¾ç‰‡å‹ç¼©å‡½æ•°
            async function compressImage(base64String, maxWidthHeight = 800, quality = 0.8) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        // è®¡ç®—æ–°å°ºå¯¸ï¼Œä¿æŒå®½é«˜æ¯”
                        let width = img.width;
                        let height = img.height;
                        if (width > height && width > maxWidthHeight) {
                            height = height * (maxWidthHeight / width);
                            height = height * (maxWidthHeight / width);
                            width = maxWidthHeight;
                        } else if (height > maxWidthHeight) {
                            width = width * (maxWidthHeight / height);
                            height = maxWidthHeight;
                        }

                        canvas.width = width;
                        canvas.height = height;

                        // ç»˜åˆ¶å‹ç¼©å›¾åƒ
                        ctx.drawImage(img, 0, 0, width, height);

                        // è½¬æ¢å›Base64
                        resolve(canvas.toDataURL('image/jpeg', quality));
                    };
                    img.src = base64String;
                });
            }

            // --- è§’è‰²SpriteèƒŒæ™¯å»é™¤ ---
            async function removeEdgeWhiteBackground(img) {
                return new Promise((resolve, reject) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    const width = img.naturalWidth; const height = img.naturalHeight;
                    if (width === 0 || height === 0) { console.warn("å›¾åƒå°ºå¯¸ä¸ºé›¶ï¼Œæ— æ³•å¤„ç†ã€‚"); resolve(img.src); return; }
                    canvas.width = width; canvas.height = height;
                    try {
                        ctx.drawImage(img, 0, 0);
                        const imageData = ctx.getImageData(0, 0, width, height);
                        const data = imageData.data;
                        const visited = new Uint8Array(width * height);

                        // --- ç¬¬ä¸€æ¬¡å¤„ç†: Edge Flood Fill (ä½¿ç”¨é€‚ä¸­çš„å®¹å·®å€¼) ---
                        const whiteThreshold = 255;
                        const floodFillTolerance = 7; // <<<<<<<<<< å¯å°è¯•è°ƒæ•´æ­¤å€¼ (4, 5 æˆ– 6)
                        const effectiveFloodThreshold = whiteThreshold - floodFillTolerance;

                        function isNearWhiteForFlood(index) {
                            if (index < 0 || index >= data.length || data[index + 3] < 128) return false;
                            const r = data[index]; const g = data[index + 1]; const b = data[index + 2];
                            return r >= effectiveFloodThreshold && g >= effectiveFloodThreshold && b >= effectiveFloodThreshold;
                        }
                        function getIndex(x, y) { return (y * width + x) * 4; }
                        function getVisitedIndex(x, y) { return y * width + x; }
                        const queue = [];
                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                if (y === 0 || y === height - 1 || x === 0 || x === width - 1) {
                                    const index = getIndex(x, y);
                                    const visitedIndex = getVisitedIndex(x, y);
                                    if (!visited[visitedIndex] && isNearWhiteForFlood(index)) {
                                        queue.push({ x, y });
                                        visited[visitedIndex] = 1;
                                    }
                                }
                            }
                        }
                        console.log(`å¼€å§‹Flood Fillå¤„ç†ã€‚å®¹å·®å€¼: ${floodFillTolerance}. åˆå§‹é˜Ÿåˆ—:`, queue.length);
                        let processedFloodFillCount = 0;
                        while (queue.length > 0) {
                            const { x, y } = queue.shift(); const index = getIndex(x, y);
                            if (data[index + 3] > 0) { data[index + 3] = 0; processedFloodFillCount++; } // è®¾ä¸ºé€æ˜
                            const neighbors = [{ nx: x + 1, ny: y }, { nx: x - 1, ny: y }, { nx: x, ny: y + 1 }, { nx: x, ny: y - 1 }];
                            for (const { nx, ny } of neighbors) {
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const neighborIndex = getIndex(nx, ny);
                                    const visitedIndex = getVisitedIndex(nx, ny);
                                    if (!visited[visitedIndex] && isNearWhiteForFlood(neighborIndex)) {
                                        queue.push({ x: nx, y: ny });
                                        visited[visitedIndex] = 1;
                                    }
                                }
                            }
                        }
                        console.log(`Flood fillå®Œæˆã€‚${processedFloodFillCount}ä¸ªåƒç´ è®¾ä¸ºé€æ˜ã€‚`);

                        // --- ç¬¬äºŒæ¬¡å¤„ç†: æ¸…ç†å­¤ç«‹çš„ç™½è‰²åƒç´ ç‚¹ ---
                        const cleanupTolerance = 4; // <<<<<<<<<< ä½¿ç”¨ä¸¥æ ¼çš„å®¹å·®å€¼
                        const effectiveCleanupThreshold = whiteThreshold - cleanupTolerance;
                        let cleanedPixelCount = 0;

                        console.log(`å¼€å§‹æ¸…ç†å­¤ç«‹åƒç´ ã€‚ä¸¥æ ¼å®¹å·®: ${cleanupTolerance}`);
                        for (let y = 1; y < height - 1; y++) { // è·³è¿‡è¾¹ç•Œ
                            for (let x = 1; x < width - 1; x++) {
                                const index = getIndex(x, y);
                                // æ£€æŸ¥åƒç´ æ˜¯å¦å·²ç»é€æ˜
                                if (data[index + 3] > 0) {
                                    const r = data[index]; const g = data[index + 1]; const b = data[index + 2];
                                    // æ£€æŸ¥æ˜¯å¦éå¸¸æ¥è¿‘ç™½è‰²
                                    if (r >= effectiveCleanupThreshold && g >= effectiveCleanupThreshold && b >= effectiveCleanupThreshold) {
                                        // æ£€æŸ¥å…¶å‘¨å›´4ä¸ªç›´æ¥ç›¸é‚»åƒç´ 
                                        let transparentNeighbors = 0;
                                        const neighborsIndices = [getIndex(x + 1, y), getIndex(x - 1, y), getIndex(x, y + 1), getIndex(x, y - 1)];
                                        for (const nIndex of neighborsIndices) {
                                            // æ£€æŸ¥é‚»å±…æ˜¯å¦åœ¨è¾¹ç•Œå†…ä¸”é€æ˜
                                            if (nIndex >= 0 && nIndex < data.length && data[nIndex + 3] === 0) {
                                                transparentNeighbors++;
                                            }
                                        }
                                        // å¦‚æœ4ä¸ªé‚»å±…ä¸­æœ‰3ä¸ªæˆ–ä»¥ä¸Šæ˜¯é€æ˜çš„ï¼Œè®¤ä¸ºæ˜¯å­¤ç«‹ç‚¹
                                        if (transparentNeighbors >= 3) {
                                            data[index + 3] = 0; // å°†å…¶è®¾ä¸ºé€æ˜
                                            cleanedPixelCount++;
                                        }
                                    }
                                }
                            }
                        }
                        console.log(`å­¤ç«‹åƒç´ æ¸…ç†å®Œæˆã€‚${cleanedPixelCount}ä¸ªå­¤ç«‹åƒç´ è¢«è®¾ä¸ºé€æ˜ã€‚`);

                        ctx.putImageData(imageData, 0, 0);
                        resolve(canvas.toDataURL('image/png'));
                    } catch (error) {
                        // é”™è¯¯å¤„ç†
                        if (error.name === 'SecurityError') {
                            console.error("Canvaså¤„ç†é”™è¯¯(å¯èƒ½æ˜¯CORSé—®é¢˜)...", error);
                            resolve(img.src);
                        } else {
                            console.error("removeEdgeWhiteBackgroundä¸­Canvaså¤„ç†é”™è¯¯:", error);
                            resolve(img.src);
                        }
                    }
                });
            }

            // --- å›¾åƒåŠ è½½ ---
            async function loadDynamicImage(element, prompt, imageType = "background", nologo = true, seed = null) {
                if (!prompt || !element) {
                    console.warn(`è·³è¿‡${imageType}å›¾åƒ: æ²¡æœ‰æä¾›æç¤ºæˆ–å…ƒç´ ã€‚`);
                    if (imageType === 'character') {
                        element.classList.add('hidden');
                        element.style.opacity = null;
                    }
                    return Promise.resolve();
                }

                const baseCharacterPrompt = prompt;
                console.log(`å°è¯•åŠ è½½${imageType}å›¾åƒï¼ŒåŸºç¡€æç¤º: ${baseCharacterPrompt}`);

                let width = 768, height = 1024, extraParams = "", finalPromptString;

                if (imageType === 'character') {
                    width = 768; height = 1024; extraParams = "&nofeed=true";
                    finalPromptString = `${FIXED_STYLE_PROMPT}, ${SPRITE_BACKGROUND_KEYWORDS}, ${baseCharacterPrompt}`;
                    console.log("æœ€ç»ˆè§’è‰²æç¤º:", finalPromptString);

                    if (spriteCache[finalPromptString]) {
                        console.log(`ç¼“å­˜å‘½ä¸­: ${finalPromptString.substring(0, 100)}...`);
                        element.src = spriteCache[finalPromptString];
                        element.classList.remove('hidden');
                        element.style.opacity = null; // æ¸…é™¤å†…è”æ ·å¼
                        return Promise.resolve();
                    }

                    element.classList.add('hidden');
                    element.style.opacity = null; // æ·»åŠ hiddenæ—¶æ¸…é™¤å†…è”æ ·å¼
                } else if (imageType === 'background') {
                    finalPromptString = `${baseCharacterPrompt}, anime style, visual novel background, detailed illustration, high quality`;
                    width = 1024;
                    height = 576;
                    extraParams = "&nofeed=true";
                }

                const nologoValue = nologo ? 'true' : 'false';
                let url = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPromptString)}?width=${width}&height=${height}&model=flux&nologo=${nologoValue}${extraParams}`;

                if (seed) {
                    url += `&seed=${encodeURIComponent(seed)}`;
                }

                console.log(`ç”Ÿæˆ${imageType}å›¾åƒURL:`, url);

                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";

                    img.onload = async () => {
                        console.log(`${imageType}å›¾åƒé¢„åŠ è½½æˆåŠŸã€‚`);
                        if (imageType === 'background') {
                            element.style.backgroundImage = `url('${url}')`;
                            console.log(`èƒŒæ™¯å›¾åƒå·²è®¾ç½®:`, element);
                            resolve();
                        } else { // å¤„ç†è§’è‰²å›¾åƒ
                            try {
                                console.log(`å°è¯•ç§»é™¤${element.id}çš„ç™½è‰²èƒŒæ™¯...`);
                                const processedUrl = await removeEdgeWhiteBackground(img);
                                element.src = processedUrl;
                                spriteCache[finalPromptString] = processedUrl; // ç¼“å­˜å¤„ç†åçš„URL
                                element.classList.remove('hidden');
                                element.style.opacity = null; // æˆåŠŸåæ¸…é™¤å†…è”æ ·å¼
                                console.log(`${element.id}çš„ç™½è‰²èƒŒæ™¯å·²ç§»é™¤ã€‚`);
                            } catch (error) {
                                console.error(`${element.id}èƒŒæ™¯ç§»é™¤é”™è¯¯:`, error);
                                element.src = url; // å›é€€ä½¿ç”¨åŸå§‹URL
                                spriteCache[finalPromptString] = url; // ç¼“å­˜åŸå§‹URL
                                element.classList.remove('hidden');
                                element.style.opacity = null; // å›é€€æ—¶æ¸…é™¤å†…è”æ ·å¼
                                showGameError(`å¤„ç†${element.alt}èƒŒæ™¯æ—¶å‡ºé”™ã€‚`);
                            } finally {
                                resolve();
                            }
                        }
                    };

                    img.onerror = (e) => {
                        console.error(`åŠ è½½${imageType}å›¾åƒé”™è¯¯:`, e, url);
                        showGameError(`${imageType === 'character' ? element.alt : 'èƒŒæ™¯'}åŠ è½½å¤±è´¥ã€‚`);
                        if (imageType === 'character') {
                            element.classList.add('hidden');
                            element.style.opacity = null; // é”™è¯¯æ—¶æ¸…é™¤å†…è”æ ·å¼
                        }
                        resolve();
                    };

                    img.src = url;
                });
            }

            // è¯»å–æ–‡ä»¶è¾“å…¥å¹¶è½¬æ¢ä¸ºBase64
            function handleImageUpload(fileInput, previewElement, clearButton, stateVariableSetter) {
                const file = fileInput.files[0];
                if (!file) {
                    stateVariableSetter(null);
                    previewElement.style.display = 'none';
                    clearButton.style.display = 'none';
                    return;
                }

                if (!ALLOWED_IMAGE_TYPES.includes(file.type)) {
                    showGameError(`ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: ${file.type}. è¯·ä¸Šä¼  JPG, PNG, æˆ– WebP æ ¼å¼å›¾ç‰‡.`);
                    fileInput.value = null;
                    stateVariableSetter(null);
                    previewElement.style.display = 'none';
                    clearButton.style.display = 'none';
                    return;
                }

                const reader = new FileReader();
                reader.onload = async (e) => {
                    const result = e.target.result;
                    // å‹ç¼©å›¾ç‰‡ä»¥å‡å°‘APIè°ƒç”¨å¤§å°
                    const compressedImage = await compressImage(result);
                    stateVariableSetter(compressedImage);
                    previewElement.src = compressedImage;
                    previewElement.style.display = 'block';
                    clearButton.style.display = 'inline-block';
                    console.log(`å›¾ç‰‡å·²åŠ è½½å¹¶å‹ç¼©: ${fileInput.id}`);
                };
                reader.onerror = (e) => {
                    showGameError("è¯»å–å›¾ç‰‡æ–‡ä»¶æ—¶å‡ºé”™.");
                    console.error("FileReader error:", e);
                    fileInput.value = null;
                    stateVariableSetter(null);
                    previewElement.style.display = 'none';
                    clearButton.style.display = 'none';
                };
                reader.readAsDataURL(file);
            }

            // æ¸…é™¤å›¾ç‰‡ä¸Šä¼ 
            function clearImageUpload(fileInput, previewElement, clearButton, stateVariableSetter) {
                fileInput.value = null;
                stateVariableSetter(null);
                previewElement.src = '#';
                previewElement.style.display = 'none';
                clearButton.style.display = 'none';
                console.log(`å·²æ¸…é™¤å›¾ç‰‡: ${fileInput.id}`);
            }

            // å®‰å…¨APIå¯†é’¥å­˜å‚¨
            function secureStoreApiKey(key) {
                // ç®€å•æ··æ·†ï¼Œå®é™…é¡¹ç›®ä¸­åº”è€ƒè™‘æ›´å®‰å…¨çš„æ–¹å¼
                const obscuredKey = btoa(key.split('').reverse().join(''));
                localStorage.setItem(GALGAME_STORAGE_PREFIX + 'apiKeyObscured', obscuredKey);
            }

            function secureRetrieveApiKey() {
                const obscuredKey = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'apiKeyObscured');
                if (!obscuredKey) return '';
                return atob(obscuredKey).split('').reverse().join('');
            }

            // æ˜¾ç¤ºç« èŠ‚æ ‡è®°
            function renderChapterMarker(chapterInfo) {
                const chapterMarker = document.createElement('div');
                chapterMarker.className = 'chapter-marker';
                chapterMarker.innerHTML = `
                <div class="chapter-line"></div>
                <div class="chapter-title">${chapterInfo.title}</div>
                <div class="chapter-line"></div>
            `;
                dialogueBox.insertBefore(chapterMarker, choicesContainer);

                // æ»šåŠ¨åˆ°ç« èŠ‚æ ‡è®°
                setTimeout(() => {
                    chapterMarker.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            }

            // æ˜¾ç¤ºé€‰æ‹©å½±å“
            function showChoiceImpact(impactType) {
                const impactMessage = document.createElement('div');
                impactMessage.className = `choice-impact ${impactType}`;

                let message = "";
                let icon = "";

                switch (impactType) {
                    case 'relationship-up':
                        message = "å¥½æ„Ÿåº¦æå‡";
                        icon = "â¤ï¸";
                        break;
                    case 'relationship-down':
                        message = "å¥½æ„Ÿåº¦ä¸‹é™";
                        icon = "ğŸ’”";
                        break;
                    case 'story-branch':
                        message = "æ•…äº‹èµ°å‘æ”¹å˜";
                        icon = "ğŸ”€";
                        break;
                    case 'progress-significant':
                        message = "é‡è¦å‰§æƒ…ç‚¹";
                        icon = "âœ¨";
                        break;
                }

                impactMessage.innerHTML = `${icon} ${message}`;
                document.getElementById('galgame-container').appendChild(impactMessage);

                // åŠ¨ç”»åç§»é™¤
                setTimeout(() => {
                    impactMessage.classList.add('fadeout');
                    setTimeout(() => impactMessage.remove(), 1000);
                }, 2000);
            }

            // æ˜¾ç¤ºæ•…äº‹ç»“å±€
            function displayStoryEnding(ending) {
                // åˆ›å»ºç»“å±€æ˜¾ç¤ºé¢æ¿
                const endingPanel = document.createElement('div');
                endingPanel.className = 'story-ending-panel';

                // ç»“å±€æ ‡é¢˜å’Œç±»å‹
                const endingTitle = ending.type === "good" ? "å®Œç¾ç»“å±€" :
                    (ending.type === "neutral" ? "æ™®é€šç»“å±€" : "ç³Ÿç³•ç»“å±€");

                endingPanel.innerHTML = `
                <div class="ending-header">
                    <h2>${endingTitle}</h2>
                    <div class="ending-type ${ending.type}">${ending.name || 'æ•…äº‹ç»“æŸ'}</div>
                </div>
                <div class="ending-content">${ending.description || 'ä½ çš„æ•…äº‹å·²ç»ç»“æŸã€‚'}</div>
                <div class="ending-buttons">
                    <button class="restart-button">é‡æ–°å¼€å§‹</button>
                    <button class="share-button">åˆ†äº«ç»“å±€</button>
                </div>
            `;

                // æ·»åŠ åˆ°æ¸¸æˆå®¹å™¨
                document.getElementById('galgame-container').appendChild(endingPanel);

                // äº‹ä»¶ç›‘å¬
                endingPanel.querySelector('.restart-button').addEventListener('click', restartGame);
                endingPanel.querySelector('.share-button').addEventListener('click', () => {
                    // åˆ†äº«åŠŸèƒ½
                    alert('åˆ†äº«åŠŸèƒ½å³å°†æ¨å‡ºï¼');
                });
            }

            // é‡å¯æ¸¸æˆ
            function restartGame() {
                // æ¸…é™¤çŠ¶æ€
                conversationHistory = [];
                currentDialogueSegments = [];
                currentSegmentIndex = 0;
                currentTurnChoices = [];
                currentTurnParsedData = null;
                isGameStarted = false;

                // é‡ç½®è¿›åº¦æ¡
                StoryTracker.reset();

                // é‡ç½®UI
                dialogueText.innerHTML = 'åœ¨è¿™é‡Œè®¾ç½®ç©å®¶åç§°ã€è®¾å®šå’ŒæœŸæœ›å¼€å±€åï¼Œç‚¹å‡»"å¼€å§‹"ã€‚';
                speakerName.textContent = 'æ—ç™½';
                choicesContainer.innerHTML = '';
                aiCharacterSprite.classList.add('hidden');
                playerCharacterSprite.classList.add('hidden');

                // ç§»é™¤ç»“å±€é¢æ¿
                const endingPanel = document.querySelector('.story-ending-panel');
                if (endingPanel) endingPanel.remove();

                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                nextButton.textContent = 'å¼€å§‹';

                // æ‰“å¼€è®¾ç½®é¢æ¿
                configPanel.classList.add('visible');
            }

            // --- é”™è¯¯å’ŒåŠ è½½UI ---
            function showGameError(message) {
                console.error("æ¸¸æˆé”™è¯¯:", message);
                gameErrorMessage.textContent = message;
                gameErrorMessage.style.display = 'block';
                setTimeout(() => {
                    clearGameError();
                }, 5000);
            }

            function clearGameError() {
                gameErrorMessage.style.display = 'none';
                gameErrorMessage.textContent = '';
            }

            function setLoading(loading) {
                console.log("è®¾ç½®åŠ è½½çŠ¶æ€ä¸º:", loading);
                isLoading = loading;
                loadingOverlay.classList.toggle('visible', loading);
                const canInteract = currentApiKey && currentModel;
                const choicesCurrentlyDisplayed = choicesContainer.querySelector('.choice-button') !== null;
                const moreSegmentsAvailable = currentDialogueSegments && currentSegmentIndex < currentDialogueSegments.length - 1;
                nextButton.disabled = loading || !canInteract || !isGameStarted || choicesCurrentlyDisplayed || !moreSegmentsAvailable;
                toggleHistoryBtn.disabled = loading || !canInteract || !isGameStarted;
                // ç§»é™¤è¿™ä¸€è¡Œ: toggleConfigBtn.disabled = loading;
                document.querySelectorAll('.choice-button').forEach(btn => btn.disabled = loading);
            }

            // --- é…ç½®é€»è¾‘ ---
            function saveConfig() {
                // æ–‡æœ¬é…ç½®ä¿å­˜åˆ°localStorage
                const apiKey = apiKeyInput.value.trim();
                const apiUrl = apiUrlInput.value.trim() || DEFAULT_API_URL_GALGAME;
                const model = modelSelect.value;
                const aiPersona = aiPersonaInput.value.trim();
                const pName = playerNameInput.value.trim();
                const pPersona = playerPersonaInput.value.trim();
                const pStart = playerStartInput.value.trim();

                // å®‰å…¨å­˜å‚¨APIå¯†é’¥
                secureStoreApiKey(apiKey);

                localStorage.setItem(GALGAME_STORAGE_PREFIX + 'apiUrl', apiUrl);
                localStorage.setItem(GALGAME_STORAGE_PREFIX + 'model', model);
                localStorage.setItem(GALGAME_STORAGE_PREFIX + 'aiPersona', aiPersona);
                localStorage.setItem(GALGAME_STORAGE_PREFIX + 'playerName', pName);
                localStorage.setItem(GALGAME_STORAGE_PREFIX + 'playerPersona', pPersona);
                localStorage.setItem(GALGAME_STORAGE_PREFIX + 'playerStart', pStart);

                // æ•…äº‹è®¾ç½®
                localStorage.setItem(GALGAME_STORAGE_PREFIX + 'storyTheme', storyThemeSelect.value);
                localStorage.setItem(GALGAME_STORAGE_PREFIX + 'storyLength', storyLengthSelect.value);
                localStorage.setItem(GALGAME_STORAGE_PREFIX + 'storyComplexity', storyComplexityRange.value);

                // æ›´æ–°å½“å‰å˜é‡
                currentApiKey = apiKey;
                currentApiUrl = apiUrl;
                currentModel = model;
                currentAiPersona = aiPersona;
                playerName = pName;
                playerPersona = pPersona;
                playerStart = pStart;

                console.log("æ¸¸æˆé…ç½®å·²ä¿å­˜:", { currentApiKey: "å·²éšè—", currentApiUrl, currentModel, currentAiPersona, playerName, playerPersona, playerStart });

                const canEnable = currentApiKey && currentModel;
                nextButton.disabled = !canEnable;
                nextButton.textContent = canEnable ? 'å¼€å§‹' : 'å¼€å§‹ (è¯·å…ˆè®¾ç½®API)';

                showGameError("è®¾ç½®å·²ä¿å­˜.");
            }

            function loadConfig() {
                // ä»localStorageåŠ è½½æ–‡æœ¬é…ç½®
                currentApiKey = secureRetrieveApiKey() || '';
                currentApiUrl = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'apiUrl') || DEFAULT_API_URL_GALGAME;
                currentModel = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'model') || '';
                currentAiPersona = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'aiPersona') || '';
                playerName = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'playerName') || '';
                playerPersona = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'playerPersona') || '';
                playerStart = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'playerStart') || '';

                // åŠ è½½æ•…äº‹è®¾ç½®
                const savedTheme = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'storyTheme');
                const savedLength = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'storyLength');
                const savedComplexity = localStorage.getItem(GALGAME_STORAGE_PREFIX + 'storyComplexity');

                if (savedTheme) storyThemeSelect.value = savedTheme;
                if (savedLength) storyLengthSelect.value = savedLength;
                if (savedComplexity) storyComplexityRange.value = savedComplexity;

                // é‡ç½®å›¾ç‰‡ä¸Šä¼ 
                clearImageUpload(playerImageUpload, playerImagePreview, clearPlayerImageBtn, (val) => playerImageBase64 = val);
                clearImageUpload(aiImageUpload, aiImagePreview, clearAiImageBtn, (val) => aiImageBase64 = val);

                console.log("æ¸¸æˆé…ç½®å·²åŠ è½½ (å›¾ç‰‡å·²é‡ç½®):", { currentApiKey: "å·²éšè—", currentApiUrl, currentModel, currentAiPersona, playerName, playerPersona, playerStart });

                const canConfigure = currentApiKey && currentModel;

                // æ›´æ–°UIåæ˜ é…ç½®
                apiKeyInput.value = currentApiKey;
                apiUrlInput.value = currentApiUrl;

                if (currentModel) {
                    // å¦‚æœå·²æœ‰ä¿å­˜çš„æ¨¡å‹ï¼Œç¡®ä¿æ¨¡å‹é€‰æ‹©å™¨ä¸­æœ‰è¯¥é€‰é¡¹
                    if (modelSelect.querySelector(`option[value="${currentModel}"]`)) {
                        modelSelect.value = currentModel;
                    } else {
                        // å¦‚æœæ²¡æœ‰ï¼Œåˆ›å»ºä¸€ä¸ª
                        const option = document.createElement('option');
                        option.value = currentModel;
                        option.textContent = currentModel;
                        modelSelect.appendChild(option);
                        modelSelect.value = currentModel;
                        modelSelect.disabled = false;
                    }
                }

                aiPersonaInput.value = currentAiPersona;
                playerNameInput.value = playerName;
                playerPersonaInput.value = playerPersona;
                playerStartInput.value = playerStart;

                nextButton.disabled = !canConfigure;
                nextButton.textContent = canConfigure ? 'å¼€å§‹' : 'å¼€å§‹ (è¯·å…ˆè®¾ç½®API)';
            }

            function toggleConfigPanel() {
                configPanel.classList.toggle('visible');
            }

            // --- åˆå§‹åŒ–æ•…äº‹ ---
            async function initializeGame() {
                // æ”¶é›†æ•…äº‹è®¾ç½®
                const storyTheme = storyThemeSelect.value;
                const storyLength = storyLengthSelect.value;
                const storyComplexity = storyComplexityRange.value;

                // åˆå§‹åŒ–æ•…äº‹è·Ÿè¸ªå™¨
                const storyMetadata = StoryTracker.initialize(storyTheme, storyLength, storyComplexity);

                // æ„å»ºåˆå§‹åŒ–è¯·æ±‚
                const initPrompt = `è¯·ä¸ºæˆ‘åˆ›å»ºä¸€ä¸ª${storyThemeNames[storyTheme]}ç±»å‹çš„è§†è§‰å°è¯´æ•…äº‹ã€‚
ç©å®¶è§’è‰²æ˜¯ï¼š${playerName || 'ä¸»è§’'}ï¼Œ${playerPersona || 'ä¸€åæ™®é€šçš„é«˜ä¸­ç”Ÿ'}
AIè§’è‰²æ˜¯ï¼š${currentAiPersona || 'ç”±ä½ å†³å®šä¸€ä¸ªæœ‰è¶£çš„è§’è‰²'}

ã€é‡è¦ï¼æ•…äº‹è§„åˆ’è¦æ±‚ã€‘ï¼š
åœ¨ä½ çš„å“åº”ä¸­ï¼Œè¯·å…ˆå†…éƒ¨åˆ›å»ºä»¥ä¸‹å†…å®¹ï¼ˆä¸è¦ç›´æ¥å±•ç¤ºç»™ç©å®¶ï¼‰ï¼š
1. æ•…äº‹ä¸»çº¿ï¼šè®¾è®¡3-5ä¸ªå…³é”®æƒ…èŠ‚ç‚¹
2. å¯èƒ½çš„ç»“å±€ï¼šè‡³å°‘è®¾è®¡3ä¸ªä¸åŒç»“å±€ï¼ˆå¥½/ä¸­ç«‹/åï¼‰
3. åˆ†æ”¯æ¡ä»¶ï¼šç¡®å®šå“ªäº›ç©å®¶é€‰æ‹©ä¼šå¯¼å‘ä¸åŒåˆ†æ”¯
4. è¿›åº¦æŒ‡ç¤ºå™¨ï¼šæ¯æ¬¡å›åº”éƒ½è¦æä¾›story_metadataå­—æ®µæ›´æ–°è¿›åº¦ï¼ˆ0%~100%ï¼‰

æ•…äº‹åº”è¯¥åŒ…å«æ˜ç¡®çš„å¼€å§‹ã€ä¸­é—´å†²çªå’Œç»“å±€ã€‚
å¤æ‚åº¦è¦æ±‚ï¼š${storyComplexity}/5ï¼ˆè¶Šé«˜åˆ†æ”¯é€‰æ‹©è¶Šå¤šï¼‰
æœŸæœ›é•¿åº¦ï¼š${storyLength === 'short' ? 'çŸ­ç¯‡ï¼ˆçº¦10å›åˆï¼‰' : (storyLength === 'medium' ? 'ä¸­ç¯‡ï¼ˆçº¦15å›åˆï¼‰' : 'é•¿ç¯‡ï¼ˆçº¦20å›åˆï¼‰')}
å¼€åœºæƒ…æ™¯ï¼š${playerStart || 'ç”±ä½ å†³å®šé€‚åˆçš„å¼€åœº'}

è¯·åœ¨å›åº”ä¸­åŒ…å«ï¼š
1. å†…éƒ¨æ•…äº‹å¤§çº²ï¼ˆä¸ç›´æ¥å±•ç¤ºç»™ç©å®¶ï¼‰
2. å¯èƒ½çš„ç»“å±€åˆ†æ”¯
3. ç¬¬ä¸€ä¸ªåœºæ™¯æè¿°å’Œå¯¹è¯

å½“æ•…äº‹è¿›è¡Œåˆ°70%ä»¥ä¸Šæ—¶ï¼Œå¼€å§‹å¼•å¯¼ç©å®¶èµ°å‘æŸä¸ªç»“å±€ã€‚
è¯·è®°ä½ï¼Œè¿™æ˜¯ä¸€ä¸ªè§†è§‰å°è¯´/Galgameï¼Œæ‰€ä»¥å™äº‹é£æ ¼åº”è¯¥ç¬¦åˆè¿™ä¸ªç±»å‹ï¼Œå¹¶ä¸”éœ€è¦æœ‰é€‚å½“çš„åœºæ™¯å’Œè§’è‰²æè¿°ã€‚`;

                // åˆ›å»ºåˆå§‹åŒ–æç¤ºå†å²
                const setupHistory = [
                    {
                        role: "user",
                        parts: [{ text: initPrompt }],
                        isSetup: true,
                        storyMetadata: storyMetadata
                    }
                ];

                // è°ƒç”¨APIå¼€å§‹æ•…äº‹
                setLoading(true);
                try {
                    const response = await callLLMApi_Galgame(setupHistory);
                    processGameResponse(response);
                    isGameStarted = true;
                } catch (error) {
                    showGameError("åˆå§‹åŒ–æ•…äº‹æ—¶å‡ºé”™: " + error.message);
                } finally {
                    setLoading(false);
                }
            }

            // --- LLM APIè°ƒç”¨ ---
            async function callLLMApi_Galgame(promptHistory) {
                console.log("å¼€å§‹è°ƒç”¨LLM API...");
                if (!currentApiKey || !currentModel || !currentApiUrl) {
                    showGameError("API é…ç½®ä¸å®Œæ•´ï¼è¯·æ£€æŸ¥è®¾ç½®ã€‚");
                    const fallbackData = {
                        scene_state: {
                            background_prompt: "error config",
                            visible_characters: []
                        },
                        dialogue_segments: [
                            {
                                speaker: "ç³»ç»Ÿ",
                                text: "API é…ç½®ä¸å®Œæ•´ï¼è¯·æ£€æŸ¥è®¾ç½®ã€‚"
                            }
                        ],
                        story_metadata: StoryTracker.metadata
                    };

                    // ç¡®ä¿é”™è¯¯è¢«æ·»åŠ åˆ°å†å²ä¸­ï¼ˆå¦‚æœæ¸¸æˆå·²ç»å¼€å§‹ï¼‰
                    if (isGameStarted && (!conversationHistory.length || !conversationHistory[conversationHistory.length - 1].isErrorFallback)) {
                        conversationHistory.push({
                            role: "model",
                            parts: [{ text: JSON.stringify(fallbackData) }],
                            isErrorFallback: true
                        });
                    }

                    return fallbackData;
                }

                clearGameError();
                let finalApiUrl = currentApiUrl.trim();
                let requestBody;
                let headers = { 'Content-Type': 'application/json' };
                const isFirstCall = promptHistory.length === 1 && promptHistory[0].isSetup;
                let userPromptText = isFirstCall ?
                    promptHistory[0].parts[0].text :
                    promptHistory[promptHistory.length - 1].parts[0].text;

                // ç³»ç»ŸæŒ‡ä»¤ï¼ˆåŒ…å«æ•…äº‹è§„åˆ’è¦æ±‚ï¼‰
                const systemInstruction = `ä½ ç°åœ¨æ˜¯ä¸€ä¸ª Galgame (è§†è§‰å°è¯´) å¼•æ“ã€‚ä½ çš„ä»»åŠ¡æ˜¯ä¸ç©å®¶ (${playerName || 'ç©å®¶'}) äº’åŠ¨ï¼Œå¹¶ç”Ÿæˆæ¸¸æˆå†…å®¹ã€‚
ç©å®¶åŸºç¡€å¤–è²Œæç¤ºè¯(ç”±ä½ ç”Ÿæˆæˆ–å®Œå–„): ${playerBaseAppearancePrompt || '(å°šæœªç”Ÿæˆ)'}\nAIè§’è‰²åŸºç¡€å¤–è²Œæç¤ºè¯(ç”±ä½ ç”Ÿæˆæˆ–å®Œå–„): ${aiBaseAppearancePrompt || '(å°šæœªç”Ÿæˆ)'}\n${currentAiPersona ? `AI è§’è‰²è®¾å®š: ${currentAiPersona}\n` : ''}è¯·**ä¸¥æ ¼**æŒ‰ç…§ä»¥ä¸‹ JSON æ ¼å¼ç”Ÿæˆå“åº”ï¼Œä¸è¦åŒ…å«ä»»ä½•é¢å¤–çš„è§£é‡Šæˆ– Markdown æ ‡è®°åŒ…è£¹ JSON æœ¬èº«ï¼š\n\`\`\`json\n{\n  "scene_state": {\n    "background_prompt": "String (åœºæ™¯çš„è‹±æ–‡æè¿°, è¿™æ˜¯æ¸¸æˆèƒŒæ™¯å›¾, ä¸æ˜¯è§’è‰²ç«‹ç»˜èƒŒæ™¯!)",\n    "visible_characters": [\n      {\n        "character_id": "String ('player' or 'ai')",\n        "emotion": "String or Null (è§’è‰²ã€å½“å‰ã€‘çš„è¡¨æƒ…/åŠ¨ä½œ/ç»†å¾®å˜åŒ–, e.g., 'smiling slightly', 'surprised face', 'holding a pen', 'adjusting glasses')"\n      }\n      // ... å¯èƒ½åŒ…å« 'player' å’Œ/æˆ– 'ai'\n    ]\n  },\n  "dialogue_segments": [\n    {\n      "speaker": "String (AIè§’è‰²å, ${playerName ? "'" + playerName + "'" : "'ç©å®¶'"}, 'æ—ç™½', 'å†…å¿ƒæƒ³æ³•')",\n      "emotion": "String or Null (è¯´è¯è€…è¡¨æƒ…/åŠ¨ä½œ, å¯¹åº”æ­¤ã€å¯¹è¯ã€‘å†…å®¹)",\n      "text": "String (è¯¥ç‰‡æ®µçš„å¯¹è¯/æ—ç™½æ–‡æœ¬, æ”¯æŒMarkdown)"\n    }\n    // ... more segments\n  ],\n  "choices": [\n    "String (é€‰é¡¹1)", \n    "String (é€‰é¡¹2)"\n  ],\n  "story_metadata": {\n    "progress": 50, // Number: å®Œæˆåº¦ç™¾åˆ†æ¯”, 0-100\n    "currentAct": 2, // Number: å½“å‰ç« èŠ‚ç¼–å·\n    "totalActs": 3, // Number: æ€»ç« èŠ‚æ•°\n    "branchPath": "main", // String: å½“å‰æ•…äº‹åˆ†æ”¯\n    "remainingTurns": 8, // Number: é¢„è®¡å‰©ä½™å›åˆæ•°\n    "currentEnding": null // Objectæˆ–null: å½“è¿›åº¦<90%æ—¶ä¸ºnullï¼Œæ¥è¿‘ç»“å±€æ—¶ä¸ºåŒ…å«type/name/descriptionçš„å¯¹è±¡\n    /* ç»“å±€ç¤ºä¾‹ï¼š\n    "currentEnding": {\n      "type": "good", // String: 'good', 'neutral', æˆ– 'bad'\n      "name": "å¹¸ç¦çš„çº¦å®š", // String: ç»“å±€åç§°\n      "description": "åœ¨ç»å†äº†é‡é‡å›°éš¾å..." // String: ç»“å±€è¯¦ç»†æè¿°\n    }\n    */\n  },\n  "initial_setup_details": { \n     // !!! è¿™ä¸ªå­—æ®µã€åªåœ¨ã€‘å“åº”ç¬¬ä¸€ä¸ªè®¾ç½®è¯·æ±‚æ—¶å‡ºç° !!!\n     // **è¦æ±‚ï¼šç”Ÿæˆã€ç®€è¦ä¸”è¿è´¯ã€‘ã€åŒ…å«å…·ä½“ç‰¹å¾(å‘å‹/å‘è‰²/ç³è‰²/èº«æ/è„¸å‹)å’Œã€å…·ä½“æœè£…ã€‘æè¿°çš„åŸºç¡€æç¤ºè¯(50-80ä¸ªè‹±æ–‡å•è¯)ã€‚**ã€ç¦æ­¢ã€‘**åŒ…å«äººåæˆ–è§’è‰²åç§°ï¼Œä»¥åŠ 'same character', 'same face', 'same style' ç­‰æ— æ•ˆè¯è¯­ã€‚**\n     "player_base_appearance_prompt": "String (ç”Ÿæˆã€ç®€è¦ã€è¿è´¯ã€‘çš„ç©å®¶åŸºç¡€å¤–è²Œè‹±æ–‡æç¤ºè¯, e.g., '1girl, medium height, slim build, long wavy bright pink hair tied in high twin tails with red ribbons, large sparkling emerald green eyes, fair skin, wearing a standard white short-sleeve sailor school uniform with navy blue collar and cuffs, red necktie, navy blue pleated skirt, white knee-high socks, brown loafers')",\n     "ai_base_appearance_prompt": "String (ç”Ÿæˆã€ç®€è¦ã€è¿è´¯ã€‘çš„AIè§’è‰²åŸºç¡€å¤–è²Œè‹±æ–‡æç¤ºè¯, åŒä¸Šè¦æ±‚)"\n  }\n}\n\`\`\`\n*   **scene_state**: æè¿°å½“å‰åœºæ™¯è§†è§‰çŠ¶æ€ã€‚\n    *   **background_prompt**: å½“å‰åœºæ™¯çš„ã€æ¸¸æˆèƒŒæ™¯å›¾ã€‘æç¤ºè¯ã€‚\n    *   **visible_characters**: æ•°ç»„åŒ…å«å½“å‰å±å¹•ä¸Šå¯è§çš„è§’è‰²ã€‚æ¯ä¸ªå¯¹è±¡æŒ‡å®š \`character_id\` ('player' æˆ– 'ai') å’Œ \`emotion\`ã€‚ \`emotion\` å¿…é¡»æ˜¯ã€æå…¶ç®€æ´åœ°æè¿°å½“å‰è¡¨æƒ…ã€åŠ¨ä½œæˆ–éå¸¸å°çš„ä¸´æ—¶ç‰©å“ã€‘ï¼Œä¾‹å¦‚ 'smiling', 'sad', 'surprised', 'holding a book', 'waving hand', 'blushing', 'looking down shyly'ã€‚**ã€ç»å¯¹ç¦æ­¢ã€‘** åœ¨ \`emotion\` å­—æ®µä¸­é‡æ–°æè¿°è§’è‰²çš„æ ¸å¿ƒç‰¹å¾ï¼ˆå¦‚å‘å‹ã€å‘è‰²ã€ç³è‰²ï¼‰ã€ä¸»è¦æœè£…æˆ–æ•´ä½“è‰ºæœ¯é£æ ¼ï¼Œä¹Ÿ**ã€ç»å¯¹ç¦æ­¢ã€‘**åŒ…å« 'same character/face/style/clothing' ç­‰è¯è¯­ã€‚å®¢æˆ·ç«¯ä¼šå¼ºåˆ¶åº”ç”¨ä¸€è‡´çš„æ—¥å¼äºŒæ¬¡å…ƒç”»é£å’Œçº¯ç™½èƒŒæ™¯ã€‚\n*   **dialogue_segments**: å¯¹è¯å†…å®¹æ•°ç»„ã€‚\n*   **choices**: ç©å®¶é€‰é¡¹æ•°ç»„ã€‚\n*   **story_metadata**: æ•…äº‹è¿›åº¦æ•°æ®ï¼ŒåŒ…æ‹¬ï¼š\n    *   **progress**: æ•°å­—ç±»å‹ï¼Œå®Œæˆåº¦ç™¾åˆ†æ¯” (0-100)\n    *   **currentAct**: æ•°å­—ç±»å‹ï¼Œå½“å‰ç« èŠ‚ç¼–å·\n    *   **totalActs**: æ•°å­—ç±»å‹ï¼Œæ€»ç« èŠ‚æ•°\n    *   **branchPath**: å­—ç¬¦ä¸²ç±»å‹ï¼Œå½“å‰æ•…äº‹åˆ†æ”¯\n    *   **remainingTurns**: æ•°å­—ç±»å‹ï¼Œé¢„è®¡å‰©ä½™å›åˆæ•°\n    *   **currentEnding**: å¯¹è±¡ç±»å‹æˆ–nullï¼Œå½“è¿›åº¦æ¥è¿‘100%æ—¶ï¼Œå¡«å†™ç»“å±€ä¿¡æ¯\n*   **initial_setup_details**: ã€åªåœ¨é¦–æ¬¡å“åº”æ—¶æä¾›ã€‘ï¼ŒåŒ…å«ä½ ç”Ÿæˆçš„ã€ç®€è¦(50-80ä¸ªè‹±æ–‡å•è¯)ã€è¿è´¯ä¸”ä¸å«äººåæˆ–æ— æ•ˆé‡å¤è¯ã€‘çš„åŸºç¡€å¤–è²Œæç¤ºè¯ã€‚\n*   **é£æ ¼å’Œç«‹ç»˜èƒŒæ™¯**: å®¢æˆ·ç«¯ä¼šå¼ºåˆ¶ä½¿ç”¨å›ºå®šçš„ã€æ—¥å¼äºŒæ¬¡å…ƒè§†è§‰å°è¯´ç«‹ç»˜é£æ ¼ã€‘å’Œã€çº¯ç™½èƒŒæ™¯ã€‘æ¥ç”Ÿæˆè§’è‰²ç«‹ç»˜ã€‚ä½ çš„ä»»åŠ¡æ˜¯æä¾›è¯¦ç»†çš„åŸºç¡€æè¿°å’Œç®€æ´çš„çŠ¶æ€å˜åŒ–ï¼Œå¹¶é¿å…æ— æ•ˆå…³é”®è¯ã€‚

            *   **æ•°å­¦å…¬å¼**: å½“å¯¹è¯æˆ–æ—ç™½ä¸­éœ€è¦å±•ç¤ºæ•°å­¦å…¬å¼ã€åŒ–å­¦æ–¹ç¨‹å¼æˆ–å…¶ä»–ç§‘å­¦ç¬¦å·æ—¶ï¼Œè¯·ä½¿ç”¨ LaTeX æ ¼å¼ã€‚

*   å¯¹äº**è¡Œå†…å…¬å¼** (åµŒå…¥æ–‡æœ¬ä¸­)ï¼Œè¯·ä½¿ç”¨å•ä¸ªç¾å…ƒç¬¦å·åŒ…è£¹ï¼Œä¾‹å¦‚ï¼š\`çˆ±å› æ–¯å¦çš„è´¨èƒ½æ–¹ç¨‹æ˜¯ \$E=mc^2\`ã€‚
*   å¯¹äº**å—çº§å…¬å¼** (å•ç‹¬æˆè¡Œå±•ç¤º)ï¼Œè¯·ä½¿ç”¨åŒç¾å…ƒç¬¦å·åŒ…è£¹ï¼Œä¾‹å¦‚ï¼š\`\$\$\int_{-\infty}^{\infty} e^{-x^2} dx = \\sqrt{\pi}\$\$ \`
                *   è¯·ç¡®ä¿ LaTeX è¯­æ³•æ­£ç¡®ï¼Œå¹¶å°½é‡ä½¿ç”¨å¸¸ç”¨ã€å…¼å®¹æ€§å¥½çš„å‘½ä»¤ã€‚
å½“æ•…äº‹è¿›è¡Œåˆ°70%ä»¥ä¸Šæ—¶ï¼Œå¼€å§‹å¼•å¯¼ç©å®¶èµ°å‘æŸä¸ªé¢„è®¾ç»“å±€ã€‚
ä¸è¦è¶…è¿‡é¢„å®šå›åˆæ•°å°±è¦ç»“æŸæ•…äº‹ï¼ˆçŸ­ç¯‡çº¦10å›åˆï¼Œä¸­ç¯‡çº¦15å›åˆï¼Œé•¿ç¯‡çº¦20å›åˆï¼‰ã€‚

æ³¨æ„ï¼šä¸è¦è¯´"åŒä¸Š"æˆ–"ä¿æŒä¸å˜"ç­‰æ¨¡ç³Šè¯è¯­ï¼Œæ€»æ˜¯è¯¦ç»†æè¿°å®Œæ•´çš„åœºæ™¯å’Œè§’è‰²çŠ¶æ€ã€‚`;

                // æ·»åŠ æ•…äº‹è·Ÿè¸ªæ•°æ®åˆ°æ¯ä¸ªè¯·æ±‚
                const storyTrackingPrompt = `
ã€æ•…äº‹è¿›åº¦è·Ÿè¸ªã€‘
- å½“å‰è¿›åº¦: ${StoryTracker.metadata.progress}%
- å½“å‰åˆ†æ”¯: ${StoryTracker.metadata.branchPath}
- å‰©ä½™å›åˆ: ${StoryTracker.metadata.remainingTurns}
- ç›®æ ‡ï¼šç¡®ä¿æ•…äº‹åœ¨å‰©ä½™å›åˆå†…æ¨è¿›åˆ°ç»“å±€ï¼Œä¸è¦æ— é™å»¶ç»­

æ¯æ¬¡å›åº”éƒ½å¿…é¡»åœ¨JSONä¸­åŒ…å«story_metadataå­—æ®µï¼Œæ›´æ–°è¿›åº¦ä¿¡æ¯ã€‚
å½“è¿›åº¦è¶…è¿‡70%æ—¶ï¼Œå¼€å§‹å¼•å¯¼æ•…äº‹èµ°å‘æŸä¸ªé¢„è®¾ç»“å±€ã€‚
`;

                try {
                    // æ„å»ºAPIè¯·æ±‚ä½“
                    if (finalApiUrl.includes('generativelanguage.googleapis.com')) {
                        // Gemini APIç»“æ„
                        if (!finalApiUrl.includes('/v1beta/models')) {
                            finalApiUrl = finalApiUrl.replace(/\/$/, '') + `/v1beta/models/${currentModel}:generateContent?key=${currentApiKey}`;
                        } else {
                            finalApiUrl += `?key=${currentApiKey}`;
                        }

                        let geminiContents = [];

                        // æ·»åŠ æ•…äº‹è·Ÿè¸ªæç¤º
                        geminiContents.push({
                            role: 'user',
                            parts: [{ text: storyTrackingPrompt }]
                        });
                        geminiContents.push({
                            role: 'model',
                            parts: [{ text: "æˆ‘ä¼šæŒ‰ç…§æŒ‡ç¤ºè·Ÿè¸ªæ•…äº‹è¿›åº¦å¹¶ç¡®ä¿é€‚å½“ç»“æŸã€‚" }]
                        });

                        // æ·»åŠ å¯¹è¯å†å²
                        promptHistory.slice(0, isFirstCall ? -1 : undefined)
                            .slice(-7).forEach(h => {
                                const role = (h.role === 'model' ? 'model' : 'user');
                                if (geminiContents.length > 0 && geminiContents[geminiContents.length - 1].role === role) {
                                    if (role === 'model') {
                                        geminiContents.push({ role: 'user', parts: [{ text: "(Continue...)" }] });
                                    } else {
                                        geminiContents.push({ role: 'model', parts: [{ text: "{}" }] });
                                    }
                                }
                                geminiContents.push({ role: role, parts: [{ text: h.parts[0].text }] });
                            });

                        let currentUserParts = [];
                        if (isFirstCall) {
                            const playerData = getImageDataFromBase64(playerImageBase64);
                            if (playerData) {
                                currentUserParts.push({
                                    inline_data: {
                                        mime_type: playerData.mimeType,
                                        data: playerData.data
                                    }
                                });
                                console.log("å°†ç©å®¶å›¾ç‰‡æ·»åŠ åˆ°Geminiè¯·æ±‚");
                            }

                            const aiData = getImageDataFromBase64(aiImageBase64);
                            if (aiData) {
                                currentUserParts.push({
                                    inline_data: {
                                        mime_type: aiData.mimeType,
                                        data: aiData.data
                                    }
                                });
                                console.log("å°†AIå›¾ç‰‡æ·»åŠ åˆ°Geminiè¯·æ±‚");
                            }
                        }

                        currentUserParts.push({ text: userPromptText }); // æ–‡æœ¬æç¤ºæœ€åæ·»åŠ 

                        if (geminiContents.length === 0 || geminiContents[geminiContents.length - 1].role === 'model') {
                            geminiContents.push({ role: 'user', parts: currentUserParts });
                        } else {
                            console.warn("Geminiå¯èƒ½å­˜åœ¨éäº¤æ›¿å¯¹è¯ç»“æ„é—®é¢˜ã€‚");
                            geminiContents.push({ role: 'user', parts: currentUserParts });
                        }

                        requestBody = JSON.stringify({
                            contents: geminiContents,
                            generationConfig: {
                                responseMimeType: "application/json"
                            }
                        });
                    } else if (finalApiUrl.includes('/v1')) {
                        // OpenAIå…¼å®¹APIç»“æ„
                        headers['Authorization'] = `Bearer ${currentApiKey}`;
                        if (!finalApiUrl.includes('/chat/completions')) {
                            finalApiUrl = finalApiUrl.replace(/\/v1\/?$/, '') + '/v1/chat/completions';
                        }

                        let openAiMessages = [];

                        // ç³»ç»ŸæŒ‡ä»¤åŒ…å«æ•…äº‹è·Ÿè¸ªæç¤º
                        openAiMessages.push({
                            "role": "system",
                            "content": systemInstruction + "\n\n" + storyTrackingPrompt
                        });

                        // æ·»åŠ å¯¹è¯å†å²
                        promptHistory.slice(0, isFirstCall ? -1 : undefined)
                            .slice(-7).forEach(h => {
                                openAiMessages.push({
                                    role: h.role === 'model' ? 'assistant' : 'user',
                                    content: h.parts[0].text
                                });
                            });

                        let currentUserContent = [];
                        currentUserContent.push({
                            type: "text",
                            text: userPromptText
                        });

                        // åœ¨é¦–æ¬¡è°ƒç”¨æ—¶å¤„ç†å›¾ç‰‡
                        if (isFirstCall) {
                            if (playerImageBase64) {
                                currentUserContent.push({
                                    type: "image_url",
                                    image_url: { url: playerImageBase64 }
                                });
                                console.log("å°†ç©å®¶å›¾ç‰‡æ·»åŠ åˆ°OpenAIè¯·æ±‚");
                            }
                            if (aiImageBase64) {
                                currentUserContent.push({
                                    type: "image_url",
                                    image_url: { url: aiImageBase64 }
                                });
                                console.log("å°†AIå›¾ç‰‡æ·»åŠ åˆ°OpenAIè¯·æ±‚");
                            }
                        }

                        openAiMessages.push({
                            role: "user",
                            content: currentUserContent
                        });

                        requestBody = JSON.stringify({
                            model: currentModel,
                            messages: openAiMessages,
                            max_tokens: 65536,
                            response_format: { type: "json_object" }
                        });
                    } else {
                        throw new Error("æ— æ³•è¯†åˆ«çš„ API åŸºç¡€åœ°å€æ ¼å¼ã€‚");
                    }

                    console.log("è°ƒç”¨Galgame LLM API:", finalApiUrl);

                    const response = await fetch(finalApiUrl, {
                        method: 'POST',
                        headers,
                        body: requestBody
                    });

                    console.log("LLM APIå“åº”çŠ¶æ€:", response.status);

                    // å¢å¼ºçš„å“åº”å¤„ç†å’Œè°ƒè¯•
                    let data;
                    try {
                        data = await response.json();
                        console.log("LLM APIåŸå§‹å“åº”æ•°æ®:", JSON.stringify(data, null, 2).substring(0, 500) + "...");
                    } catch (jsonError) {
                        console.error("æ— æ³•å°†APIå“åº”è§£æä¸ºJSON:", jsonError);
                        try {
                            const textResponse = await response.text();
                            console.error("APIåŸå§‹æ–‡æœ¬å“åº”:", textResponse.substring(0, 500) + "...");
                            throw new Error(`APIå“åº”ä¸æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼: ${textResponse.substring(0, 100)}...`);
                        } catch (textError) {
                            console.error("æ— æ³•è·å–æ–‡æœ¬å“åº”ã€‚");
                            throw new Error("APIå“åº”ä¸æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼ï¼Œä¸”æ— æ³•è¯»å–æ–‡æœ¬å†…å®¹ã€‚");
                        }
                    }

                    // æ£€æŸ¥å“åº”æ˜¯å¦æˆåŠŸ
                    if (!response.ok) {
                        let errorMsg = `API è¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText}`;
                        if (data && data.error && data.error.message) {
                            errorMsg += `\nè¯¦æƒ…: ${data.error.message}`;
                        } else {
                            errorMsg += `\nè¯¦æƒ…: ${JSON.stringify(data)}`;
                        }
                        throw new Error(errorMsg);
                    }

                    // æå–å†…å®¹
                    let responseContent = null;
                    if (data && data.error && (data.error.message || data.error.code)) {
                        console.error("APIè¿”å›é”™è¯¯å¯¹è±¡:", data.error);
                        throw new Error(`APIé”™è¯¯: ${data.error.message || `Code ${data.error.code}`}`);
                    } else if (data.candidates?.[0]?.finishReason && data.candidates[0].finishReason !== "STOP") {
                        // Gemini: æ£€æŸ¥å®ŒæˆåŸå› æ˜¯å¦å¼‚å¸¸
                        console.error("Geminiè¯·æ±‚éæ­£å¸¸ç»“æŸ:", data.candidates[0].finishReason, data.promptFeedback);
                        let reason = data.candidates[0].finishReason;
                        if (data.promptFeedback?.blockReason) {
                            reason += ` (Block Reason: ${data.promptFeedback.blockReason})`;
                        }
                        throw new Error(`è¯·æ±‚è¢«ç»ˆæ­¢: ${reason}`);
                    } else if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
                        responseContent = data.candidates[0].content.parts[0].text;
                    } else if (data.choices?.[0]?.finish_reason && data.choices[0].finish_reason !== "stop") {
                        // OpenAI: æ£€æŸ¥å®ŒæˆåŸå› 
                        console.error("OpenAIè¯·æ±‚éæ­£å¸¸ç»“æŸ:", data.choices[0].finish_reason);
                        throw new Error(`è¯·æ±‚è¢«ç»ˆæ­¢: ${data.choices[0].finish_reason}`);
                    } else if (data.choices?.[0]?.message?.content) {
                        responseContent = data.choices[0].message.content;
                    } else if (data.choices?.[0]?.error) {
                        console.error("APIåœ¨choicesä¸­è¿”å›é”™è¯¯:", data.choices[0].error);
                        throw new Error(`APIé”™è¯¯: ${data.choices[0].error.message || JSON.stringify(data.choices[0].error)}`);
                    } else {
                        console.error("æ— æ³•ä»APIå“åº”ä¸­æå–å†…å®¹ã€‚", data);
                        throw new Error("æ— æ³•ä» API å“åº”ä¸­æå–æœ‰æ•ˆå†…å®¹ã€‚");
                    }

                    console.log("æå–çš„å“åº”å†…å®¹(è§£æå‰):", responseContent.substring(0, 500) + "...");

                    // JSONè§£æå’ŒéªŒè¯
                    let parsedData;
                    try {
                        const cleanedText = responseContent.replace(/^```json\s*|```$/gs, '').trim();
                        if (!cleanedText) {
                            throw new Error("æå–åˆ°çš„å†…å®¹ä¸ºç©ºå­—ç¬¦ä¸²ã€‚");
                        }
                        parsedData = JSON.parse(cleanedText);

                        // å°†å“åº”æ·»åŠ åˆ°å¯¹è¯å†å²
                        conversationHistory.push({
                            role: "user",
                            parts: [{ text: userPromptText }]
                        });
                        conversationHistory.push({
                            role: "model",
                            parts: [{ text: cleanedText }]
                        });

                        // æ›´æ–°æ•…äº‹è·Ÿè¸ªå™¨
                        StoryTracker.updateFromAIResponse(parsedData);

                        return parsedData;
                    } catch (parseError) {
                        console.error("JSONè§£æé”™è¯¯:", parseError);
                        console.log("å°è¯•è§£æçš„æ–‡æœ¬:", responseContent);

                        // å°è¯•ä½¿ç”¨æ­£åˆ™æå–JSON
                        const jsonRegex = /{[\s\S]*}/;
                        const match = responseContent.match(jsonRegex);
                        if (match) {
                            try {
                                parsedData = JSON.parse(match[0]);
                                console.log("ä½¿ç”¨æ­£åˆ™æå–çš„JSONæˆåŠŸè§£æã€‚");

                                conversationHistory.push({
                                    role: "user",
                                    parts: [{ text: userPromptText }]
                                });
                                conversationHistory.push({
                                    role: "model",
                                    parts: [{ text: match[0] }]
                                });

                                StoryTracker.updateFromAIResponse(parsedData);
                                return parsedData;
                            } catch (regexParseError) {
                                console.error("æ­£åˆ™æå–çš„JSONè§£æå¤±è´¥:", regexParseError);
                            }
                        }

                        throw new Error("æ— æ³•è§£æAPIå“åº”ä¸ºæœ‰æ•ˆJSONã€‚");
                    }
                } catch (error) {
                    console.error("è°ƒç”¨LLM APIæ—¶å‡ºé”™:", error);
                    showGameError(`APIé”™è¯¯: ${error.message}`);

                    // è¿”å›é”™è¯¯çŠ¶æ€
                    const errorResponse = {
                        scene_state: {
                            background_prompt: "error",
                            visible_characters: []
                        },
                        dialogue_segments: [{
                            speaker: "ç³»ç»Ÿ",
                            text: `å‘ç”Ÿé”™è¯¯: ${error.message}`
                        }],
                        story_metadata: StoryTracker.metadata
                    };

                    return errorResponse;
                }
            }

            // --- å¤„ç†æ¸¸æˆå“åº” ---
            // --- å¤„ç†æ¸¸æˆå“åº” ---
            // --- å¤„ç†æ¸¸æˆå“åº” ---
            async function processGameResponse(data) {
                console.log("å¤„ç†æ¸¸æˆå“åº”:", data);
                // setLoading(true); // Optional: Set loading at the start

                // --- æ·»åŠ å¼€å§‹: å¤„ç†å¹¶å­˜å‚¨åˆå§‹å¤–è§‚æç¤ºè¯ ---
                if (data.initial_setup_details) {
                    console.log("Processing initial setup details from API response.");
                    if (data.initial_setup_details.player_base_appearance_prompt) {
                        // Store the received prompt into the global variable
                        playerBaseAppearancePrompt = data.initial_setup_details.player_base_appearance_prompt;
                        console.log("Stored playerBaseAppearancePrompt:", playerBaseAppearancePrompt);
                        // Optional: Store in localStorage if you want it to persist across page loads (but usually not needed for one session)
                        // localStorage.setItem(GALGAME_STORAGE_PREFIX + 'playerBaseAppearancePrompt', playerBaseAppearancePrompt);
                    } else {
                        console.warn("Initial setup details received, but no player_base_appearance_prompt found.");
                    }
                    if (data.initial_setup_details.ai_base_appearance_prompt) {
                        // Store the received prompt into the global variable
                        aiBaseAppearancePrompt = data.initial_setup_details.ai_base_appearance_prompt;
                        console.log("Stored aiBaseAppearancePrompt:", aiBaseAppearancePrompt);
                        // Optional: Store in localStorage
                        // localStorage.setItem(GALGAME_STORAGE_PREFIX + 'aiBaseAppearancePrompt', aiBaseAppearancePrompt);
                    } else {
                        console.warn("Initial setup details received, but no ai_base_appearance_prompt found.");
                    }
                }
                // --- æ·»åŠ ç»“æŸ ---

                // å­˜å‚¨å½“å‰å›åˆçš„æ•°æ®
                currentTurnParsedData = data;
                currentTurnChoices = data.choices || [];
                currentDialogueSegments = data.dialogue_segments || [];
                currentSegmentIndex = 0;

                try {
                    // --- åœºæ™¯çŠ¶æ€å¤„ç† ---
                    if (data.scene_state) {
                        // æ›´æ–°èƒŒæ™¯
                        if (data.scene_state.background_prompt) {
                            await loadDynamicImage(gameBackground, data.scene_state.background_prompt, "background");
                        }

                        // æ›´æ–°è§’è‰²æ˜¾ç¤º
                        const characters = data.scene_state.visible_characters || [];
                        let aiCharacterVisible = false;
                        let playerCharacterVisible = false;
                        const characterPromises = [];

                        characters.forEach(char => {
                            const charId = char.character_id; // 'player' or 'ai'
                            const emotion = char.emotion || null;
                            // ---> ä¿®æ”¹: ä»å…¨å±€å˜é‡è·å–åŸºç¡€æç¤º <---
                            const basePrompt = (charId === 'ai' ? aiBaseAppearancePrompt : playerBaseAppearancePrompt);

                            // ---> ç°åœ¨ basePrompt åº”è¯¥æœ‰å€¼äº† (å¦‚æœåˆå§‹è®¾ç½®è¢«æ­£ç¡®å¤„ç†) <---
                            if (basePrompt) {
                                const finalPrompt = emotion ? `${basePrompt}, ${emotion}` : basePrompt;
                                console.log(`å°è¯•åŠ è½½è§’è‰² ${charId}ï¼ŒåŸºç¡€æç¤ºå­˜åœ¨ï¼Œæœ€ç»ˆæç¤º: ${finalPrompt.substring(0, 100)}...`);
                                const spriteElement = (charId === 'ai' ? aiCharacterSprite : playerCharacterSprite);
                                characterPromises.push(loadDynamicImage(spriteElement, finalPrompt, "character"));
                                if (charId === 'ai') aiCharacterVisible = true;
                                else playerCharacterVisible = true;
                            } else {
                                // è¿™ä¸ªè­¦å‘Šç°åœ¨åº”è¯¥åªåœ¨åˆå§‹è®¾ç½®æœªæ”¶åˆ°æˆ–å¤„ç†å¤±è´¥æ—¶å‡ºç°
                                console.warn(`è§’è‰² ${charId} ç¼ºå°‘åŸºç¡€å¤–è§‚æç¤ºè¯ï¼Œæ— æ³•åŠ è½½ã€‚ (Base prompt variable is empty)`);
                                const spriteElement = (charId === 'ai' ? aiCharacterSprite : playerCharacterSprite);
                                spriteElement.classList.add('hidden');
                            }
                        });

                        await Promise.all(characterPromises);
                        console.log("æ‰€æœ‰è§’è‰²å›¾ç‰‡åŠ è½½å®Œæˆã€‚");

                        if (!aiCharacterVisible) aiCharacterSprite.classList.add('hidden');
                        else aiCharacterSprite.classList.remove('hidden'); // æ˜ç¡®ç§»é™¤ hidden
                        if (!playerCharacterVisible) playerCharacterSprite.classList.add('hidden');
                        else playerCharacterSprite.classList.remove('hidden'); // æ˜ç¡®ç§»é™¤ hidden


                    } else {
                        aiCharacterSprite.classList.add('hidden');
                        playerCharacterSprite.classList.add('hidden');
                    }
                    // --- åœºæ™¯å¤„ç†ç»“æŸ ---

                    // --- å¯¹è¯å’ŒæŒ‰é’®å¤„ç† (ä½¿ç”¨ä¹‹å‰çš„ä¿®æ”¹ç‰ˆæœ¬) ---
                    if (currentDialogueSegments.length > 0) {
                        displayDialogueSegment(currentSegmentIndex);
                        choicesContainer.innerHTML = ''; // Clear choices initially

                        if (currentDialogueSegments.length > 1) {
                            nextButton.disabled = false;
                            nextButton.textContent = 'ç»§ç»­';
                            console.log("å“åº”æœ‰å¤šæ®µå¯¹è¯ï¼ŒæŒ‰é’®è®¾ä¸º'ç»§ç»­'ã€‚");
                        } else { // Only one segment
                            if (currentTurnChoices.length > 0) {
                                displayChoices(); // Display choices now
                                nextButton.disabled = true;
                                nextButton.textContent = 'è¯·é€‰æ‹©';
                                console.log("å“åº”åªæœ‰ä¸€æ®µå¯¹è¯ä¸”æœ‰é€‰é¡¹ï¼Œæ˜¾ç¤ºé€‰é¡¹ï¼Œç¦ç”¨æŒ‰é’®ã€‚");
                            } else {
                                nextButton.disabled = false;
                                nextButton.textContent = 'ä¸‹ä¸€æ­¥';
                                console.log("å“åº”åªæœ‰ä¸€æ®µå¯¹è¯æ— é€‰é¡¹ï¼ŒæŒ‰é’®è®¾ä¸º'ä¸‹ä¸€æ­¥'ã€‚");
                            }
                        }
                    } else {
                        console.warn("APIå“åº”ä¸­æ²¡æœ‰å¯¹è¯ç‰‡æ®µã€‚");
                        dialogueText.innerHTML = "(æ²¡æœ‰æ”¶åˆ°å¯¹è¯å†…å®¹)";
                        speakerName.textContent = "ç³»ç»Ÿ";
                        choicesContainer.innerHTML = '';
                        nextButton.textContent = 'ä¸‹ä¸€æ­¥';
                        nextButton.disabled = false;
                    }
                    // --- å¯¹è¯å’ŒæŒ‰é’®å¤„ç†ç»“æŸ ---


                    // å…¶ä»–å¤„ç†
                    if (data.chapter_marker) renderChapterMarker(data.chapter_marker);
                    if (data.choice_impact) showChoiceImpact(data.choice_impact);
                    StoryTracker.updateFromAIResponse(data);

                } catch (error) {
                    console.error("å¤„ç†æ¸¸æˆå“åº”æ—¶å‡ºé”™:", error);
                    showGameError(`å¤„ç†å“åº”æ—¶å‡ºé”™: ${error.message}`);
                    nextButton.disabled = false;
                    nextButton.textContent = 'é‡è¯•';
                } finally {
                    setLoading(false);
                    console.log("processGameResponse å®Œæˆ, æœ€ç»ˆæŒ‰é’®çŠ¶æ€:", nextButton.disabled);
                }
            }

            // æ˜¾ç¤ºå•ä¸ªå¯¹è¯éƒ¨åˆ†
            // æ˜¾ç¤ºå•ä¸ªå¯¹è¯éƒ¨åˆ†
            function displayDialogueSegment(index) {
                if (!currentDialogueSegments || index >= currentDialogueSegments.length) {
                    console.error("æ— æ•ˆçš„å¯¹è¯æ®µè½ç´¢å¼•:", index);
                    return;
                }

                const segment = currentDialogueSegments[index];
                speakerName.textContent = segment.speaker || "æ—ç™½";

                // ä½¿ç”¨DOMPurifyå’Œmarkedå¤„ç†markdown
                const markedOptions = {
                    breaks: true,
                    gfm: true
                };
                const purifiedHtml = DOMPurify.sanitize(marked.parse(segment.text || "", markedOptions));
                dialogueText.innerHTML = purifiedHtml;
                try {
                    renderMathInElement(dialogueText, {
                        // é…ç½® KaTeX è‡ªåŠ¨æ¸²æŸ“
                        delimiters: [
                            { left: "$$", right: "$$", display: true },  // Display mode (å—çº§å…¬å¼)
                            { left: "$", right: "$", display: false },   // Inline mode (è¡Œå†…å…¬å¼)
                            { left: "\\(", right: "\\)", display: false }, // Inline mode (å…¼å®¹ LaTeX)
                            { left: "\\[", right: "\\]", display: true }   // Display mode (å…¼å®¹ LaTeX)
                        ],
                        // å¦‚æœé‡åˆ° KaTeX ä¸æ”¯æŒçš„å‘½ä»¤ï¼Œåˆ™æŠ›å‡ºé”™è¯¯
                        throwOnError: false
                    });
                    console.log("KaTeX rendering applied to dialogue segment.");
                } catch (error) {
                    console.error("KaTeX rendering failed:", error);
                    // å¦‚æœæ¸²æŸ“å¤±è´¥ï¼ŒHTML ä»ç„¶æ˜¯æ¸…ç†è¿‡çš„ Markdown å†…å®¹
                }

                // æ¸…é™¤ä¹‹å‰çš„é€‰æ‹© (æ¯æ¬¡åˆ‡æ¢éƒ½æ¸…ç©º)
                choicesContainer.innerHTML = '';

                // --- ç§»é™¤è¿™æ®µä»£ç  ---
                // if (index === currentDialogueSegments.length - 1 && currentTurnChoices.length > 0) {
                //     displayChoices();
                // }
                // --- ç§»é™¤ç»“æŸ ---
            }
            // åªæ·»åŠ è¿™ä¸ªå‡½æ•°ï¼Œä¸ä¿®æ”¹ä»»ä½•å…¶ä»–ä»£ç 
            function toggleHistoryPanel() {
                if (isLoading) return;
                if (!isGameStarted || !currentApiKey || !currentModel) {
                    showGameError("æ¸¸æˆå°šæœªå¼€å§‹ï¼");
                    return;
                }

                historyPanel.classList.toggle('visible');
                if (historyPanel.classList.contains('visible')) {
                    displayHistory();
                }
            }
            // æ˜¾ç¤ºé€‰æ‹©é¡¹
            // æ˜¾ç¤ºé€‰æ‹©é¡¹ (å¤„ç†å­—ç¬¦ä¸²æ•°ç»„)
            // æ˜¾ç¤ºé€‰æ‹©é¡¹ (å¤„ç†å­—ç¬¦ä¸²æ•°ç»„ï¼Œå¹¶ä¼ é€’å‚æ•°ç»™å¤„ç†å™¨)
            // æ˜¾ç¤ºé€‰æ‹©é¡¹ (å†æ¬¡åŠ å¼ºç›‘å¬å™¨å†…éƒ¨æ—¥å¿—)
            // æ˜¾ç¤ºé€‰æ‹©é¡¹ (å¤„ç†å­—ç¬¦ä¸²æ•°ç»„ï¼Œå¹¶ä¼ é€’å‚æ•°ç»™å¤„ç†å™¨)
            // æ˜¾ç¤ºé€‰æ‹©é¡¹ (å†æ¬¡åŠ å¼ºç›‘å¬å™¨å†…éƒ¨æ—¥å¿—)
            function displayChoices() {
                choicesContainer.innerHTML = ''; // Clear first
                if (!currentTurnChoices || currentTurnChoices.length === 0) {
                    console.log("No choices to display.");
                    return;
                }
                console.log("Displaying choices:", currentTurnChoices);

                const markedOptions = { // ç¡®ä¿ markedOptions å®šä¹‰æˆ–å¯è®¿é—®
                    breaks: true,
                    gfm: true
                };

                currentTurnChoices.forEach((choiceText, idx) => {
                    // åœ¨å¾ªç¯å¼€å§‹æ—¶è®°å½•ï¼Œä»¥é˜²åç»­è¢«ä¿®æ”¹
                    const capturedText = choiceText;
                    const capturedIndex = idx;

                    console.log(`[displayChoices] Loop ${capturedIndex}, capturedText: "${capturedText}", type: ${typeof capturedText}`);

                    if (typeof capturedText !== 'string' || capturedText.trim() === '') {
                        console.warn(`[displayChoices] Skipping invalid item at index ${capturedIndex}:`, capturedText);
                        return;
                    }

                    const choiceButton = document.createElement('button');
                    choiceButton.className = 'choice-button';

                    // --- ä¿®æ”¹å¼€å§‹ ---
                    // 1. ä½¿ç”¨ innerHTML è€Œä¸æ˜¯ textContent
                    // 2. åƒå¯¹è¯æ–‡æœ¬ä¸€æ ·ï¼Œå…ˆé€šè¿‡ marked å’Œ DOMPurify å¤„ç†
                    const purifiedChoiceHtml = DOMPurify.sanitize(marked.parse(capturedText || "", markedOptions));
                    choiceButton.innerHTML = purifiedChoiceHtml;
                    // --- ä¿®æ”¹ç»“æŸ ---

                    choiceButton.dataset.choiceIndex = capturedIndex;

                    choiceButton.addEventListener('click', (event) => {
                        console.log(`[Listener Executed] Button clicked!`);
                        console.log(`[Listener Executed]   - Button textContent at click time: "${event.target.textContent}"`);
                        console.log(`[Listener Executed]   - Captured text from forEach loop: "${capturedText}" (type: ${typeof capturedText})`);
                        console.log(`[Listener Executed]   - Captured index from forEach loop: ${capturedIndex}`);
                        console.log(`[Listener Executed]   - About to call handleChoiceClick with: text="${capturedText}", index=${capturedIndex}`);
                        handleChoiceClick(capturedText, capturedIndex);
                    });

                    choicesContainer.appendChild(choiceButton);
                    console.log(`[displayChoices] Appended button for index ${capturedIndex}: "${capturedText}"`);
                });

                // --- æ·»åŠ å¼€å§‹ ---
                // 3. åœ¨æ‰€æœ‰æŒ‰é’®æ·»åŠ åˆ°å®¹å™¨åï¼Œå¯¹å®¹å™¨åº”ç”¨ KaTeX æ¸²æŸ“
                try {
                    renderMathInElement(choicesContainer, {
                        delimiters: [
                            { left: "$$", right: "$$", display: true },
                            { left: "$", right: "$", display: false },
                            { left: "\\(", right: "\\)", display: false },
                            { left: "\\[", right: "\\]", display: true }
                        ],
                        throwOnError: false
                    });
                    console.log("KaTeX rendering applied to choices container.");
                } catch (error) {
                    console.error("KaTeX rendering failed for choices container:", error);
                }
                // --- æ·»åŠ ç»“æŸ ---

                console.log("Finished appending choice buttons. Container children:", choicesContainer.children.length);
            }

            // å¤„ç†é€‰æ‹©ç‚¹å‡» (ä»äº‹ä»¶ç›®æ ‡è·å–æ–‡æœ¬)
            // å¤„ç†é€‰æ‹©ç‚¹å‡» (æ¥æ”¶æ–‡æœ¬å’Œç´¢å¼•ä½œä¸ºå‚æ•°)
            // å¤„ç†é€‰æ‹©ç‚¹å‡» (æ¥æ”¶æ–‡æœ¬å’Œç´¢å¼•ä½œä¸ºå‚æ•°)
            async function handleChoiceClick(choiceText, choiceIndex) {
                console.log(`[handleChoiceClick START] Received choiceText: "${choiceText}" (type: ${typeof choiceText}), choiceIndex: ${choiceIndex}`);

                if (isLoading) {
                    console.log("[handleChoiceClick] Loading... Click ignored.");
                    return;
                }

                // å†æ¬¡ä¸¥æ ¼æ£€æŸ¥ä¼ å…¥çš„å€¼
                if (typeof choiceText !== 'string' || choiceText.trim() === '') {
                    console.error("[handleChoiceClick] ERROR: Invalid choiceText received:", choiceText);
                    showGameError("å†…éƒ¨é”™è¯¯ï¼šå¤„ç†é€‰é¡¹æ—¶æ–‡æœ¬æ— æ•ˆã€‚");
                    // å¯ä»¥åœ¨è¿™é‡Œå°è¯•æ¢å¤UIï¼Œæ¯”å¦‚é‡æ–°æ˜¾ç¤ºé€‰é¡¹
                    // displayChoices();
                    // nextButton.disabled = true;
                    return; // é˜»æ­¢åç»­æ‰§è¡Œ
                }

                console.log(`[handleChoiceClick] Confirmed valid selection: "${choiceText}" (Index: ${choiceIndex})`);

                setLoading(true);
                choicesContainer.innerHTML = ''; // æ¸…é™¤é€‰é¡¹
                try {
                    const promptText = JSON.stringify({
                        player_choice: choiceText
                    });

                    // æ·»åŠ åˆ°å†å²
                    conversationHistory.push({
                        role: "user",
                        parts: [{ text: `é€‰æ‹©äº†: "${choiceText}"` }]
                    });

                    // å‡†å¤‡APIå†å²
                    const choicePromptHistoryForApi = [
                        ...conversationHistory.slice(0, -1),
                        { role: "user", parts: [{ text: promptText }] }
                    ];

                    // è°ƒç”¨API
                    const response = await callLLMApi_Galgame(choicePromptHistoryForApi);
                    processGameResponse(response);

                } catch (error) {
                    console.error("[handleChoiceClick] Error during API call or response processing:", error);
                    showGameError(`å¤„ç†é€‰æ‹©æ—¶å‡ºé”™: ${error.message}`);
                    setLoading(false);
                    // é”™è¯¯æ¢å¤ï¼šé‡æ–°æ˜¾ç¤ºé€‰é¡¹
                    try {
                        console.log("[handleChoiceClick Error Recovery] Attempting to re-display choices.");
                        displayChoices(); // ç¡®ä¿æ­¤æ—¶ currentTurnChoices ä»ç„¶æ˜¯æ­£ç¡®çš„
                        nextButton.disabled = true; // ç¡®ä¿æŒ‰é’®ç¦ç”¨
                    } catch (displayError) {
                        console.error("[handleChoiceClick Error Recovery] Failed to re-display choices:", displayError);
                    }
                }
            }

            // å¤„ç†é€‰æ‹©ç‚¹å‡»
            // å¤„ç†é€‰æ‹©ç‚¹å‡» (æ¥æ”¶æ–‡æœ¬å’Œç´¢å¼•ä½œä¸ºå‚æ•° - å¢åŠ é˜²å¾¡æ€§èµ‹å€¼)
            async function handleChoiceClick(incomingChoiceText, incomingChoiceIndex) { // ä½¿ç”¨ä¸åŒçš„å‚æ•°å
                // --- é˜²å¾¡æ€§èµ‹å€¼å¹¶æ£€æŸ¥ ---
                const localChoiceText = incomingChoiceText;
                const localChoiceIndex = incomingChoiceIndex;
                console.log(`[handleChoiceClick START] Received incomingChoiceText: "${incomingChoiceText}" (type: ${typeof incomingChoiceText})`);
                console.log(`[handleChoiceClick START] Copied to localChoiceText: "${localChoiceText}" (type: ${typeof localChoiceText})`);
                console.log(`[handleChoiceClick START] Received incomingChoiceIndex: ${incomingChoiceIndex}, Copied to localChoiceIndex: ${localChoiceIndex}`);
                // --- æ£€æŸ¥ç»“æŸ ---

                if (isLoading) {
                    console.log("[handleChoiceClick] Loading... Click ignored.");
                    return;
                }

                // --- ä½¿ç”¨å±€éƒ¨å˜é‡è¿›è¡Œæ£€æŸ¥ ---
                if (typeof localChoiceText !== 'string' || localChoiceText.trim() === '') {
                    console.error("[handleChoiceClick] ERROR: Invalid localChoiceText after copy:", localChoiceText);
                    showGameError("å†…éƒ¨é”™è¯¯ï¼šå¤„ç†é€‰é¡¹æ—¶æ–‡æœ¬æ— æ•ˆ(æœ¬åœ°å‰¯æœ¬)ã€‚");
                    return;
                }
                // --- æ£€æŸ¥ç»“æŸ ---

                console.log(`[handleChoiceClick] Confirmed valid selection using local copy: "${localChoiceText}" (Index: ${localChoiceIndex})`); // ä½¿ç”¨å±€éƒ¨å˜é‡è®°å½•
                console.log("[handleChoiceClick] Current conversationHistory before modification:", JSON.stringify(conversationHistory));


                setLoading(true);
                choicesContainer.innerHTML = '';
                try {
                    // --- ä½¿ç”¨å±€éƒ¨å˜é‡ ---
                    const promptText = JSON.stringify({
                        player_choice: localChoiceText // ä½¿ç”¨å±€éƒ¨å˜é‡
                    });

                    // ä½¿ç”¨å±€éƒ¨å˜é‡æ·»åŠ åˆ°å†å²
                    conversationHistory.push({
                        role: "user",
                        parts: [{ text: `é€‰æ‹©äº†: "${localChoiceText}"` }] // ä½¿ç”¨å±€éƒ¨å˜é‡
                    });

                    // ä½¿ç”¨å±€éƒ¨å˜é‡å‡†å¤‡APIå†å²
                    const choicePromptHistoryForApi = [
                        ...conversationHistory.slice(0, -1),
                        { role: "user", parts: [{ text: promptText }] }
                    ];
                    console.log("[handleChoiceClick] History being sent to API:", JSON.stringify(choicePromptHistoryForApi));


                    // è°ƒç”¨API
                    const response = await callLLMApi_Galgame(choicePromptHistoryForApi);
                    processGameResponse(response); // æ³¨æ„ï¼šè¿™é‡Œ userPromptText åº”è¯¥å·²ç»è¢«å¤„ç†ï¼Œä½†ä¸ºä¿æŒä¸€è‡´æ€§ï¼Œ review processGameResponse çš„è°ƒç”¨æ–¹å¼

                } catch (error) {
                    console.error("[handleChoiceClick] Error during API call or response processing:", error);
                    showGameError(`å¤„ç†é€‰æ‹©æ—¶å‡ºé”™: ${error.message}`);
                    setLoading(false);
                    try {
                        console.log("[handleChoiceClick Error Recovery] Attempting to re-display choices.");
                        displayChoices();
                        nextButton.disabled = true;
                    } catch (displayError) {
                        console.error("[handleChoiceClick Error Recovery] Failed to re-display choices:", displayError);
                    }
                }
                // æ³¨æ„ï¼šprocessGameResponse åº”è¯¥å¤„ç† setLoading(false)
            }

            // å¤„ç†ä¸‹ä¸€æ­¥æŒ‰é’®ç‚¹å‡»
            // å¤„ç†ä¸‹ä¸€æ­¥æŒ‰é’®ç‚¹å‡»
            async function handleNextButtonClick() {
                if (isLoading) return; // é˜²æ­¢åŠ è½½æ—¶é‡å¤ç‚¹å‡»

                if (!isGameStarted) {
                    // --- åˆå§‹åŒ–æ¸¸æˆé€»è¾‘ (ä¿æŒä¸å˜) ---
                    try {
                        if (!currentApiKey || !currentModel) {
                            showGameError("è¯·å…ˆé…ç½®APIè®¾ç½®ï¼");
                            return;
                        }
                        setLoading(true);
                        await initializeGame(); // æ³¨æ„: initializeGame å†…éƒ¨åº”è¯¥è°ƒç”¨ processGameResponse
                        isGameStarted = true;
                        toggleHistoryBtn.disabled = false;
                        // nextButton çš„çŠ¶æ€ç”± initializeGame é‡Œçš„ processGameResponse è®¾ç½®
                    } catch (error) {
                        showGameError(`æ¸¸æˆåˆå§‹åŒ–å¤±è´¥: ${error.message}`);
                        setLoading(false); // åˆå§‹åŒ–å¤±è´¥ä¹Ÿè¦è§£é™¤åŠ è½½
                    }
                    // setLoading(false) åº”è¯¥ç”± initializeGame/processGameResponse ç®¡ç†
                    // --- åˆå§‹åŒ–ç»“æŸ ---
                } else if (currentSegmentIndex < currentDialogueSegments.length - 1) {
                    // --- æ˜¾ç¤ºä¸‹ä¸€æ®µå¯¹è¯ ---
                    currentSegmentIndex++;
                    displayDialogueSegment(currentSegmentIndex);

                    // æ£€æŸ¥æ˜¯å¦æ˜¯æœ€åä¸€æ®µ (åˆšåˆšæ˜¾ç¤ºçš„è¿™ä¸€æ®µ)
                    if (currentSegmentIndex === currentDialogueSegments.length - 1) {
                        // æ˜¯æœ€åä¸€æ®µï¼Œæ£€æŸ¥æ˜¯å¦æœ‰é€‰é¡¹
                        if (currentTurnChoices && currentTurnChoices.length > 0) {
                            // æœ‰é€‰é¡¹ï¼šæ˜¾ç¤ºé€‰é¡¹å¹¶ç¦ç”¨â€œç»§ç»­â€æŒ‰é’®
                            displayChoices();
                            nextButton.disabled = true;
                            nextButton.textContent = 'è¯·é€‰æ‹©'; // å¯é€‰ï¼šæ›´æ–°æŒ‰é’®æ–‡æœ¬
                            console.log("å·²æ˜¾ç¤ºæœ€åç‰‡æ®µå¹¶æœ‰é€‰é¡¹ï¼Œç¦ç”¨ç»§ç»­æŒ‰é’®ã€‚");
                        } else {
                            // æ˜¯æœ€åä¸€æ®µä½†æ— é€‰é¡¹ï¼šä¿æŒâ€œç»§ç»­â€æŒ‰é’®å¯ç”¨ï¼Œæ–‡æœ¬æ”¹ä¸ºâ€œä¸‹ä¸€æ­¥â€
                            nextButton.disabled = false;
                            nextButton.textContent = 'ä¸‹ä¸€æ­¥';
                            console.log("å·²æ˜¾ç¤ºæœ€åç‰‡æ®µæ— é€‰é¡¹ï¼ŒæŒ‰é’®ä¸ºä¸‹ä¸€æ­¥ã€‚");
                        }
                    } else {
                        // ä¸æ˜¯æœ€åä¸€æ®µï¼šä¿æŒâ€œç»§ç»­â€æŒ‰é’®å¯ç”¨
                        nextButton.disabled = false;
                        nextButton.textContent = 'ç»§ç»­';
                    }
                    // --- ä¸‹ä¸€æ®µå¯¹è¯ç»“æŸ ---
                } else {
                    // --- è¯·æ±‚ä¸‹ä¸€å›åˆ (å½“å‰å·²æ˜¯æœ€åä¸€æ®µä¸”æ— é€‰é¡¹) ---
                    console.log("ç‚¹å‡»ä¸‹ä¸€æ­¥ï¼Œè¯·æ±‚æ–°å›åˆ...");
                    setLoading(true);
                    try {
                        // ä½¿ç”¨æ›´æ˜ç¡®çš„åŠ¨ä½œæŒ‡ç¤ºï¼Œé¿å…æ­§ä¹‰
                        const promptText = JSON.stringify({ "action": "continue_story" });

                        const nextPromptHistory = [
                            ...conversationHistory, // ç¡®ä¿ conversationHistory æ˜¯æœ€æ–°çš„
                            {
                                role: "user",
                                parts: [{ text: promptText }]
                            }
                        ];

                        const response = await callLLMApi_Galgame(nextPromptHistory);
                        // processGameResponse ä¼šå¤„ç†æŒ‰é’®çš„æ–°çŠ¶æ€å’Œæ–‡æœ¬
                        processGameResponse(response);
                    } catch (error) {
                        showGameError(`è·å–ä¸‹ä¸€å›åˆæ—¶å‡ºé”™: ${error.message}`);
                        setLoading(false); // å‡ºé”™æ—¶è§£é™¤åŠ è½½
                        nextButton.disabled = false; // å‡ºé”™æ—¶å…è®¸é‡è¯•
                        nextButton.textContent = 'é‡è¯•';
                    }
                    // setLoading(false) ç”± processGameResponse åœ¨ finally ä¸­å¤„ç†
                    // --- è¯·æ±‚æ–°å›åˆç»“æŸ ---
                }
            }

            // --- å†å²é¢æ¿é€»è¾‘ ---
            function displayHistory() {
                console.log("æ˜¾ç¤ºå†å²ã€‚æ•°é‡:", conversationHistory.length);
                historyContent.innerHTML = '';

                if (conversationHistory.length === 0) {
                    historyContent.innerHTML = '<div class="history-empty">æ²¡æœ‰å†å²è®°å½•ã€‚</div>';
                    return;
                }

                // åˆ†æå†å²å¹¶æ˜¾ç¤º
                const historyPairs = [];
                let userMessage = null;

                conversationHistory.forEach((item, idx) => {
                    if (item.isSetup || item.isErrorFallback) return; // è·³è¿‡åˆå§‹è®¾ç½®å’Œé”™è¯¯å›é€€

                    if (item.role === 'user') {
                        userMessage = item;
                    } else if (item.role === 'model' && userMessage) {
                        try {
                            // è§£ææ¨¡å‹å“åº”
                            const modelText = item.parts[0].text;
                            let modelData;
                            try {
                                modelData = JSON.parse(modelText.replace(/```json\s*|\s*```/g, ''));
                            } catch (error) {
                                console.error("å†å²è®°å½•JSONè§£æé”™è¯¯:", error);
                                modelData = { dialogue_segments: [{ speaker: "ç³»ç»Ÿ", text: "è§£æé”™è¯¯" }] };
                            }

                            historyPairs.push({
                                user: userMessage,
                                model: { ...item, parsedData: modelData }
                            });

                            userMessage = null;
                        } catch (error) {
                            console.error("å¤„ç†å†å²è®°å½•æ—¶å‡ºé”™:", error);
                        }
                    }
                });

                // æ¸²æŸ“å†å²å¯¹è¯
                historyPairs.forEach((pair, idx) => {
                    const entry = document.createElement('div');
                    entry.className = 'history-entry';

                    // ç”¨æˆ·æ¶ˆæ¯
                    try {
                        let userContent = pair.user.parts[0].text;
                        // å¦‚æœæ˜¯JSONæ ¼å¼çš„é€‰æ‹©ï¼Œè§£æå®ƒ
                        try {
                            const userJson = JSON.parse(userContent);
                            if (userJson.player_choice) {
                                userContent = `é€‰æ‹©äº†: "${userJson.player_choice}"`;
                            }
                        } catch (e) {
                            // ä¸æ˜¯JSONï¼Œä½¿ç”¨åŸå§‹æ–‡æœ¬
                        }

                        const userHeader = document.createElement('div');
                        userHeader.className = 'history-role-user';
                        userHeader.textContent = playerName || 'ç©å®¶';

                        const userText = document.createElement('div');
                        userText.className = 'history-text';
                        userText.textContent = userContent;

                        entry.appendChild(userHeader);
                        entry.appendChild(userText);
                    } catch (error) {
                        console.error("æ¸²æŸ“ç”¨æˆ·å†å²æ—¶å‡ºé”™:", error);
                    }

                    // æ¨¡å‹å“åº”
                    try {
                        if (pair.model && pair.model.parsedData) {
                            const modelData = pair.model.parsedData;

                            // æ·»åŠ å¯¹è¯ç‰‡æ®µ
                            if (modelData.dialogue_segments && modelData.dialogue_segments.length > 0) {
                                const dialogues = document.createElement('div');
                                dialogues.className = 'history-dialogues';

                                modelData.dialogue_segments.forEach(segment => {
                                    const dialogueSegment = document.createElement('div');
                                    dialogueSegment.className = 'history-dialogue-segment';

                                    const speaker = document.createElement('span');
                                    speaker.className = 'segment-speaker';
                                    speaker.textContent = segment.speaker || 'æ—ç™½';

                                    const text = document.createElement('span');
                                    text.className = 'segment-text';
                                    text.innerHTML = DOMPurify.sanitize(marked.parse(segment.text || ""));

                                    dialogueSegment.appendChild(speaker);
                                    dialogueSegment.appendChild(text);
                                    dialogues.appendChild(dialogueSegment);
                                });

                                entry.appendChild(dialogues);
                            }
                        }
                    } catch (error) {
                        console.error("æ¸²æŸ“æ¨¡å‹å†å²æ—¶å‡ºé”™:", error);
                    }

                    historyContent.appendChild(entry);
                });

                // æ»šåŠ¨åˆ°åº•éƒ¨
                historyContent.scrollTop = historyContent.scrollHeight;
            }

            // --- è§’è‰²æ¨¡æ¿å¤„ç† ---
            function handleCharacterTemplateChange() {
                const templateKey = characterTemplateSelect.value;
                if (!templateKey) return;

                const template = characterTemplates[templateKey];
                if (!template) return;

                aiPersonaInput.value = template.persona;
            }

            // --- APIå¯†é’¥æ˜¾ç¤ºåˆ‡æ¢ ---
            function toggleApiKeyVisibility() {
                const currentType = apiKeyInput.getAttribute('type');
                if (currentType === 'password') {
                    apiKeyInput.setAttribute('type', 'text');
                    toggleApiKeyVisibilityBtn.textContent = 'ğŸ‘ï¸â€ğŸ—¨ï¸';
                } else {
                    apiKeyInput.setAttribute('type', 'password');
                    toggleApiKeyVisibilityBtn.textContent = 'ğŸ‘ï¸';
                }
            }

            // --- è®¾ç½®äº‹ä»¶ç›‘å¬å™¨ ---
            function setupEventListeners() {
                // é…ç½®é¢æ¿
                toggleConfigBtn.addEventListener('click', toggleConfigPanel);
                closeConfigBtn.addEventListener('click', toggleConfigPanel);
                saveConfigBtn.addEventListener('click', () => {
                    saveConfig();
                    configPanel.classList.remove('visible');
                });
                toggleApiKeyVisibilityBtn.addEventListener('click', toggleApiKeyVisibility);
                fetchModelsBtn.addEventListener('click', fetchLLMModels);
                // è§’è‰²æ¨¡æ¿é€‰æ‹©
                characterTemplateSelect.addEventListener('change', handleCharacterTemplateChange);

                // æµ‹è¯•APIå¯†é’¥
                document.getElementById('test-key-btn').addEventListener('click', testApiKey);

                // ç©å®¶å›¾ç‰‡ä¸Šä¼ 
                playerImageUpload.addEventListener('change', () => {
                    handleImageUpload(
                        playerImageUpload,
                        playerImagePreview,
                        clearPlayerImageBtn,
                        (val) => playerImageBase64 = val
                    );
                });

                clearPlayerImageBtn.addEventListener('click', () => {
                    clearImageUpload(
                        playerImageUpload,
                        playerImagePreview,
                        clearPlayerImageBtn,
                        (val) => playerImageBase64 = val
                    );
                });

                // AIå›¾ç‰‡ä¸Šä¼ 
                aiImageUpload.addEventListener('change', () => {
                    handleImageUpload(
                        aiImageUpload,
                        aiImagePreview,
                        clearAiImageBtn,
                        (val) => aiImageBase64 = val
                    );
                });

                clearAiImageBtn.addEventListener('click', () => {
                    clearImageUpload(
                        aiImageUpload,
                        aiImagePreview,
                        clearAiImageBtn,
                        (val) => aiImageBase64 = val
                    );
                });

                // æ¸¸æˆæ§åˆ¶
                nextButton.addEventListener('click', handleNextButtonClick);
                toggleHistoryBtn.addEventListener('click', toggleHistoryPanel);
                closeHistoryBtn.addEventListener('click', toggleHistoryPanel);

                // è‡ªåŠ¨ä¿å­˜è¾“å…¥å˜æ›´ï¼ˆä½¿ç”¨é˜²æŠ–ï¼‰
                const debouncedSaveConfig = debounce(saveConfig, 1000);
                const configInputs = document.querySelectorAll('#config-panel input, #config-panel textarea, #config-panel select');
                configInputs.forEach(input => {
                    input.addEventListener('change', debouncedSaveConfig);
                });

                // é”®ç›˜å¿«æ·é”®
                document.addEventListener('keydown', (e) => {
                    // å¦‚æœæ­£åœ¨æ˜¾ç¤ºé€‰æ‹©æˆ–å†å²é¢æ¿ï¼Œä¸å¤„ç†å¿«æ·é”®
                    if (historyPanel.classList.contains('visible') ||
                        configPanel.classList.contains('visible') ||
                        choicesContainer.children.length > 0) {
                        return;
                    }

                    if ((e.key === ' ' || e.key === 'Enter') && !nextButton.disabled) {
                        e.preventDefault();
                        nextButton.click();
                    }
                });
            }

            // --- APIæµ‹è¯•åŠŸèƒ½ ---
            async function testApiKey() {
                const testKeyButtonElement = document.getElementById('test-key-btn');
                const apiKey = apiKeyInput.value.trim();
                const baseApiUrl = apiUrlInput.value.trim() || DEFAULT_API_URL_GALGAME;

                if (!apiKey) {
                    showGameError("è¯·è¾“å…¥APIå¯†é’¥ï¼");
                    keyStatusSpan.textContent = "æœªæä¾›APIå¯†é’¥";
                    keyStatusSpan.className = "error";
                    return;
                }

                // æ˜¾ç¤ºæµ‹è¯•ä¸­çŠ¶æ€
                keyStatusSpan.textContent = "æ­£åœ¨æµ‹è¯•...";
                keyStatusSpan.className = "testing";
                testKeyButtonElement.disabled = true;

                try {
                    let testUrl;
                    let testBody;
                    let headers = { 'Content-Type': 'application/json' };

                    if (baseApiUrl.includes('generativelanguage.googleapis.com')) {
                        // Gemini APIæµ‹è¯•
                        testUrl = `${baseApiUrl.replace(/\/$/, '')}/v1beta/models?key=${apiKey}`;
                        // ä¸éœ€è¦è¯·æ±‚ä½“ï¼Œåªè·å–æ¨¡å‹åˆ—è¡¨
                    } else if (baseApiUrl.includes('/v1')) {
                        // OpenAIå…¼å®¹APIæµ‹è¯•
                        testUrl = `${baseApiUrl.replace(/\/v1\/?$/, '')}/v1/models`;
                        headers['Authorization'] = `Bearer ${apiKey}`;
                    } else {
                        throw new Error("ä¸æ”¯æŒçš„API URLæ ¼å¼");
                    }

                    const response = await fetch(testUrl, {
                        method: 'GET',
                        headers
                    });

                    const data = await response.json();

                    if (response.ok) {
                        keyStatusSpan.textContent = "æœ‰æ•ˆçš„APIå¯†é’¥";
                        keyStatusSpan.className = "valid";
                        saveConfig(); // è‡ªåŠ¨ä¿å­˜æœ‰æ•ˆé…ç½®
                    } else {
                        const errorMessage = data.error?.message || JSON.stringify(data.error) || "æœªçŸ¥é”™è¯¯";
                        keyStatusSpan.textContent = `æ— æ•ˆ: ${errorMessage}`;
                        keyStatusSpan.className = "invalid";
                    }
                } catch (error) {
                    console.error("æµ‹è¯•APIå¯†é’¥æ—¶å‡ºé”™:", error);
                    keyStatusSpan.textContent = `é”™è¯¯: ${error.message}`;
                    keyStatusSpan.className = "error";
                } finally {
                    testKeyButtonElement.disabled = false;
                }
            }

            // --- åˆå§‹åŒ–å’Œæ¨¡å‹åŠ è½½ ---
            async function fetchLLMModels() {
                const apiKey = apiKeyInput.value.trim();
                const baseApiUrl = apiUrlInput.value.trim() || DEFAULT_API_URL_GALGAME;

                if (!apiKey) {
                    showGameError("è¯·è¾“å…¥APIå¯†é’¥ä»¥è·å–æ¨¡å‹åˆ—è¡¨ã€‚");
                    return;
                }

                fetchModelsBtn.disabled = true;
                modelLoadingIndicator.style.display = 'inline-block';

                try {
                    let modelsUrl;
                    let headers = { 'Content-Type': 'application/json' };

                    if (baseApiUrl.includes('generativelanguage.googleapis.com')) {
                        // Gemini API
                        modelsUrl = `${baseApiUrl.replace(/\/$/, '')}/v1beta/models?key=${apiKey}`;
                    } else if (baseApiUrl.includes('/v1')) {
                        // OpenAIå…¼å®¹API
                        modelsUrl = `${baseApiUrl.replace(/\/v1\/?$/, '')}/v1/models`;
                        headers['Authorization'] = `Bearer ${apiKey}`;
                    } else {
                        throw new Error("ä¸æ”¯æŒçš„API URLæ ¼å¼ã€‚è¯·ä½¿ç”¨Geminiæˆ–OpenAIå…¼å®¹çš„APIåœ°å€ã€‚");
                    }

                    const response = await fetch(modelsUrl, {
                        method: 'GET',
                        headers
                    });

                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.error?.message || "è·å–æ¨¡å‹åˆ—è¡¨å¤±è´¥");
                    }

                    // æ¸…é™¤å½“å‰é€‰é¡¹
                    while (modelSelect.options.length > 0) {
                        modelSelect.remove(0);
                    }

                    // æ·»åŠ æç¤ºé€‰é¡¹
                    const defaultOption = document.createElement('option');
                    defaultOption.value = "";
                    defaultOption.textContent = "-- é€‰æ‹©ä¸€ä¸ªæ¨¡å‹ --";
                    defaultOption.disabled = true;
                    defaultOption.selected = true;
                    modelSelect.appendChild(defaultOption);

                    // å¤„ç†ä¸åŒAPIè¿”å›çš„æ¨¡å‹åˆ—è¡¨æ ¼å¼
                    let models = [];
                    if (data.models) {
                        // Gemini APIæ ¼å¼
                        models = data.models.map(m => ({
                            id: m.name.split('/').pop(),
                            fullName: m.name
                        }));
                    } else if (data.data) {
                        // OpenAI APIæ ¼å¼
                        models = data.data.map(m => ({
                            id: m.id,
                            fullName: m.id
                        }));
                    }

                    // æ·»åŠ æ¨¡å‹é€‰é¡¹
                    models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.fullName;
                        option.textContent = model.id;
                        modelSelect.appendChild(option);
                    });

                    modelSelect.disabled = false;
                    showGameError("å·²æˆåŠŸè·å–æ¨¡å‹åˆ—è¡¨ï¼");
                } catch (error) {
                    console.error("è·å–æ¨¡å‹åˆ—è¡¨æ—¶å‡ºé”™:", error);
                    showGameError(`è·å–æ¨¡å‹åˆ—è¡¨å¤±è´¥: ${error.message}`);
                } finally {
                    fetchModelsBtn.disabled = false;
                    modelLoadingIndicator.style.display = 'none';
                }
            }

            // --- åˆå§‹åŒ–åº”ç”¨ ---
            // --- åˆå§‹åŒ–åº”ç”¨ ---
            // --- åˆå§‹åŒ–åº”ç”¨ ---
            // --- åˆå§‹åŒ–åº”ç”¨ ---
            function initializeApp() {
                // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨ (This already sets up the listener for toggleConfigBtn)
                setupEventListeners();

                // ç¡®ä¿è®¾ç½®æŒ‰é’®åœ¨åˆå§‹åŒ–æ—¶æ˜¯å¯ç”¨çš„
                if (toggleConfigBtn) {
                    toggleConfigBtn.disabled = false;
                    // REMOVED: Redundant event listener attachment was here.
                    // The listener is correctly added in setupEventListeners.
                    console.log("Toggle config button listener is attached by setupEventListeners.");
                }

                // åŠ è½½ä¿å­˜çš„é…ç½®
                loadConfig();

                // åˆå§‹éšè—è§’è‰²sprite
                aiCharacterSprite.classList.add('hidden');
                playerCharacterSprite.classList.add('hidden');

                console.log("AI Galgameåº”ç”¨å·²åˆå§‹åŒ–");
            }

            // ä¿®æ”¹setLoadingå‡½æ•°ï¼Œç¡®ä¿è®¾ç½®æŒ‰é’®å§‹ç»ˆå¯ç”¨
            // ä¿®æ”¹setLoadingå‡½æ•°ï¼Œç¡®ä¿è®¾ç½®æŒ‰é’®å§‹ç»ˆå¯ç”¨
            function setLoading(loading) {
                console.log("è®¾ç½®åŠ è½½çŠ¶æ€ä¸º:", loading);
                isLoading = loading;
                loadingOverlay.classList.toggle('visible', loading);
                const canInteract = currentApiKey && currentModel;

                // æ£€æŸ¥é€‰é¡¹æ˜¯å¦å½“å‰æ­£åœ¨æ˜¾ç¤º (è¯»å–DOM)
                const choicesCurrentlyDisplayed = choicesContainer.querySelector('.choice-button') !== null;

                // --- ä¿®æ”¹å¼€å§‹ ---
                // æŒ‰é’®åº”è¯¥ç¦ç”¨ï¼Œå¦‚æœï¼š
                // 1. æ­£åœ¨åŠ è½½
                // 2. APIæœªé…ç½®
                // 3. æ¸¸æˆæœªå¼€å§‹
                // 4. **æœ‰é€‰é¡¹æ­£åœ¨æ˜¾ç¤º** (ç”¨æˆ·å¿…é¡»é€‰ä¸€ä¸ª)
                // ä¸å†å› ä¸ºæ˜¯æœ€åä¸€ä¸ªç‰‡æ®µå°±ç¦ç”¨æŒ‰é’®
                nextButton.disabled = loading || !canInteract || !isGameStarted || choicesCurrentlyDisplayed;
                // --- ä¿®æ”¹ç»“æŸ ---

                // å†å²æŒ‰é’®å’Œå…¶ä»–æ§åˆ¶
                toggleHistoryBtn.disabled = loading || !canInteract || !isGameStarted;
                document.querySelectorAll('.choice-button').forEach(btn => btn.disabled = loading);
            }

            // å¯åŠ¨åº”ç”¨
            initializeApp();
        });
    </script>
</body>

</html>