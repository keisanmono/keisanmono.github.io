<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸŒŒ AI äº’åŠ¨å°è¯´ | ğŸŒ¸ æˆ‘çš„äºŒæ¬¡å…ƒå°çª ğŸŒ¸</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
        .if-container {
            max-width: 900px;
            margin: 30px auto;
            padding: 30px 40px;
            background: rgba(255, 255, 255, 0.75); /* Slightly more opaque */
            backdrop-filter: blur(10px) saturate(160%);
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #333;
        }

        .if-container h2 {
            text-align: center;
            margin-bottom: 25px;
            color: #6a5acd; /* Slate Blue */
            font-size: 1.8em;
            text-shadow: 0 0 8px rgba(106, 90, 205, 0.4);
        }

        /* Setup Area */
        #setup-area, #game-area {
            margin-bottom: 20px;
        }
         #game-area {
             display: none; /* Initially hidden */
         }

        .form-group { /* Reusing style from ai_draw */
            margin-bottom: 20px;
        }
        .form-group label { display: block; margin-bottom: 8px; font-weight: 500; color: #555; }
        .form-group input[type="text"],
        .form-group input[type="password"], /* Use password type for API key */
        .form-group textarea {
             width: 100%; padding: 12px 15px; border: 1px solid rgba(0, 0, 0, 0.1);
             border-radius: 8px; background: rgba(255, 255, 255, 0.8); outline: none;
             transition: all 0.3s ease; box-sizing: border-box; font-size: 0.95em;
             color: #333; font-family: inherit;
        }
        .form-group input:focus, .form-group textarea:focus {
             background: rgba(255, 255, 255, 0.95); border-color: rgba(106, 90, 205, 0.7);
             box-shadow: 0 0 10px rgba(106, 90, 205, 0.5);
         }
         .api-key-warning {
             font-size: 0.85em; color: #dc3545; margin-top: 5px; font-weight: bold;
         }

        /* Game Display Area */
        #image-display {
            text-align: center;
            min-height: 250px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px dashed rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }
        #story-image {
            max-width: 100%;
            max-height: 50vh;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            display: none; /* Hide initially */
            vertical-align: middle;
        }
         #loading-image {
             display: none; /* Hide initially */
             color: #666; animation: pulse 1.5s infinite ease-in-out;
         }

        /* --- Style for Story Text Container --- */
        #story-text-container {
            background: rgba(255, 255, 255, 0.6);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            min-height: 100px;
            line-height: 1.7;
            font-size: 1.05em;
            position: relative; /* For loading indicator */
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
         #loading-text {
             position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
             display: none; color: #666; font-style: italic;
         }
         /* --- Style for Story Text content itself --- */
         #story-text {
             white-space: pre-wrap; /* Preserve line breaks from AI initially */
             /* Markdown will override this where applicable (e.g., lists, paragraphs) */
         }
         /* Add some basic Markdown styling (optional, can be expanded) */
         #story-text p { margin-bottom: 1em; }
         #story-text h1, #story-text h2, #story-text h3, #story-text h4, #story-text h5, #story-text h6 { margin-top: 1.2em; margin-bottom: 0.8em; color: #444; }
         #story-text ul, #story-text ol { margin-left: 2em; margin-bottom: 1em; }
         #story-text li { margin-bottom: 0.4em; }
         #story-text code { background-color: rgba(0,0,0,0.05); padding: 0.2em 0.4em; border-radius: 3px; font-family: monospace; }
         #story-text pre { background-color: rgba(0,0,0,0.07); padding: 1em; border-radius: 5px; overflow-x: auto; }
         #story-text pre code { background-color: transparent; padding: 0; }
         #story-text blockquote { border-left: 4px solid #ccc; padding-left: 1em; margin-left: 0; color: #666; font-style: italic; }
         #story-text hr { border: none; border-top: 1px solid #eee; margin: 1.5em 0; }


        #choices-container {
            display: flex;
            flex-direction: column; /* Stack choices vertically */
            gap: 10px;
            align-items: stretch; /* Make buttons full width */
        }

        .choice-button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #aeeeee, #87cefa); /* Blue gradient */
            color: #333;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            text-align: left; /* Align text left */
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .choice-button:hover {
            background: linear-gradient(135deg, #87cefa, #aeeeee);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
            color: #0056b3;
        }
        .choice-button:disabled { background: var(--text-color-lighter); color: var(--text-color); opacity: 0.6; box-shadow: none; transform: none; }
        #start-game-btn { /* Reusing generate button style */
            padding: 12px 25px; border: none; border-radius: 25px;
            background: linear-gradient(135deg, #90ee90, #3cb371); /* Green gradient */
            color: white; font-size: 1.1em; font-weight: 600; cursor: pointer;
            transition: all 0.3s ease; box-shadow: 0 5px 15px rgba(60, 179, 113, 0.4);
            margin-top: 10px; display: block; width: 100%;
        }
        #start-game-btn:hover { background: linear-gradient(135deg, #3cb371, #90ee90); box-shadow: 0 8px 20px rgba(60, 179, 113, 0.6); transform: translateY(-3px); }
        #start-game-btn:disabled { background: var(--text-color-lighter); cursor: not-allowed; box-shadow: none; transform: none; opacity: 0.7; }
        #error-message-if { display: none; color: #dc3545; font-weight: bold; margin-top: 15px; text-align: center; background: rgba(255, 220, 220, 0.7); padding: 10px; border-radius: 5px; }
        body.theme-dark #error-message-if { color: #f5c6cb; background: rgba(248, 215, 218, 0.1); }
        /* Styles copied/adapted from tno_generator.html for config */
        .config-section { border: 1px dashed var(--border-color-input); padding: 20px; margin-bottom: 25px; border-radius: 8px; background: rgba(200, 200, 255, 0.05); }
        body.theme-dark .config-section { background: rgba(100, 100, 150, 0.05); }
        .config-section h3 { margin-top: 0; margin-bottom: 15px; color: var(--heading-color-tertiary); font-size: 1.2em; }
        .form-grid { display: grid; grid-template-columns: 1fr; gap: 15px; }
        .form-group { margin-bottom: 0; } /* Adjusted from original, kept */
        /* --- Reverted form-group label style back to original --- */
        .form-group label { display: block; margin-bottom: 8px; font-weight: 500; color: #555; }
        /* --- End revert --- */
        .form-group input[type="text"], .form-group input[type="url"],
        .form-group input[type="password"], .form-group textarea, .form-group select {
            /* Uses general input styles from style.css now */
        }
        .api-key-wrapper { position: relative; display: flex; align-items: center; }
        .api-key-wrapper input { padding-right: 45px; flex-grow: 1; }
        #toggle-api-key-visibility { /* Uses general styles, can keep for specificity */
             position: absolute; right: 1px; top: 50%; transform: translateY(-50%); background: none; border: none;
             cursor: pointer; padding: 10px; color: var(--text-color-lighter); font-size: 1.2em; line-height: 1; opacity: 0.7; transition: opacity 0.2s;
        }
        #toggle-api-key-visibility:hover { opacity: 1; color: var(--text-color); }
        .api-url-wrapper { display: flex; gap: 0; align-items: stretch; }
        .api-url-wrapper input[type="url"] { flex-grow: 1; border-top-right-radius: 0; border-bottom-right-radius: 0; border-right: none; }
        #fetch-models-btn { /* Uses general button styles now, specific style for background below */
             flex-shrink: 0; padding: 10px 18px; border: 1px solid var(--border-color-input); border-left: none;
             border-top-left-radius: 0; border-bottom-left-radius: 0;
             background: var(--tno-fetch-btn-bg); /* Reuse TNO style */ color: var(--tno-fetch-btn-color);
             cursor: pointer; font-weight: 500; font-size: 0.95em; transition: all 0.3s ease; height: auto;
        }
        #fetch-models-btn:hover { background: var(--tno-fetch-btn-hover-bg); color: var(--tno-fetch-btn-hover-color); }
        #fetch-models-btn:disabled { background: rgba(0,0,0,0.1); color: var(--text-color-lighter); box-shadow: none; opacity: 0.5; }
        #model-loading-indicator { margin-left: 8px; color: var(--text-color-light); font-size: 1.2em; vertical-align: middle; display: none; }
        .form-group .input-hint { font-size: 0.85em; color: var(--text-color-lighter); display:block; margin-top: 5px; }
    </style>
</head>
<body>
    <!-- Background, Sidebar, Toggle Button -->
    <div class="background"></div>
    <div id="sidebar">
        <nav id="sidebar-nav">
            <a href="index.html">ğŸ  ä¸»é¡µ</a>
            <a href="about.html">âœ¨ å…³äºæˆ‘</a>
            <a href="blog_page1.html">ğŸ“ åšå®¢</a>
            <a href="contact.html">ğŸ’Œ è”ç³»æˆ‘</a>
            <a href="download.html">ğŸ“ æ–‡ä»¶ä¸‹è½½</a>
            <a href="ai_draw.html">ğŸ¨ AI ä½œç”»</a>
            <a href="tno_generator.html">ğŸ“œ TNOäº‹ä»¶ç”Ÿæˆ</a>
            <a href="if_game.html">ğŸŒŒ AI äº’åŠ¨å°è¯´</a>
            <a href="ai_rpg.html">ğŸ’– AI Galgame</a>
        </nav>
        <div class="theme-switcher">
            <h4>åˆ‡æ¢ä¸»é¢˜:</h4>
            <div class="theme-buttons-container">
                <button data-theme="pastel" class="theme-button">ğŸŒ¸ ç²‰å½©æ¢¦å¢ƒ</button>
                <button data-theme="dark" class="theme-button">ğŸŒ™ åˆå¤œæ¨±è½</button>
            </div>
        </div>
    </div>
    <button id="toggle-btn">â˜°</button>

    <!-- Page Content -->
    <div class="content scroll-container">
        <header>
            <h1>AI äº’åŠ¨å°è¯´</h1>
        </header>

        <main>
            <div class="if-container">
                <h2>å¼€å§‹ä½ çš„å†’é™©ï¼</h2>

                <!-- Configuration Section -->
                <div class="config-section">
                    <h3>API è®¾ç½®</h3>
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="llm-api-key">API å¯†é’¥:</label> <!-- Added for="llm-api-key" -->
                            <div class="api-key-wrapper">
                                <input type="password" id="llm-api-key" placeholder="è¾“å…¥ API Key (ä¾‹å¦‚ Gemini)">
                                <button id="toggle-api-key-visibility" title="åˆ‡æ¢å¯è§æ€§">ğŸ‘ï¸</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="llm-api-url">API åŸºç¡€åœ°å€:</label> <!-- Added for="llm-api-url" -->
                            <div class="api-url-wrapper">
                                <input type="url" id="llm-api-url" placeholder="ä¾‹å¦‚: https://generativelanguage.googleapis.com" value="https://generativelanguage.googleapis.com">
                                <button id="fetch-models-btn" title="è·å–å¯ç”¨æ¨¡å‹åˆ—è¡¨">è·å–åˆ—è¡¨</button>
                            </div>
                             <small class="input-hint">(Google: ç•™ç©ºæˆ–å¡« ...googleapis.com; OpenAIå…¼å®¹: å¡«åˆ° /v1/ ç»“å°¾)</small>
                        </div>
                        <div class="form-group">
                            <label for="llm-model-select">é€‰æ‹© LLM æ¨¡å‹:</label> <!-- Added for="llm-model-select" -->
                             <div style="display: flex; align-items: center; gap: 10px;">
                                <div class="select-wrapper" style="flex-grow: 1;">
                                    <select id="llm-model-select" disabled>
                                        <option value="" disabled selected>-- è¯·å…ˆè·å–æ¨¡å‹åˆ—è¡¨ --</option>
                                    </select>
                                </div>
                                <span id="model-loading-indicator" title="æ­£åœ¨åŠ è½½æ¨¡å‹...">ğŸ”„</span>
                             </div>
                        </div>
                         <div class="form-group">
                            <label for="initial-prompt">æ•…äº‹å¼€ç«¯/è®¾å®š:</label> <!-- Added for="initial-prompt" -->
                             <textarea id="initial-prompt" rows="4" placeholder="æè¿°ä½ æƒ³å¼€å§‹çš„æ•…äº‹åœºæ™¯ã€è§’è‰²æˆ–ä¸»é¢˜..."></textarea>
                         </div>
                    </div>
                    <button id="start-game-btn" disabled>å¼€å¯æ•…äº‹ (è¯·å…ˆé…ç½®API)</button>
                </div>
                <!-- End Configuration Section -->

                <!-- Game Display Area (Hidden initially) -->
                <div id="game-area">
                    <div id="image-display">
                        <span id="loading-image">ğŸ–¼ï¸ åœºæ™¯åŠ è½½ä¸­...</span>
                        <img id="story-image" src="#" alt="æ•…äº‹åœºæ™¯æ’ç”»">
                    </div>
                    <div id="story-text-container">
                         <span id="loading-text">âœï¸ AI æ­£åœ¨æ„æ€æ•…äº‹...</span>
                        <div id="story-text"></div> <!-- Content will be HTML -->
                    </div>
                    <div id="choices-container">
                        <!-- Choice buttons will be added here by JS -->
                    </div>
                </div>
                 <div id="error-message-if"></div> <!-- Error display for IF -->
            </div>
        </main>

        <footer>
            <p>Â© 2024 MOLIFULAN's Blog | Interactive Fiction powered by AI</p>
        </footer>
    </div>

    <!-- JS Files -->
    <!-- === ADDED LIBRARIES FOR MARKDOWN SUPPORT === -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    <!-- === END ADDED LIBRARIES === -->

    <script src="js/script.js"></script> <!-- Assuming general site script like theme switcher is here -->
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- IF Game Specific JS ---

        // --- DOM Element References ---
        const configSection = document.querySelector('.config-section');
        const gameArea = document.getElementById('game-area');
        const apiKeyInput = document.getElementById('llm-api-key');
        const apiUrlInput = document.getElementById('llm-api-url');
        const fetchModelsBtn = document.getElementById('fetch-models-btn');
        const modelSelect = document.getElementById('llm-model-select');
        const modelLoadingIndicator = document.getElementById('model-loading-indicator');
        const toggleApiKeyVisibilityBtn = document.getElementById('toggle-api-key-visibility');
        const initialPromptInput = document.getElementById('initial-prompt');
        const startGameBtn = document.getElementById('start-game-btn');
        const imageDisplay = document.getElementById('image-display');
        const storyImage = document.getElementById('story-image');
        const loadingImage = document.getElementById('loading-image');
        const storyTextContainer = document.getElementById('story-text-container');
        const storyTextDiv = document.getElementById('story-text');
        const loadingText = document.getElementById('loading-text');
        const choicesContainer = document.getElementById('choices-container');
        const errorMessageDiv = document.getElementById('error-message-if');

        // --- State Variables ---
        let currentApiKey = null;
        let currentApiUrl = null;
        let currentModel = null;
        let storyHistory = [];
        let isGenerating = false;
        const IF_GAME_STORAGE_PREFIX = 'ifGame_';

        // --- Error & Loading UI ---
        function showError(message) { /* ... (Keep existing implementation from original) ... */
             errorMessageDiv.textContent = `é”™è¯¯ï¼š${message}`;
             errorMessageDiv.style.display = 'block';
             loadingText.style.display = 'none';
             loadingImage.style.display = 'none';
             isGenerating = false; // Ensure generating flag is reset on error
             // Re-enable buttons based on config state
             startGameBtn.disabled = !(currentApiKey && currentModel);
             const choiceButtons = choicesContainer.querySelectorAll('button');
             choiceButtons.forEach(btn => btn.disabled = false); // Re-enable choices if error occurs after choices were displayed
         }
        function hideError() { /* ... (Keep existing implementation from original) ... */
             errorMessageDiv.style.display = 'none'; errorMessageDiv.textContent = '';
        }
        function showLoading(type) { /* ... (Keep existing implementation from original) ... */
             hideError(); // Hide previous errors when new loading starts
             if (type === 'text') {
                 loadingText.style.display = 'block';
                 storyTextDiv.innerHTML = ''; // Clear previous content (now using innerHTML)
                 choicesContainer.innerHTML = ''; // Clear choices
                 const buttons = choicesContainer.querySelectorAll('button'); // Ensure buttons are disabled
                 buttons.forEach(btn => btn.disabled = true);
             }
             else if (type === 'image') {
                 loadingImage.style.display = 'block';
                 storyImage.style.display = 'none';
                 storyImage.src = '#';
             }
         }
        function hideLoading(type) { /* ... (Keep existing implementation from original) ... */
            if (type === 'text') loadingText.style.display = 'none';
            if (type === 'image') loadingImage.style.display = 'none';
        }

        // --- Configuration Logic (Keep existing from original) ---
        function saveConfig() { /* ... */
            const apiKey = apiKeyInput.value.trim();
            const apiUrl = apiUrlInput.value.trim() || 'https://generativelanguage.googleapis.com'; // Default if empty
            const model = modelSelect.value;

            // Basic validation before saving and enabling start button
            let canStart = true;
            if (!apiKey) {
                // Optionally show a less intrusive warning or just keep button disabled
                console.warn("API Key is empty, cannot start.");
                canStart = false;
            }
            if (!model) {
                console.warn("Model not selected, cannot start.");
                canStart = false;
            }

            localStorage.setItem(IF_GAME_STORAGE_PREFIX + 'apiKey', apiKey);
            localStorage.setItem(IF_GAME_STORAGE_PREFIX + 'apiUrl', apiUrl);
            localStorage.setItem(IF_GAME_STORAGE_PREFIX + 'model', model);

            currentApiKey = apiKey;
            currentApiUrl = apiUrl;
            currentModel = model;

            startGameBtn.disabled = !canStart;
            startGameBtn.textContent = canStart ? 'å¼€å¯æ•…äº‹' : 'å¼€å¯æ•…äº‹ (è¯·å…ˆé…ç½®API)';

            // Only show alert if values actually changed and are valid, or keep it simple
            // alert("è®¾ç½®å·²ä¿å­˜ï¼");
             console.log("IF Config saved:", { apiKey: currentApiKey ? '******' : 'empty', currentApiUrl, currentModel }); // Avoid logging key directly
        }
        function loadConfig() { /* ... */
            currentApiKey = localStorage.getItem(IF_GAME_STORAGE_PREFIX + 'apiKey') || '';
            currentApiUrl = localStorage.getItem(IF_GAME_STORAGE_PREFIX + 'apiUrl') || 'https://generativelanguage.googleapis.com';
            currentModel = localStorage.getItem(IF_GAME_STORAGE_PREFIX + 'model') || '';

            apiKeyInput.value = currentApiKey;
            // Handle URL display: show placeholder if it's the default Google URL
            apiUrlInput.value = (currentApiUrl === 'https://generativelanguage.googleapis.com') ? '' : currentApiUrl;

            // Reset model select before potentially adding saved model
            modelSelect.innerHTML = '<option value="" disabled selected>-- è·å–æˆ–é€‰æ‹©æ¨¡å‹ --</option>';
            modelSelect.disabled = true; // Disable initially

            if(currentModel) {
                 const tempOption = document.createElement('option');
                 tempOption.value = currentModel;
                 tempOption.textContent = currentModel + " (å·²ä¿å­˜)";
                 tempOption.selected = true;
                 modelSelect.appendChild(tempOption);
                 modelSelect.disabled = false; // Enable if there's a saved model
            }

            // Set initial state of start button based on loaded config
            const canStart = !!(currentApiKey && currentModel);
            startGameBtn.disabled = !canStart;
            startGameBtn.textContent = canStart ? 'å¼€å¯æ•…äº‹' : 'å¼€å¯æ•…äº‹ (è¯·å…ˆé…ç½®API)';

            console.log("IF Config loaded:", { apiKey: currentApiKey ? '******' : 'empty', currentApiUrl, currentModel });
        }
        async function fetchLLMModels() { /* ... (Keep existing implementation from original) ... */
             const apiKey = apiKeyInput.value.trim();
             const baseApiUrl = apiUrlInput.value.trim() || 'https://generativelanguage.googleapis.com'; // Use default if empty

             if (!apiKey) {
                 showError('è¯·å…ˆå¡«å†™ API å¯†é’¥ã€‚');
                 return;
             }

             hideError();
             modelLoadingIndicator.style.display = 'inline-block';
             fetchModelsBtn.disabled = true;
             modelSelect.disabled = true; // Disable while fetching
             modelSelect.innerHTML = '<option value="" disabled selected>-- æ­£åœ¨è·å–... --</option>';

             let modelListUrl = '';
             let headers = { 'Content-Type': 'application/json' };
             let method = 'GET';

             try {
                 // Determine the correct endpoint based on the URL format
                 if (baseApiUrl.includes('generativelanguage.googleapis.com')) {
                     // Google Gemini API endpoint for listing models
                     modelListUrl = `${baseApiUrl.replace(/\/$/, '')}/v1beta/models?key=${apiKey}&pageSize=1000`; // Use v1beta for listing
                 } else if (baseApiUrl.includes('/v1')) {
                     // OpenAI-compatible API endpoint
                     headers['Authorization'] = `Bearer ${apiKey}`;
                     modelListUrl = `${baseApiUrl.replace(/\/v1\/?$/, '')}/v1/models`; // Standard models endpoint
                 } else {
                     // Assume OpenAI-compatible if format is unknown, try /v1/models
                     console.warn("æœªçŸ¥ API åœ°å€æ ¼å¼ï¼Œå°è¯• /v1/models");
                     headers['Authorization'] = `Bearer ${apiKey}`;
                     modelListUrl = `${baseApiUrl.replace(/\/$/, '')}/v1/models`;
                 }

                 const response = await fetch(modelListUrl, { method, headers });

                 if (!response.ok) {
                     let errorDetails = '';
                     try {
                         const errorData = await response.json();
                         errorDetails = errorData?.error?.message || JSON.stringify(errorData);
                     } catch (e) {
                         errorDetails = await response.text();
                     }
                     throw new Error(`è·å–æ¨¡å‹åˆ—è¡¨å¤±è´¥: ${response.status} ${response.statusText}. ${errorDetails.substring(0, 200)}`);
                 }

                 const data = await response.json();
                 let modelNames = [];

                 // Parse response based on expected format (Google vs OpenAI)
                 if (data.models?.length) { // Google format
                     modelNames = data.models
                         .map(m => m.name?.replace(/^models\//, '')) // Extract name, remove 'models/' prefix
                         .filter(Boolean) // Remove empty names
                         // Filter for likely chat/generative models (heuristic)
                         .filter(name => name.includes('gemini') && !name.includes('embed') && !name.includes('vision') && !name.includes('aqa'))
                         .sort();
                 } else if (data.data?.length) { // OpenAI format
                     modelNames = data.data
                         .map(m => m.id) // Extract model ID
                         .filter(Boolean)
                         // Filter for likely chat models (heuristic, might need adjustment)
                         .filter(id => !/embed|vision|instruct|text-|whisper|tts|davinci|babbage|curie|ada|engine|search|similarity|edit|codex/i.test(id))
                         .sort();
                 } else {
                     throw new Error("æ— æ³•è¯†åˆ«çš„æ¨¡å‹åˆ—è¡¨æ ¼å¼ã€‚");
                 }

                 if (modelNames.length === 0) {
                     throw new Error("æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„èŠå¤©æ¨¡å‹ã€‚è¯·æ£€æŸ¥ API Key æˆ– åœ°å€ã€‚");
                 }

                 // Repopulate select dropdown
                 const previouslySelected = currentModel || modelSelect.value; // Keep track of selection
                 modelSelect.innerHTML = '<option value="" disabled>-- è¯·é€‰æ‹©ä¸€ä¸ªæ¨¡å‹ --</option>';
                 let foundPrevious = false;

                 modelNames.forEach(name => {
                     const option = document.createElement('option');
                     option.value = name;
                     option.textContent = name;
                     if (name === previouslySelected) {
                         option.selected = true;
                         foundPrevious = true;
                     }
                     modelSelect.appendChild(option);
                 });

                 // Auto-select first model if previous wasn't found or none was selected
                 if (!foundPrevious && modelNames.length > 0) {
                     modelSelect.selectedIndex = 1; // Select the first actual model
                 } else if (!foundPrevious && !previouslySelected) {
                      modelSelect.selectedIndex = 0; // Keep "Please select" if nothing matched
                 }


                 modelSelect.disabled = false; // Enable the select dropdown
                 hideError(); // Clear any previous errors
                 saveConfig(); // Save the potentially auto-selected model

             } catch (error) {
                 console.error("è·å–æ¨¡å‹å‡ºé”™:", error);
                 showError(error.message || "è·å–æ¨¡å‹æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯ã€‚");
                 modelSelect.innerHTML = '<option value="" disabled selected>-- è·å–å¤±è´¥ --</option>'; // Update placeholder on error
             } finally {
                 modelLoadingIndicator.style.display = 'none'; // Hide loading indicator
                 fetchModelsBtn.disabled = false; // Re-enable button
                 // Don't re-enable select here if error occurred, let user retry fetch
                 modelSelect.disabled = modelSelect.options.length <= 1;
             }
        }
        // API Key visibility toggle (Keep existing implementation from original)
        if (toggleApiKeyVisibilityBtn && apiKeyInput) {
            toggleApiKeyVisibilityBtn.addEventListener('click', () => {
                const isPassword = apiKeyInput.type === 'password';
                apiKeyInput.type = isPassword ? 'text' : 'password';
                toggleApiKeyVisibilityBtn.textContent = isPassword ? 'ğŸ‘ï¸â€ğŸ—¨ï¸' : 'ğŸ‘ï¸';
            });
        }


        // --- API Call Function (Keep existing implementation from original) ---
        async function callLLMApi(promptHistory) {
            if (!currentApiKey || !currentModel || !currentApiUrl) {
                throw new Error("API é…ç½®ä¸å®Œæ•´ï¼è¯·æ£€æŸ¥è®¾ç½®ã€‚");
            }
            if (isGenerating) {
                console.warn("API call requested while already generating.");
                return null; // Prevent concurrent calls
            }

            isGenerating = true;
            hideError();
            showLoading('text');
            // Disable choices while generating
            const buttons = choicesContainer.querySelectorAll('button');
            buttons.forEach(btn => btn.disabled = true);

            let finalApiUrl = currentApiUrl.trim();
            let requestBody;
            let headers = { 'Content-Type': 'application/json' };
            let method = 'POST';

            // Define the system instruction for the IF engine
            const systemInstruction = `ä½ æ˜¯ä¸€ä¸ªäº’åŠ¨å°è¯´å¼•æ“ã€‚æ ¹æ®ç”¨æˆ·æä¾›çš„å†å²è®°å½•å’Œæœ€æ–°é€‰æ‹©ï¼Œç»§ç»­æ•…äº‹ã€‚\nä½ çš„å›ç­”å¿…é¡»æ˜¯ JSON æ ¼å¼ï¼ŒåŒ…å«ä»¥ä¸‹å­—æ®µï¼š\n1. "story_text": (string) æ•…äº‹çš„ä¸‹ä¸€éƒ¨åˆ†ï¼Œç”ŸåŠ¨æè¿°å½“å‰åœºæ™¯å’Œäº‹ä»¶ã€‚ä½¿ç”¨ Markdown æ ¼å¼åŒ– (ä¾‹å¦‚ *æ–œä½“*, **ç²—ä½“**, åˆ—è¡¨ç­‰)ã€‚\n2. "image_prompt": (string) ä¸€ä¸ªç®€æ´çš„ã€è‹±æ–‡ã€‘æç¤ºè¯ (å°‘äº30è¯ï¼Œé€‚åˆ Stable Diffusion æˆ–ç±»ä¼¼æ¨¡å‹)ï¼Œæ¦‚æ‹¬ story_text ä¸­çš„æ ¸å¿ƒè§†è§‰åœºæ™¯ã€‚\n3. "choices": (array of strings) 2åˆ°4ä¸ªä¾›ç”¨æˆ·é€‰æ‹©çš„ä¸‹ä¸€æ­¥è¡ŒåŠ¨é€‰é¡¹ã€‚å¦‚æœæ•…äº‹è‡ªç„¶ç»“æŸï¼Œå¯ä»¥è¿”å›ç©ºæ•°ç»„ []ã€‚`;

            try {
                // Construct API request based on URL type (Google vs OpenAI-compatible)
                if (finalApiUrl.includes('generativelanguage.googleapis.com')) {
                    // Google Gemini API
                    if (!finalApiUrl.includes('/v1beta/models')) {
                        // Ensure the URL points to the generateContent endpoint
                        finalApiUrl = `${finalApiUrl.replace(/\/$/, '')}/v1beta/models/${currentModel}:generateContent?key=${currentApiKey}`;
                    } else {
                         // If URL already has /v1beta/models, just add key (less common case)
                         finalApiUrl = `${finalApiUrl.replace(/\/$/, '')}?key=${currentApiKey}`;
                    }
                    // Prepare request body for Gemini
                    // Map history roles: 'user' -> 'user', 'model' (AI response) -> 'model'
                    const geminiHistory = promptHistory.map(item => ({
                        role: item.role === 'model' ? 'model' : 'user', // Ensure correct role mapping
                        parts: item.parts
                    }));

                    requestBody = JSON.stringify({
                        contents: [
                            // Add System Instruction as the first part of the first 'user' turn, or as a separate system instruction if supported (v1beta content filtering might block pure system roles)
                            // Let's prepend it to the first user message conceptually if no system role available in history.
                            // Or better: include it in the *last* user message which triggers the generation
                            ...geminiHistory, // Pass the existing history
                             { role: "user", parts: [{ text: `System Prompt (Follow these instructions):\n${systemInstruction}\n\nBased on the history above, generate the next part of the story. The last user action/input was: "${promptHistory[promptHistory.length - 1].parts[0].text}"` }] }
                        ],
                        generationConfig: {
                            responseMimeType: "application/json", // Request JSON output
                            // Optional: Add temperature, topP etc. if needed
                            // temperature: 0.7,
                        },
                        // Safety settings (optional, adjust as needed)
                        // safetySettings: [
                        //     { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                        //     { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                        //     { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                        //     { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                        // ]
                    });
                    headers = { 'Content-Type': 'application/json' }; // Gemini uses Content-Type

                } else if (finalApiUrl.includes('/v1')) {
                    // OpenAI-compatible API
                    headers['Authorization'] = `Bearer ${currentApiKey}`;
                    if (!finalApiUrl.includes('/chat/completions')) {
                        // Ensure URL points to chat completions endpoint
                        finalApiUrl = `${finalApiUrl.replace(/\/v1\/?$/, '')}/v1/chat/completions`;
                    }
                     // Map history roles: 'user' -> 'user', 'model' (AI response) -> 'assistant'
                    const openaiHistory = promptHistory.map(item => ({
                        role: item.role === 'model' ? 'assistant' : 'user', // Map 'model' to 'assistant'
                        content: item.parts[0].text // OpenAI expects content as string
                    }));

                    requestBody = JSON.stringify({
                        model: currentModel,
                        messages: [
                            { role: "system", content: systemInstruction }, // Use the system role
                            ...openaiHistory // Pass mapped history
                        ],
                        response_format: { type: "json_object" } // Request JSON output
                        // Optional: Add temperature, top_p etc.
                        // temperature: 0.7,
                    });

                } else {
                    throw new Error("æ— æ³•è¯†åˆ«çš„ API åŸºç¡€åœ°å€æ ¼å¼ã€‚è¯·ç¡®ä¿åœ°å€åŒ…å« 'generativelanguage.googleapis.com' æˆ– '/v1'");
                }

                console.log("Calling LLM API:", finalApiUrl);
                // console.log("Request Body:", requestBody); // Careful logging sensitive data

                const response = await fetch(finalApiUrl, { method, headers, body: requestBody });

                if (!response.ok) {
                    let errorText = `API è¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText}`;
                    try {
                        const errorBody = await response.json();
                        // Extract specific error message if available
                        const message = errorBody?.error?.message || errorBody?.detail || JSON.stringify(errorBody);
                        errorText += `\nè¯¦ç»†ä¿¡æ¯: ${message}`;
                    } catch (_) {
                        // If response is not JSON, read as text
                        try {
                            errorText += `\nè¯¦ç»†ä¿¡æ¯: ${await response.text()}`;
                        } catch (e) { /* Ignore further errors reading response */ }
                    }
                    throw new Error(errorText);
                }

                const data = await response.json();
                console.log("LLM Raw Response:", data);

                let responseText;
                // Extract text based on API provider format
                if (data.candidates?.[0]?.content?.parts?.[0]?.text) { // Google Gemini
                    responseText = data.candidates[0].content.parts[0].text;
                } else if (data.choices?.[0]?.message?.content) { // OpenAI-compatible
                    responseText = data.choices[0].message.content;
                } else {
                    throw new Error("æ— æ³•ä» API å“åº”ä¸­æå–æœ‰æ•ˆæ–‡æœ¬ã€‚");
                }
                console.log("Extracted Response Text (Raw):", responseText);

                // Clean potential ```json markdown code blocks
                const cleanedText = responseText.replace(/^```json\s*|```$/gs, '').trim();
                console.log("Cleaned Text for Parsing:", cleanedText);

                let parsedResponse;
                try {
                    parsedResponse = JSON.parse(cleanedText);
                    // Validate required fields
                    if (!parsedResponse.story_text || typeof parsedResponse.story_text !== 'string' ||
                        !parsedResponse.image_prompt || typeof parsedResponse.image_prompt !== 'string' ||
                        !Array.isArray(parsedResponse.choices)) {
                        console.error("Parsed JSON is missing required fields or has incorrect types:", parsedResponse);
                        throw new Error("AI è¿”å›çš„ JSON å“åº”ç¼ºå°‘å¿…è¦çš„å­—æ®µ (story_text, image_prompt, choices) æˆ–ç±»å‹é”™è¯¯ã€‚");
                    }
                } catch (parseError) {
                    console.error("è§£æ LLM JSON å“åº”å¤±è´¥:", parseError);
                    console.error("æ”¶åˆ°çš„åŸå§‹æ–‡æœ¬:", responseText); // Log original raw text
                    console.error("å°è¯•è§£æçš„æ–‡æœ¬:", cleanedText); // Log the text attempted to parse

                    // Fallback: Display the raw (cleaned) text and indicate error
                    // Push error indication to history? Optional.
                     storyHistory.push({ role: "model", parts: [{ text: `(AI è¿”å›æ ¼å¼é”™è¯¯ï¼Œæ— æ³•è§£æ JSON):\n${cleanedText}` }] });
                     displayStory(`(AI è¿”å›æ ¼å¼é”™è¯¯ï¼Œæ— æ³•è§£æ JSON):\n${cleanedText}`); // Use displayStory to show the error text
                     displayChoices([]); // No valid choices
                     callPollinationsAPI("error message, confused anime character looking at code"); // Show an error image
                    return null; // Indicate failure
                }

                // Successfully parsed response
                // Push the *original parsed data structure* or just the text?
                // Let's push the clean JSON string as received from the model for history consistency.
                storyHistory.push({ role: "model", parts: [{ text: cleanedText }] });
                console.log("Parsed LLM Response:", parsedResponse);

                return parsedResponse; // Return the structured data

            } catch (error) {
                console.error("è°ƒç”¨ LLM API æ—¶å‡ºé”™:", error);
                showError(error.message || "ä¸ AI çš„è¿æ¥ä¸­æ–­ã€‚è¯·æ£€æŸ¥ç½‘ç»œæˆ– API è®¾ç½®ã€‚");
                // Attempt to roll back the last user prompt if the API call failed, preventing duplicate prompts on retry
                 if (storyHistory.length > 0 && storyHistory[storyHistory.length - 1].role === 'user') {
                     console.log("API call failed, considering rolling back last user prompt in history.");
                     // Decide if rollback is needed based on function context (e.g., called from handleChoice)
                     // For now, let's *not* automatically roll back, user might want to retry the *same* choice.
                 }
                return null; // Indicate failure
            } finally {
                 isGenerating = false;
                 hideLoading('text'); // Hide loading *after* potential error display/story update
                 // Re-enable choice buttons *only if* there are choices displayed and no error occurred that requires user action
                 const currentChoices = choicesContainer.querySelectorAll('button');
                 if (currentChoices.length > 0 && !errorMessageDiv.style.display || errorMessageDiv.style.display === 'none') {
                     currentChoices.forEach(btn => btn.disabled = false);
                 }
                 // Ensure Start Game button state is correct (might be disabled if error is config related)
                 startGameBtn.disabled = !(currentApiKey && currentModel);
            }
        }


        // --- Pollinations API (Keep existing implementation from original) ---
        function callPollinationsAPI(imagePrompt) { /* ... */
             if (!imagePrompt) {
                console.warn("No image prompt provided for Pollinations.");
                // Maybe display a placeholder or hide image area smoothly
                storyImage.style.display = 'none';
                loadingImage.style.display = 'none';
                return;
             }
             showLoading('image');
             const encodedPrompt = encodeURIComponent(imagePrompt.trim());
             // Simple parameters, adjust as needed
             const width = 768; // Slightly smaller for faster generation?
             const height = 768;
             const model = 'flux'; // Or other available models like 'turbo'
             const seed = Math.floor(Math.random() * 1e7); // Random seed per request
             const apiUrl = `https://image.pollinations.ai/prompt/${encodedPrompt}?width=${width}&height=${height}&model=${model}&seed=${seed}&nologo=true`;

             console.log("Requesting image from Pollinations:", apiUrl);
             displayImage(apiUrl); // This function handles onload/onerror
        }

        // --- *** MODIFIED UI Update Function for Markdown *** ---
        function displayStory(text) {
            hideLoading('text'); // Hide loading indicator first
            if (typeof marked !== 'undefined' && typeof DOMPurify !== 'undefined') {
                try {
                    // 1. Parse Markdown to potentially unsafe HTML using marked.js
                    const unsafeHtml = marked.parse(text);
                    // 2. Sanitize the HTML using DOMPurify to prevent XSS
                    const safeHtml = DOMPurify.sanitize(unsafeHtml);
                    // 3. Set the sanitized HTML content
                    storyTextDiv.innerHTML = safeHtml;
                } catch (e) {
                     console.error("Error during Markdown processing:", e);
                     // Fallback to textContent on processing error
                     storyTextDiv.textContent = `(Markdown å¤„ç†é”™è¯¯) ${text}`;
                }
            } else {
                // Fallback if libraries aren't loaded: display as plain text
                console.warn("Markdown libraries (marked.js or DOMPurify) not loaded. Displaying as plain text.");
                storyTextDiv.textContent = text;
            }
        }
        // --- *** END MODIFIED SECTION *** ---

        function displayImage(imageUrl) { /* ... (Keep existing implementation from original) ... */
             storyImage.onload = () => {
                 hideLoading('image');
                 storyImage.style.display = 'block'; // Show image once loaded
                 imageDisplay.style.minHeight = 'auto'; // Adjust container height after load
             };
             storyImage.onerror = () => {
                 hideLoading('image'); // Hide loading indicator
                 console.warn("Pollinations image failed to load:", imageUrl);
                 storyImage.style.display = 'none'; // Hide the broken image element
                 // Optionally display a placeholder text in the image area
                 // loadingImage.textContent = "ğŸ–¼ï¸ å›¾ç‰‡åŠ è½½å¤±è´¥";
                 // loadingImage.style.display = 'block';
             };
             storyImage.src = imageUrl; // Set src to trigger load
        }

        function displayChoices(choices) { /* ... (Keep existing implementation from original) ... */
             choicesContainer.innerHTML = ''; // Clear previous choices
             if (!choices || choices.length === 0) {
                 // If AI provided empty choices array, it might be end of story
                 const endMsg = document.createElement('p');
                 endMsg.textContent = "æ•…äº‹ä¼¼ä¹åˆ°è¾¾äº†ä¸€ä¸ªè‡ªç„¶çš„ç»ˆç‚¹ï¼Œæˆ–è€…AIæ²¡æœ‰æä¾›ä¸‹ä¸€æ­¥é€‰é¡¹ã€‚";
                 endMsg.style.fontStyle = 'italic';
                 endMsg.style.textAlign = 'center';
                 choicesContainer.appendChild(endMsg);
                 // Optionally, add a "Restart" button here?
                 return;
             }
             // Create buttons for each choice
             choices.forEach(choiceText => {
                 const btn = document.createElement('button');
                 btn.textContent = choiceText;
                 btn.className = 'choice-button';
                 btn.disabled = isGenerating; // Disable if generation is somehow still flagged (shouldn't happen here)
                 btn.onclick = () => handleChoice(choiceText); // Pass the chosen text
                 choicesContainer.appendChild(btn);
             });
         }

        // --- Game Flow Functions (Keep existing implementation from original) ---
        function startGame() { /* ... */
            if (!currentApiKey || !currentModel) {
                showError("è¯·å…ˆå®Œæˆå¹¶ä¿å­˜ API é…ç½®ï¼");
                return;
            }
            const initialUserPrompt = initialPromptInput.value.trim();
            if (!initialUserPrompt) {
                showError("è¯·è¾“å…¥æ•…äº‹çš„å¼€ç«¯æˆ–è®¾å®šã€‚");
                initialPromptInput.focus();
                return;
            }

            hideError(); // Clear any previous errors
            configSection.style.display = 'none'; // Hide config
            gameArea.style.display = 'block'; // Show game area
            startGameBtn.disabled = true; // Disable start button while game is running
            startGameBtn.textContent = 'æ•…äº‹è¿›è¡Œä¸­...'; // Update button text

            // Reset game state
            storyHistory = [];
            // Add the initial prompt as the first user message
            storyHistory.push({ role: "user", parts: [{ text: initialUserPrompt }] });

            // Start the story by calling the API with the initial prompt
            advanceStory(initialUserPrompt); // Pass the prompt for context if needed by advanceStory, though it mostly uses history now
        }

        async function advanceStory(userChoiceOrPrompt) { /* ... */
            // This function now primarily relies on the storyHistory being up-to-date
            // The userChoiceOrPrompt argument is less critical if handleChoice updates history first

            console.log("Advancing story. Current history length:", storyHistory.length);
            // Call the LLM API with the current history
            const result = await callLLMApi(storyHistory); // Pass the entire history

             if (result) {
                 // API call was successful and returned parsed data
                 console.log("LLM result processed, updating UI:", result);
                 displayStory(result.story_text); // Display the story text (will be Markdown parsed)
                 displayChoices(result.choices); // Display the new choices
                 callPollinationsAPI(result.image_prompt); // Request the image
             } else {
                 // API call failed or returned null (error handled within callLLMApi)
                 console.log("advanceStory received null result from callLLMApi. UI should show error.");
                 // Error message is already shown by showError called inside callLLMApi or its catch block
                 // We might not need to do anything else here, maybe re-enable choices if appropriate?
                 // Re-enabling choices is handled in showError and the finally block of callLLMApi
             }
        }

        function handleChoice(choiceText) { /* ... */
            if (isGenerating) {
                console.warn("Choice clicked while generation in progress.");
                return; // Prevent action if already generating
            }
            console.log("User chose:", choiceText);

            // Disable all choice buttons immediately to prevent multiple clicks
            const buttons = choicesContainer.querySelectorAll('button');
            buttons.forEach(btn => btn.disabled = true);

            // Add the user's choice to the history
            storyHistory.push({ role: "user", parts: [{ text: choiceText }] });

            // Call advanceStory to get the next part from the AI
            // No need to pass choiceText here as advanceStory uses the history object
            advanceStory();
        }

        // --- Event Listeners (Keep existing implementation from original) ---
        startGameBtn.addEventListener('click', startGame);
        fetchModelsBtn.addEventListener('click', fetchLLMModels);

        // Save config automatically when relevant fields change
        modelSelect.addEventListener('change', saveConfig);
        apiKeyInput.addEventListener('input', saveConfig); // Use 'input' for immediate feedback on typing/pasting
        apiUrlInput.addEventListener('input', saveConfig); // Use 'input' for immediate feedback

        // Also save config when fetching models completes successfully (handled within fetchLLMModels -> saveConfig)


        // --- Initial Load ---
        loadConfig(); // Load saved settings on page load

    }); // End DOMContentLoaded
    </script>
</body>
</html>